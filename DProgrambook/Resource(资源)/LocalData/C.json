 [
        {
            "ID": "461",
            "typeID": "12",
            "question": "语句for( ；1 ；)有什么问题？它是什么意思？",
            "answer": "无限循环，和while(1)相同。"
        },
        {
            "ID": "460",
            "typeID": "12",
            "question": "全局变量可不可以定义在可被多个.C文件包含的头文件中？为什么？",
            "answer": "可以，在不同的C文件中以static形式来声明同名全局变量。\r\n    可以在不同的C文件中声明同名的全局变量，前提是其中只能有一个C文件中对此变量赋初值，此时连接不会出错。"
        },
        {
            "ID": "459",
            "typeID": "12",
            "question": "如何引用一个已经定义过的全局变量？",
            "answer": "extern\r\n     可以用引用头文件的方式，也可以用extern关键字，如果用引用头文件方式来引用某个在头文件中声明的全局变理，假定你将那个变写错了，那么在编译期间 会报错，如果你用extern方式引用时，假定你犯了同样的错误，那么在编译期间不会报错，而在连接期间报错。"
        },
        {
            "ID": "458",
            "typeID": "12",
            "question": "局部变量能否和全局变量重名？",
            "answer": "能，局部会屏蔽全局。要用全局变量，需要使用\"::\"\r\n局部变量可以与全局变量同名，在函数内引用这个变量时，会用到同名的局部变量，而不会用到全局变量。对于有些编译器而言，在同一个函数内可以定义多个同名的局部变量，比如在两个循环体内都定义一个同名的局部变量，而那个局部变量的作用域就在那个循环体内。"
        },
        {
            "ID": "457",
            "typeID": "12",
            "question": "Internet物理地址和IP地址转换采用什么协议？",
            "answer": "ARP (Address Resolution Protocol)（地址解析協議）"
        },
        {
            "ID": "456",
            "typeID": "12",
            "question": "Internet采用哪种网络协议？该协议的主要层次结构？",
            "answer": "Tcp/Ip协议\r\n主要层次结构为： 应用层/传输层/网络层/数据链路层/物理层。"
        },
        {
            "ID": "455",
            "typeID": "12",
            "question": "冒泡排序算法的时间复杂度是什么？",
            "answer": "时间复杂度是O(n^2)。"
        },
        {
            "ID": "454",
            "typeID": "12",
            "question": "什么函数不能声明为虚函数？",
            "answer": "constructor函数不能声明为虚函数。"
        },
        {
            "ID": "453",
            "typeID": "12",
            "question": "堆栈溢出一般是由什么原因导致的？",
            "answer": "没有回收垃圾资源。"
        },
        {
            "ID": "452",
            "typeID": "12",
            "question": "什么是平衡二叉树？",
            "answer": "左右子树都是平衡二叉树 且左右子树的深度差值的绝对值不大于1。"
        },
        {
            "ID": "451",
            "typeID": "12",
            "question": "全局变量和局部变量在内存中是否有区别？如果有，是什么区别？",
            "answer": "全局变量储存在静态数据库，局部变量在堆栈。"
        },
        {
            "ID": "450",
            "typeID": "12",
            "question": "引用与指针有什么区别？",
            "answer": "1) 引用必须被初始化，指针不必。\r\n2) 引用初始化以后不能被改变，指针可以改变所指的对象。\r\n3) 不存在指向空值的引用，但是存在指向空值的指针。"
        },
        {
            "ID": "449",
            "typeID": "12",
            "question": "动态连接库的两种方式?",
            "answer": "调用一个DLL中的函数有两种方法：\r\n1．载入时动态链接（load-time dynamic linking），模块非常明确调用某个导出函数\r\n，使得他们就像本地函数一样。这需要链接时链接那些函数所在DLL的导入库，导入库向\r\n系统提供了载入DLL时所需的信息及DLL函数定位。 \r\n2．运行时动态链接（run-time dynamic linking），运行时可以通过LoadLibrary或Loa\r\ndLibraryEx函数载入DLL。DLL载入后，模块可以通过调用GetProcAddress获取DLL函数的\r\n出口地址，然后就可以通过返回的函数指针调用DLL函数了。如此即可避免导入库文件了\r\n。"
        },
        {
            "ID": "447",
            "typeID": "12",
            "question": "int i=10, j=10, k=3; k*=i+j; k最后的值是？",
            "answer": "60，此题考察优先级，实际写成： k*=(i+j);，赋值运算符优先级最低"
        },
        {
            "ID": "446",
            "typeID": "12",
            "question": "关于内存对齐的问题以及sizof()的输出",
            "answer": "编译器自动对齐的原因：为了提高程序的性能，数据结构（尤其是栈）应该尽可能\r\n地在自然边界上对齐。原因在于，为了访问未对齐的内存，处理器需要作两次内存访问\r\n；然而，对齐的内存访问仅需要一次访问。"
        },
        {
            "ID": "445",
            "typeID": "12",
            "question": "SQL Server是否支持行级锁，有什么好处？",
            "answer": "支持，设立封锁机制主要是为了对并发操作进行控制，对干扰进行封锁，保证数据\r\n的一致性和准确性，行级封锁确保在用户取得被更新的行到该行进行更新这段时间内不\r\n被其它用户所修改。因而行级锁即可保证数据的一致性又能提高数据操作的迸发性。"
        },
        {
            "ID": "444",
            "typeID": "12",
            "question": "一般数据库若出现日志满了，会出现什么情况，是否还能使用？",
            "answer": "只能执行查询等读操作，不能执行更改，备份等写操作，原因是任何写操作都要记\r\n录日志。也就是说基本上处于不能使用的状态。"
        },
        {
            "ID": "443",
            "typeID": "12",
            "question": "函数模板与类模板有什么区别？",
            "answer": "函数模板的实例化是由编译程序在处理函数调用时自动完成的，而类模板的实例化\r\n必须由程序员在程序中显式地指定。"
        },
        {
            "ID": "442",
            "typeID": "12",
            "question": "使用线程是如何防止出现大的波峰？",
            "answer": "意思是如何防止同时产生大量的线程，方法是使用线程池，线程池具有可以同时提\r\n高调度效率和限制资源使用的好处，线程池中的线程达到最大数时，其他线程就会排队\r\n等候。"
        },
        {
            "ID": "441",
            "typeID": "12",
            "question": "C++中什么数据分配在栈或堆中，New分配数据是在近堆还是远堆中？",
            "answer": "栈: 存放局部变量，函数调用参数,函数返回值，函数返回地址，由系统管理\r\n堆: 程序运行时动态申请，new 和　malloc申请的内存就在堆上\r\nnew在近堆"
        },
        {
            "ID": "440",
            "typeID": "12",
            "question": "Linux有内核级线程么？",
            "answer": "线程通常被定义为一个进程中代码的不同执行路线。从实现方式上划分，线程有两\r\n种类型：“用户级线程”和“内核级线程”。 用户线程指不需要内核支持而在用户程序\r\n中实现的线程，其不依赖于操作系统核心，应用进程利用线程库提供创建、同步、调度\r\n和管理线程的函数来控制用户线程。这种线程甚至在象 DOS 这样的操作系统中也可实现\r\n，但线程的调度需要用户程序完成，这有些类似 Windows 3.x 的协作式多任务。另外一\r\n种则需要内核的参与，由内核完成线程的调度。其依赖于操作系统核心，由内核的内部\r\n需求进行创建和撤销，这两种模型各有其好处和缺点。用户线程不需要额外的内核开支\r\n，并且用户态线程的实现方式可以被定制或修改以适应特殊应用的要求，但是当一个线\r\n程因 I/O 而处于等待状态时，整个进程就会被调度程序切换为等待状态，其他线程得不\r\n到运行的机会；而内核线程则没有各个限制，有利于发挥多处理器的并发优势，但却占\r\n用了更多的系统开支。 "
        },
        {
            "ID": "439",
            "typeID": "12",
            "question": "程序什么时候应该使用线程，什么时候单线程效率高？",
            "answer": "1．耗时的操作使用线程，提高应用程序响应\r\n2．并行操作时使用线程，如C/S架构的服务器端并发线程响应用户的请求。\r\n3．多CPU系统中，使用线程提高CPU利用率\r\n4．改善程序结构。一个既长又复杂的进程可以考虑分为多个线程，成为几个独立或半独\r\n立的运行部分，这样的程序会利于理解和修改。"
        },
        {
            "ID": "438",
            "typeID": "12",
            "question": "NEWTEXTMETRIC 是什么？",
            "answer": "物理字体结构，用来设置字体的高宽大小"
        },
        {
            "ID": "437",
            "typeID": "12",
            "question": "CSingleLock是干什么的。",
            "answer": "同步多个线程对一个数据类的同时访问"
        },
        {
            "ID": "436",
            "typeID": "12",
            "question": "C++中为什么用模板类？",
            "answer": "(1)可用来创建动态增长和减小的数据结构\r\n（2）它是类型无关的，因此具有很高的可复用性。\r\n（3）它在编译时而不是运行时检查数据类型，保证了类型安全\r\n（4）它是平台无关的，可移植性\r\n（5）可用于基本数据类型"
        },
        {
            "ID": "435",
            "typeID": "12",
            "question": "MFC中CString是类型安全类么？",
            "answer": "不是，其它数据类型转换到CString可以使用CString的成员函数Format来转换"
        },
        {
            "ID": "434",
            "typeID": "12",
            "question": "编写strcat函数",
            "answer": "已知strcat函数的原型是char *strcat (char *strDest, const char *strSrc);\r\n其中strDest 是目的字符串，strSrc 是源字符串。\r\n（1）不调用C++/C 的字符串库函数，请编写函数 strcat\r\n答：\r\nVC源码：\r\nchar * __cdecl strcat (char * dst, const char * src)\r\n{\r\nchar * cp = dst;\r\nwhile( *cp )\r\ncp++; /* find end of dst */\r\nwhile( *cp++ = *src++ ) ; /* Copy src to end of dst */\r\nreturn( dst ); /* return dst */\r\n}\r\n（2）strcat能把strSrc 的内容连接到strDest，为什么还要char * 类型的返回值？\r\n答：方便赋值给其他变量"
        },
        {
            "ID": "433",
            "typeID": "12",
            "question": "switch()中不允许的数据类型是?",
            "answer": "实型"
        },
        {
            "ID": "432",
            "typeID": "12",
            "question": "在C++ 程序中调用被 C 编译器编译后的函数，为什么要加 extern “C”声明？",
            "answer": "函数和变量被C++编译后在符号库中的名字与C语言的不同，被extern \"C\"修饰的变\r\n量和函数是按照C语言方式编译和连接的。由于编译后的名字不同，C++程序不能直接调\r\n用C 函数。C++提供了一个C 连接交换指定符号extern“C”来解决这个问题。\r\n"
        },
        {
            "ID": "431",
            "typeID": "12",
            "question": "＃i nclude 和 ＃i nclude “filename.h” 有什么区别？",
            "answer": "前者用来包含开发环境提供的库头文件，后者用来包含自己编写的头文件。"
        },
        {
            "ID": "430",
            "typeID": "12",
            "question": "头文件中的 ifndef/define/endif 干什么用？",
            "answer": "防止头文件被重复引用"
        },
        {
            "ID": "429",
            "typeID": "12",
            "question": "关键字volatile有什么含意?",
            "answer": "一个定义为volatile的变量是说这变量可能会被意想不到地改变，这样，编译器就不会去假设这个变量的值了。精确地说就是，优化器在用到这个变量时必须每次都小心地重新读取这个变量的值，而不是使用保存在寄存器里的备份。下面是volatile变量的几个例子：\r\n1) 并行设备的硬件寄存器（如：状态寄存器）\r\n2) 一个中断服务子程序中会访问到的非自动变量(Non-automatic variables)\r\n3) 多线程应用中被几个任务共享的变量"
        },
        {
            "ID": "428",
            "typeID": "12",
            "question": "关键字const有什么含意？",
            "answer": "1) 关键字const的作用是为给读你代码的人传达非常有用的信息，实际上，声明一个参数为常量是为了告诉了用户这个参数的应用目的。如果你曾花很多时间清理 其它人留下的垃圾，你就会很快学会感谢这点多余的信息。（当然，懂得用const的程序员很少会留下的垃圾让别人来清理的。）\r\n2) 通过给优化器一些附加的信息，使用关键字const也许能产生更紧凑的代码。\r\n3) 合理地使用关键字const可以使编译器很自然地保护那些不希望被改变的参数，防止其被无意的代码修改。简而言之，这样可以减少bug的出现。"
        },
        {
            "ID": "427",
            "typeID": "12",
            "question": "关键字static的作用是什么？",
            "answer": "在C语言中，关键字static有三个明显的作用：\r\n1)在函数体，一个被声明为静态的变量在这一函数被调用过程中维持其值不变。\r\n2) 在模块内（但在函数体外），一个被声明为静态的变量可以被模块内所用函数访问，但不能被模块外其它函数访问。它是一个本地的全局变量。\r\n3) 在模块内，一个被声明为静态的函数只可被这一模块内的其它函数调用。那就是，这个函数被限制在声明它的模块的本地范围内使用。"
        },
        {
            "ID": "426",
            "typeID": "12",
            "question": "怎么样用C编写死循环呢？",
            "answer": "while(1)\r\n{\r\n}\r\n"
        },
        {
            "ID": "425",
            "typeID": "12",
            "question": "写一个\"标准\"宏MIN ，这个宏输入两个参数并返回较小的一个？",
            "answer": " #define MIN(A,B) （（A） <= (B) ? (A) : (B)) "
        },
        {
            "ID": "424",
            "typeID": "12",
            "question": "用预处理指令#define 声明一个常数，用以表明1年中有多少秒（忽略闰年问题）",
            "answer": " #define SECONDS_PER_YEAR (60 * 60 * 24 * 365)UL"
        },
        {
            "ID": "277",
            "typeID": "12",
            "question": "请编写函数fun，其功能是：将两个两位数的正整数a、b合并形成一个整数放在c中。合并的方式是：将a数的十位和个位数依次放在c数的千位和十位上，b数的十位和个位数依次放在c数的百位和个位上。",
            "answer": "#include <conio.h>\r\n\r\n#include <stdio.h>\r\n\r\n \r\n\r\nvoid fun (int a, int b ,long *c)\r\n\r\n{\r\n\r\n}\r\n\r\n \r\n\r\nmain ()\r\n\r\n{\r\n\r\nint a,b;\r\n\r\nlong c;\r\n\r\nclrscr ();\r\n\r\nprintf (“Input a, b:”);\r\n\r\nscanf(“%d%d”, &a, &b);\r\n\r\nfun (a, b, &c);\r\n\r\nprintf (“The result is: %d\n”,  c);\r\n\r\n}"
        },
        {
            "ID": "276",
            "typeID": "12",
            "question": "编写一个函数，该函数可以统计一个长度为2的字符串在另一个字符串中出现的次数。例如，假定输入的字符串为：asd asasdfg asd as zx67 asd mklo，子字符串为as，则应输出6。",
            "answer": "#include <stdio.h>\r\n\r\n#include <string.h>\r\n\r\n#include <conio.h>\r\n\r\n \r\n\r\nint fun(char *str,char *substr)\r\n\r\n{\r\n\r\n \r\n\r\n}\r\n\r\n \r\n\r\nmain()\r\n\r\n{\r\n\r\nchar str[81],substr[3];\r\n\r\nint n;\r\n\r\n \r\n\r\nclrscr() ;\r\n\r\nprintf(“输入主字符串: “);\r\n\r\ngets(str);\r\n\r\nprintf(“输入子字符串: “);\r\n\r\ngets(substr);\r\n\r\nputs(str);\r\n\r\nputs(substr);\r\n\r\nn=fun(str,substr);\r\n\r\nprintf(“n=%d\n”,n);\r\n\r\n}"
        },
        {
            "ID": "275",
            "typeID": "12",
            "question": "下列给定程序中，函数fun的功能是：给一维数组a输入任意4个整数，并按如下的规律输出。例如输入1、2、3、4",
            "answer": "#include <stdio.h>\r\n\r\n#define   M   4\r\n\r\n \r\n\r\n/********found********/\r\n\r\nint fun(int a)\r\n\r\n{\r\n\r\nint i,j,k,m;\r\n\r\nprintf(“Enter 4 number : “);\r\n\r\nfor(i=0; i<M; i++)\r\n\r\nscanf(“%d”,&a[i]);\r\n\r\nprintf(“\n\nThe result  :\n\n”);\r\n\r\nfor(i=M;i>0;i–)\r\n\r\n{\r\n\r\nk=a[M-1];\r\n\r\n/********found********/\r\n\r\nfor(j=M-1;j>0;j–)\r\n\r\na[j]=a[j+1];\r\n\r\na[0]=k;\r\n\r\nfor(m=0; m<M; m++)\r\n\r\nprintf(“%d  “,a[m]);\r\n\r\nprintf(“\n”);\r\n\r\n}\r\n\r\n}\r\n\r\nmain()\r\n\r\n{\r\n\r\nint a[M];\r\n\r\nfun(a);\r\n\r\nprintf(“\n\n”);\r\n\r\n}\r\n"
        },
        {
            "ID": "274",
            "typeID": "12",
            "question": "编写一个函数fun，它的功能是：实现两个字符串的连接（不使用库函数strcat），即把p2所指的字符串连接到p1所指的字符串后。",
            "answer": "#include <stdio.h>\r\n\r\n#include <conio.h>\r\n\r\n \r\n\r\nvoid fun(char p1[], char p2[])\r\n\r\n{\r\n\r\n}\r\n\r\n \r\n\r\nmain()\r\n\r\n{\r\n\r\nchar s1[80], s2[40] ;\r\n\r\nclrscr() ;\r\n\r\nprintf(“Enter s1 and s2:\n”) ;\r\n\r\nscanf(“%s%s”, s1, s2) ;\r\n\r\nprintf(“s1=%s\n”, s1) ;\r\n\r\nprintf(“s2=%s\n”, s2) ;\r\n\r\nprintf(“Invoke fun(s1,s2):\n”) ;\r\n\r\nfun(s1, s2) ;\r\n\r\nprintf(“After invoking:\n”) ;\r\n\r\nprintf(“%s\n”, s1) ;\r\n\r\n}"
        },
        {
            "ID": "273",
            "typeID": "12",
            "question": "请编写函数fun，它的功能是计算：\r\n\r\ns =  (ln(1)+ln(2)+ln(3)+…+ln(m))0.5，\r\n\r\ns作为函数值返回。在C语言中可调用log(n)函数求ln(n)。log函数的引用说明是：double log(double x)。例如，若m的值为20，则fun函数值为6.506583。",
            "answer": "#include <conio.h>\r\n\r\n#include <math.h>\r\n\r\n#include <stdio.h>\r\n\r\n \r\n\r\ndouble  fun( int  m )\r\n\r\n{\r\n\r\n}\r\n\r\n \r\n\r\nmain()\r\n\r\n{\r\n\r\nclrscr();\r\n\r\nprintf(“%f\n”,fun(20));\r\n\r\n}"
        },
        {
            "ID": "272",
            "typeID": "12",
            "question": "堆和栈的理论知识",
            "answer": " 申请方式\r\n栈: 由系统自动分配。 例如，声明在函数中一个局部变量 int a; 系统自动在栈中为a开辟空间\r\n堆: 需要程序员自己申请，并指明大小，在c中malloc函数：如p1 = (char *)malloc(10); 在C++中用new运算符 如p2 = (char *)malloc(10); 但是注意局部变量p1、p2本身是在栈中的，但是他们指向的申请到的内存是在堆区，这点要明确!\r\n申请后系统的响应\r\n栈：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。\r\n堆：首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时， 会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序，另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的delete语句才能正确的释放本内存空间。另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。\r\n申请大小的限制\r\n栈：在Windows下,栈是向低地址扩展的数据结构，是一块连续的内存区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，在WINDOWS下，栈的大小是2M(也有的说是1M，总之是一个编译时就确定的常数)，如果申请的空间超过栈的剩余空间时，将提示overflow。因此，能从栈获得的空间较小。\r\n堆：堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。\r\n 申请效率的比较：\r\n栈：由系统自动分配，速度较快。但程序员是无法控制的。\r\n堆：是由malloc/new分配的内存，一般速度比较慢，而且容易产生内存碎片,不过用起来最方便。\r\n\r\n 堆和栈中的存储内容\r\n栈： 在函数调用时，第一个进栈的是主函数中的下一条指令(函数调用语句的下一条可执行语句)的地址，然后是函数的各个参数，在大多数的C编译器中，参数是由右往左入栈的，然后是函数中的局部变量。注意静态变量是不入栈的。当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。\r\n堆：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容有程序员安排。\r\n\r\n存取效率的比较\r\nchar s1［］ = “aaaaaaaaaaaaaaa”;\r\nchar *s2 = “bbbbbbbbbbbbbbbbb”;\r\naaaaaaaaaaa是在运行时刻赋值的；\r\n而bbbbbbbbbbb是在编译时就确定的；\r\n但是，在以后的存取中，在栈上的数组比指针所指向的字符串(例如堆)快。\r\n比如：\r\n#include\r\nvoid main()\r\n{\r\nchar a = 1;\r\nchar c［］ = “1234567890″;\r\nchar *p =”1234567890″;\r\na = c［1］;\r\na = p［1］;\r\nreturn;\r\n}\r\n对应的汇编代码\r\n10: a = c［1］;\r\n00401067 8A 4D F1 mov cl,byte ptr ［ebp-0Fh］\r\n0040106A 88 4D FC mov byte ptr ［ebp-4］,cl\r\n11: a = p［1］;\r\n0040106D 8B 55 EC mov edx,dword ptr ［ebp-14h］\r\n00401070 8A 42 01 mov al,byte ptr ［edx+1］\r\n00401073 88 45 FC mov byte ptr ［ebp-4］,al\r\n第一种在读取时直接就把字符串中的元素读到寄存器cl中，而第二种则要先把指针值读到edx中，在根据edx读取字符，显然慢了。\r\n小结\r\n堆和栈的区别可以用如下的比喻来看出： 使用栈就象我们去饭馆里吃饭，只管点菜(发出申请)、付钱、和吃(使用)，吃饱了就走，不必理会切菜、洗菜等准备工作和洗碗、刷锅等扫尾工作，他的好处是快捷，但是自由度小。使用堆就象是自己动手做喜欢吃的菜肴，比较麻烦，但是比较符合自己的口味，而且自由度大。\r\n还有就是函数调用时会在栈上有一系列的保留现场及传递参数的操作。栈的空间大小有限定，VC的缺省是2M。栈不够用的情况一般是程序中分配了大量数组和递归函数层次太深。有一点必须知道，当一个函数调用完返回后它会释放该函数中所有的栈空间。栈是由编译器自动管理的，不用你操心。堆是动态分配内存的，并且你可以分配使用很大的内存。但是用不好会产生内存泄漏。并且频繁地malloc和free会产生内存碎片(有点类似磁盘碎片)，因为C分配动态内存时是寻找匹配的内存的。而用栈则不会产生碎片。在栈上存取数据比通过指针在堆上存取数据快些。一般大家说的堆栈和栈是一样的，就是栈(stack)，而说堆时才是堆heap。栈是先入后出的，一般是由高地址向低地址生长。"
        },
        {
            "ID": "271",
            "typeID": "12",
            "question": "程序的内存分配",
            "answer": "1、栈区(stack)： 由编译器自动分配释放，存放函数的参数值，局部变量等。其操作方式类似于数据结构中的栈。\r\n2、堆区(heap)： 一般由程序员分配释放（malloc/free、new/delete）， 若程序员不释放，程序结束时可能由操作系统回收。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表。\r\n3、全局区(static)： 全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域， 未初始化的全局变量和未初始化的静态变量在相邻的另一块区域，程序结束后由系统释放。\r\n4、文字常量区： 常量字符串就是放在这里的， 程序结束后由系统释放。\r\n5、程序代码区： 存放函数体的二进制代码。\r\nExample:\r\nint a = 0; // 全局初始化区\r\nchar *p1; // 全局未初始化区\r\nmain()\r\n{\r\nint a; // 栈区\r\nchar s［］ = “abc”; // 栈区\r\nchar *p2; // 栈区\r\nchar *p3 = “123456″; // 123456\u0000在常量区，p3在栈上。\r\nstatic int c =0； // 全局(静态)初始化区\r\np1 = (char *)malloc(10);\r\np2 = (char *)malloc(20); // 分配得来得10和20字节的区域就在堆区。\r\nstrcpy(p1, “123456″); // 123456\u0000放在常量区，编译器可能会将它与p3所指向的”123456″优化成一个地方。\r\n}"
        },
        {
            "ID": "270",
            "typeID": "12",
            "question": "c++内存泄漏检测",
            "answer": "检测内存泄漏的方法多种多样，有使用内存泄漏检测工具（比如BoundsChecker）检测内存泄漏；有直接看代码检测代码逻辑，看那些地方是否没有释放内存。一般地静态内存泄漏通过工具与代码检查很容易找到泄漏点；动态的内存泄漏很难查，一般通过在代码中加断点跟踪和Run-Time内存检测工具来查找。"
        },
        {
            "ID": "269",
            "typeID": "12",
            "question": "C++内存泄漏的发生方式",
            "answer": "1. 常发性内存泄漏。发生内存泄漏的代码会被多次执行到，每次被执行的时候都会导致一块内存泄漏。比如例二，如果Something()函数一直返回True，那么pOldBmp指向的HBITMAP对象总是发生泄漏。\r\n\r\n2. 偶发性内存泄漏。发生内存泄漏的代码只有在某些特定环境或操作过程下才会发生。比如例二，如果Something()函数只有在特定环境下才返回True，那么pOldBmp指向的HBITMAP对象并不总是发生泄漏。常发性和偶发性是相对的。对于特定的环境，偶发性的也许就变成了常发性的。所以测试环境和测试方法对检测内存泄漏至关重要。\r\n\r\n3. 一次性内存泄漏。发生内存泄漏的代码只会被执行一次，或者由于算法上的缺陷，导致总会有一块仅且一块内存发生泄漏。比如，在类的构造函数中分配内存，在析构函数中却没有释放该内存，但是因为这个类是一个Singleton，所以内存泄漏只会发生一次。\r\n\r\n4. 隐式内存泄漏。程序在运行过程中不停的分配内存，但是直到结束的时候才释放内存。严格的说这里并没有发生内存泄漏，因为最终程序释放了所有申请的内存。但是对于一个 服务器程序，需要运行几天，几周甚至几个月，不及时释放内存也可能导致最终耗尽系统的所有内存。所以，我们称这类内存泄漏为隐式内存泄漏。"
        },
        {
            "ID": "268",
            "typeID": "12",
            "question": "不能做switch（）的参数类型是：",
            "answer": "SWITH（表达式），表达式可以是整型、字符型以及枚举类型等表达式。\r\n\r\nswitch的参数不能为实型。"
        },
        {
            "ID": "267",
            "typeID": "12",
            "question": "用户输入M，N值，从1至N开始顺序循环数数，每数到M输出该数值，直至全部输出。写出C程序。",
            "answer": "循环链表，用取余操作做 ——>？？"
        },
        {
            "ID": "266",
            "typeID": "12",
            "question": "IP地址的编码分为哪俩部分？",
            "answer": "IP地址由两部分组成，网络号和主机号。不过是要和“子网掩码”按位与上之后才能区分哪些是网络位哪些是主机位。"
        },
        {
            "ID": "265",
            "typeID": "12",
            "question": "Internet物理地址和IP地址转换采用什么协议？",
            "answer": "ARP （Address Resolution Protocol）（地址解析协议）"
        },
        {
            "ID": "264",
            "typeID": "12",
            "question": " Internet采用哪种网络协议？该协议的主要层次结构？",
            "answer": "tcp/ip 应用层/传输层/网络层/数据链路层/物理层"
        },
        {
            "ID": "263",
            "typeID": "12",
            "question": "写出float x 与“零值”比较的if语句。",
            "answer": "if（x>0.000001&&x<-0.000001）"
        },
        {
            "ID": "262",
            "typeID": "12",
            "question": " 冒泡排序算法的时间复杂度是什么？",
            "answer": "O（n^2）"
        },
        {
            "ID": "261",
            "typeID": "12",
            "question": "什么函数不能声明为虚函数？",
            "answer": "constructor ==>C++中的类的构造函数声明"
        },
        {
            "ID": "260",
            "typeID": "12",
            "question": "堆栈溢出一般是由什么原因导致的？",
            "answer": "没有回收垃圾资源\r\n"
        },
        {
            "ID": "259",
            "typeID": "12",
            "question": "什么是平衡二叉树？",
            "answer": "左右子树都是平衡二叉树 且左右子树的深度差值的绝对值不大于1"
        },
        {
            "ID": "258",
            "typeID": "12",
            "question": "全局变量和局部变量在内存中是否有区别？如果有，是什么区别？",
            "answer": "全局变量储存在静态数据区，局部变量在堆栈"
        },
        {
            "ID": "257",
            "typeID": "12",
            "question": "描述实时系统的基本特性",
            "answer": "在特定时间内完成特定的任务，实时性与可靠性"
        },
        {
            "ID": "256",
            "typeID": "12",
            "question": "引用与指针有什么区别？",
            "answer": "1） 引用必须被初始化，指针不必。\r\n\r\n2） 引用初始化以后不能被改变，指针可以改变所指的对象。\r\n\r\n3） 不存在指向空值的引用，但是存在指向空值的指针。"
        },
        {
            "ID": "255",
            "typeID": "12",
            "question": "static有什么用途？（请至少说明两种）",
            "answer": "1.限制变量的作用域\r\n\r\n2.设置变量的存储域"
        },
        {
            "ID": "254",
            "typeID": "12",
            "question": "C++继承机制",
            "answer": "n类成员的访问控制方式\r\n\r\npublic：类本身、派生类和其它类均可访问；\r\n\r\nprotected：类本身和派生类均可访问，其它类不能访问；\r\n\r\nprivate（默认）：类本身可访问，派生类和其它类不能访问。"
        },
        {
            "ID": "253",
            "typeID": "12",
            "question": "软件开发流程",
            "answer": "需求分析和项目计划：可行性计划，项目计划，需求分析，测试计划\r\n\r\n软件设计说明书：功能设计说明书，实现设计说明书\r\n\r\n使用手册\r\n\r\n测试报告\r\n\r\n项目总结"
        },
        {
            "ID": "252",
            "typeID": "12",
            "question": "C++多态实现机制",
            "answer": "在C++中，对于有virtual的类，其sizeof会比正常情况多处4个字节。既在类的最开始四个字节，放的是VTABLE表的地址（void *类型）。而在VTABLE中，所有虚函数是以指针数组的形式存放。 对于派生的类，即时没有重载基类的虚函数，也会在其VTABLE占用一格。造成空间上的浪费。非虚基类没有VTABLE，VTABLE是在构造的时候编译器生成的。"
        },
        {
            "ID": "251",
            "typeID": "12",
            "question": "找出两个字符串中最大公共子字符串,如\"abccade\",\"dgcadde\"的最大子串为\"cad\" ",
            "answer": "int GetCommon(char *s1, char *s2, char **r1, char **r2)\r\n{\r\nint len1 = strlen(s1);\r\nint len2 = strlen(s2);\r\nint maxlen = 0;\r\nfor(int i = 0; i < len1; i++)\r\n{\r\nfor(int j = 0; j < len2; j++)\r\n{\r\nif(s1[i] == s2[j])\r\n{\r\nint as = i, bs = j, count = 1;\r\nwhile(as + 1 < len1 && bs + 1 < len2 && s1[++as] == s2[++bs])\r\ncount++;\r\nif(count > maxlen)\r\n{\r\nmaxlen = count;\r\n*r1 = s1 + i;\r\n*r2 = s2 + j;\r\n}\r\n}\r\n}\r\n}\r\n"
        },
        {
            "ID": "243",
            "typeID": "12",
            "question": "谈谈你对面向对象的认识",
            "answer": "面向对象可以理解成对待每一个问题,都是首先要确定这个问题由几个部分组成,而每一个部分其 实就是一个对象。然后再分别设计这些对象,最后得到整个程序。传统的程序设计多是基于功能的思想 来进行考虑和设计的,而面向对象的程序设计则是基于对象的角度来考虑问题。这样做能够使得程序更 加的简洁清晰。\r\n说明:编程中接触最多的“面向对象编程技术”仅仅是面向对象技术中的一个组成部分。发挥面向 对象技术的优势是一个综合的技术问题,不仅需要面向对象的分析,设计和编程技术,而且需要借助必 要的建模和开发工具。"
        },
        {
            "ID": "242",
            "typeID": "12",
            "question": "用 C 编写一个死循环程序",
            "answer": "while(1)\r\n{}\r\n说明:很多种途径都可实现同一种功能,但是不同的方法时间和空间占用度不同,特别是对于嵌入\r\n式软件,处理器速度比较慢,存储空间较小,所以时间和空间优势是选择各种方法的首要考虑条件。"
        },
        {
            "ID": "241",
            "typeID": "12",
            "question": "简述 strcpy、sprintf 与 memcpy 的区别",
            "answer": "三者主要有以下不同之处:\r\n(1)操作对象不同,strcpy的两个操作对象均为字符串,sprintf的操作源对象可以是多种数据类型,目的操作对象是字符串,memcpy 的两个对象就是两个任意可操作的内存地址,并不限于何种数据类型。 (2)执行效率不同,memcpy 最高,strcpy 次之,sprintf 的效率最低。\r\n(3)实现功能不同,strcpy 主要实现字符串变量间的拷贝,sprintf 主要实现其他数据类型格式到字\r\n符串的转化,memcpy 主要是内存块间的拷贝。\r\n说明:strcpy、sprintf 与 memcpy 都可以实现拷贝的功能,但是针对的对象不同,根据实际需求,来\r\n选择合适的函数实现拷贝功能。\r\n"
        },
        {
            "ID": "240",
            "typeID": "12",
            "question": "常引用有什么作用",
            "answer": "常引用的引入主要是为了避免使用变量的引用时,在不知情的情况下改变变量的值。常引用主要用 于定义一个普通变量的只读属性的别名、作为函数的传入形参,避免实参在调用函数中被意外的改变。\r\n说明:很多情况下,需要用常引用做形参,被引用对象等效于常对象,不能在函数中改变实参的值, 这样的好处是有较高的易读性和较小的出错率。"
        },
        {
            "ID": "239",
            "typeID": "12",
            "question": "如何避免“野指针”",
            "answer": "“野指针”产生原因及解决办法如下:\r\n(1)指针变量声明时没有被初始化。解决办法:指针声明时初始化,可以是具体的地址值,也可 让它指向 NULL。\r\n(2)指针 p 被 free 或者 delete 之后,没有置为 NULL。解决办法:指针指向的内存空间被释放 后指针应该指向 NULL。\r\n(3)指针操作超越了变量的作用范围。解决办法:在变量的作用域结束前释放掉变量的地址空间 并且让指针指向 NULL。\r\n注意:“野指针”的解决方法也是编程规范的基本原则,平时使用指针时一定要避免产生“野指针”, 在使用指针前一定要检验指针的合法性。"
        },
        {
            "ID": "238",
            "typeID": "12",
            "question": "简述指针常量与常量指针区别\r\n",
            "answer": "指针常量是指定义了一个指针,这个指针的值只能在定义时初始化,其他地方不能改变。常量指针 是指定义了一个指针,这个指针指向一个只读的对象,不能通过常量指针来改变这个对象的值。\r\n指针常量强调的是指针的不可改变性,而常量指针强调的是指针对其所指对象的不可改变性。\r\n  注意:无论是指针常量还是常量指针,其最大的用途就是作为函数的形式参数,保证实参在被调用\r\n函数中的不可改变特性。"
        },
        {
            "ID": "237",
            "typeID": "12",
            "question": "流操作符重载为什么返回引用",
            "answer": "在程序中,流操作符>>和<<经常连续使用。因此这两个操作符的返回值应该是一个仍旧支持这两个 操作符的流引用。其他的数据类型都无法做到这一点。\r\n注意:除了在赋值操作符和流操作符之外的其他的一些操作符中,如+、-、*、/等却千万不能返回 引用。因为这四个操作符的对象都是右值,因此,它们必须构造一个对象作为返回值。\r\n"
        },
        {
            "ID": "236",
            "typeID": "12",
            "question": "extern 有什么作用",
            "answer": "extern 标识的变量或者函数声明其定义在别的文件中,提示编译器遇到此变量和函数时在其它模块\r\n中寻找其定义。"
        },
        {
            "ID": "235",
            "typeID": "12",
            "question": "static 有什么作用",
            "answer": "static 在 C 中主要用于定义全局静态变量、定义局部静态变量、定义静态函数。在 C++中新增了两 种作用:定义静态数据成员、静态函数成员。\r\n注意:因为 static 定义的变量分配在静态区,所以其定义的变量的默认值为 0,普通变量的默认值 为随机数,在定义指针变量时要特别注意。\r\n"
        },
        {
            "ID": "234",
            "typeID": "12",
            "question": "关键字 const 是什么",
            "answer": "const 用来定义一个只读的变量或对象。主要优点:便于类型检查、同宏定义一样可以方便地进行 参数的修改和调整、节省空间,避免不必要的内存分配、可为函数重载提供参考。\r\n说明:const 修饰函数参数,是一种编程规范的要求,便于阅读,一看即知这个参数不能被改变, 实现时不易出错。"
        },
        {
            "ID": "233",
            "typeID": "12",
            "question": "typedef 和 define 有什么区别",
            "answer": "(1)用法不同:typedef 用来定义一种数据类型的别名,增强程序的可读性。define 主要用来定义 常量,以及书写复杂使用频繁的宏。\r\n(2)执行时间不同:typedef 是编译过程的一部分,有类型检查的功能。define 是宏定义,是预编 译的部分,其发生在编译之前,只是简单的进行字符串的替换,不进行类型的检查。\r\n(3)作用域不同:typedef 有作用域限定。define 不受作用域约束,只要是在 define 声明后的引用 都是正确的。\r\n(4)对指针的操作不同:typedef 和 define 定义的指针时有很大的区别。\r\n注意:typedef 定义是语句,因为句尾要加上分号。而 define 不是语句,千万不能在句尾加分号。"
        },
        {
            "ID": "232",
            "typeID": "12",
            "question": "写一个“标准”宏 MIN",
            "answer": "写一个“标准”宏 MIN,这个宏输入两个参数并且返回较小的一个。 【答案】\r\n#define min(a,b)((a)<=(b)?(a):(b)) 注意:在调用时一定要注意这个宏定义的副作用,如下调用: ((++*p)<=(x)?(++*p):(x)。\r\np 指针就自加了两次,违背了 MIN 的本意。"
        },
        {
            "ID": "231",
            "typeID": "12",
            "question": "C++的引用和 C 语言的指针有什么区别",
            "answer": "指针和引用主要有以下区别:\r\n(1)引用必须被初始化,但是不分配存储空间。指针不声明时初始化,在初始化的时候需要分配 存储空间。\r\n(2)引用初始化以后不能被改变,指针可以改变所指的对象。 (3)不存在指向空值的引用,但是存在指向空值的指针。 注意:引用作为函数参数时,会引发一定的问题,因为让引用作参数,目的就是想改变这个引用所\r\n指向地址的内容,而函数调用时传入的是实参,看不出函数的参数是正常变量,还是引用,因此可能会\r\n引发错误。所以使用时一定要小心谨慎。\r\n"
        },
        {
            "ID": "230",
            "typeID": "12",
            "question": "&&和&、||和|有什么区别",
            "answer": "(1)&和|对操作数进行求值运算,&&和||只是判断逻辑关系。 18\r\n(2)&&和||在在判断左侧操作数就能确定结果的情况下就不再对右侧操作数求值。\r\n注意:在编程的时候有些时候将&&或||替换成&或|没有出错,但是其逻辑是错误的,可能会导致不 可预想的后果(比如当两个操作数一个是 1 另一个是 2 时)。"
        },
        {
            "ID": "229",
            "typeID": "12",
            "question": "short i = 0; i = i + 1L;这两句有错吗",
            "answer": "代码一是错的,代码二是正确的。\r\n说明:在数据安全的情况下大类型的数据向小类型的数据转换一定要显示的强制类型转换。"
        },
        {
            "ID": "228",
            "typeID": "12",
            "question": "谈谈你对编程规范的理解或认识",
            "answer": "编程规范可总结为:程序的可行性,可读性、可移植性以及可测试性。\r\n说明:这是编程规范的总纲目,面试者不一定要去背诵上面给出的那几个例子,应该去理解这几个 例子说明的问题,想一想,自己如何解决可行性、可读性、可移植性以及可测试性这几个问题,结合以 上几个例子和自己平时的编程习惯来回答这个问题。"
        },
        {
            "ID": "227",
            "typeID": "12",
            "question": "编码实现冒泡排序",
            "answer": "冒泡排序编程实现如下:\r\n#include <stdio.h>\r\n#define LEN 10 //数组长度\r\nvoid main( void ) {\r\nintARRAY[10]={0,6,3,2,7,5,4,9,1,8}; //待排序数组 printf( \"\n\" );\r\nfor( int a = 0; a < LEN; a++ ) {\r\nprintf( \"%d \", ARRAY[a] ); }\r\nint i = 0;\r\nint j = 0;\r\nbool isChange;\r\n//打印数组内容\r\n//设定交换标志\r\nfor( i = 1; i < LEN; i++ ) {\r\nisChange = 0;\r\nfor( j = LEN-1; j >= i; j-- ) {\r\nif( ARRAY[j+1] < ARRAY[j] ) {\r\nARRAY[0] = ARRAY[j+1];\r\n//最多做 LEN-1 趟排序 //本趟排序开始前,交换标志应为假 //对当前无序区 ARRAY[i..LEN]自下向上扫描\r\n//交换记录 //ARRAY[0]不是哨兵,仅做暂存单元\r\n} }\r\nARRAY[j+1] = ARRAY[j]; ARRAY[j] = ARRAY[0]; isChange = 1;\r\n//发生了交换,故将交换标志置为真\r\n//打印本次排序后数组内容\r\n//本趟排序未发生交换,提前终止算法\r\nprintf( \"\n\" );\r\nfor( a = 0; a < LEN; a++)\r\n{\r\nprintf( \"%d \", ARRAY[a] );\r\n}\r\nif( !isChange )\r\n{\r\nbreak;\r\n} }\r\nprintf( \"\n\" );\r\nreturn; }"
        },
        {
            "ID": "226",
            "typeID": "12",
            "question": "编码实现直接插入排序",
            "answer": "直接插入排序编程实现如下:\r\n#include<iostream.h> void main( void )\r\n{\r\nint ARRAY[10] = { 0, 6, 3, 2, 7, 5, 4, 9, 1, 8 };\r\nint i,j;\r\nfor( i=0;i<10;i++) {\r\ncout<<ARRAY[i]<<\" \"; }\r\ncout<<endl;\r\nfor( i = 2; i <= 10; i++ ) {\r\nif(ARRAY[i] < ARRAY[i-1]) {\r\n//将 ARRAY[2],...,ARRAY[n]依次按序插入\r\n//如果 ARRAY[i]大于一切有序的数值, //ARRAY[i]将保持原位不动\r\nARRAY[0] = ARRAY[i]; j = i - 1;\r\ndo{\r\n//将 ARRAY[0]看做是哨兵,是 ARRAY[i]的副本\r\n//从右向左在有序区 ARRAY[1..i-1]中 //查找 ARRAY[i]的插入位置 //将数值大于 ARRAY[i]记录后移\r\nARRAY[j+1] = ARRAY[j];\r\nj-- ;\r\n}while( ARRAY[0] < ARRAY[j] );\r\nARRAY[j+1]=ARRAY[0]; //ARRAY[i]插入到正确的位置上\r\n} }\r\nfor( i=0;i<10;i++)\r\n{\r\ncout<<ARRAY[i]<<\" \";\r\n}\r\ncout<<endl; }\r\n注意:所有为简化边界条件而引入的附加结点(元素)均可称为哨兵。引入哨兵后使得查找循环条 件的时间大约减少了一半,对于记录数较大的文件节约的时间就相当可观。类似于排序这样使用频率非 常高的算法,要尽可能地减少其运行时间。所以不能把上述算法中的哨兵视为雕虫小技。\r\n"
        },
        {
            "ID": "225",
            "typeID": "12",
            "question": "计算一颗二叉树的深度",
            "answer": "深度的计算函数:\r\n\r\nint depth(BiTree T) {\r\nif(!T) return 0; //判断当前结点是否为叶子结点\r\n\r\nint d1= depth(T->lchild); //求当前结点的左孩子树的深度 int d2= depth(T->rchild); //求当前结点的右孩子树的深度 return (d1>d2?d1:d2)+1;\r\n}\r\n注意:根据二叉树的结构特点,很多算法都可以用递归算法来实现。\r\n"
        },
        {
            "ID": "224",
            "typeID": "12",
            "question": "简述队列和栈的异同",
            "answer": "队列和栈都是线性存储结构,但是两者的插入和删除数据的操作不同,队列是“先进先出”,栈是 “后进先出”。\r\n注意:区别栈区和堆区。堆区的存取是“顺序随意”,而栈区是“后进先出”。栈由编译器自动分 配释放 ,存放函数的参数值,局部变量的值等。其操作方式类似于数据结构中的栈。堆一般由程序员 分配释放, 若程序员不释放,程序结束时可能由 OS 回收。分配方式类似于链表。\r\n它与本题中的堆和栈是两回事。堆栈只是一种数据结构,而堆区和栈区是程序的不同内存存储区域。\r\n"
        },
        {
            "ID": "223",
            "typeID": "12",
            "question": "怎样把一个单链表反序",
            "answer": "(1)反转一个链表。循环算法。\r\nList reverse(List n) {\r\nif(!n) {\r\nreturn n; }\r\nlist cur = n.next; list pre = n;\r\nlist tmp;\r\n//判断链表是否为空,为空即退出。\r\n//保存头结点的下个结点 //保存头结点\r\n\r\npre.next = null;\r\nwhile ( NULL != cur.next ) {\r\ntmp = cur; tmp.next = pre pre = tmp;\r\ncur = cur.next;\r\n//头结点的指针指空,转换后变尾结点 //循环直到 cur.next 为空\r\n//实现如图 10.3—图 10.5 所示\r\n}\r\nreturn tmp; //f 返回头指针\r\n}\r\n(2)反转一个链表。递归算法。\r\nList *reverse( List *oldList, List *newHead = NULL ) {\r\nList *next = oldList-> next; oldList-> next = newHead; newHead = oldList;\r\n//记录上次翻转后的链表 //将当前结点插入到翻转后链表的开头 //递归处理剩余的链表\r\nreturn ( next==NULL )? newHead: reverse( t, newHead ); \r\n}\r\n说明:循环算法就是图 10.2—图 10.5 的移动过程,比较好理解和想到。递归算法的设计虽有一点难 度,但是理解了循环算法,再设计递归算法就简单多了。"
        },
        {
            "ID": "222",
            "typeID": "12",
            "question": "链表和数组有什么区别",
            "answer": "数组和链表有以下几点不同:\r\n(1)存储形式:数组是一块连续的空间,声明时就要确定长度。链表是一块可不连续的动态空间, 长度可变,每个结点要保存相邻结点指针。\r\n(2)数据查找:数组的线性查找速度快,查找操作直接使用偏移地址。链表需要按顺序检索结点, 效率低。\r\n(3)数据插入或删除:链表可以快速插入和删除结点,而数组则可能需要大量数据移动。 (4)越界问题:链表不存在越界问题,数组有越界问题。 说明:在选择数组或链表数据结构时,一定要根据实际需要进行选择。数组便于查询,链表便于插\r\n入删除。数组节省空间但是长度固定,链表虽然变长但是占了更多的存储空间。"
        },
        {
            "ID": "221",
            "typeID": "12",
            "question": "简述多态实现的原理",
            "answer": "编译器发现一个类中有虚函数,便会立即为此类生成虚函数表 vtable。虚函数表的各表项为指向对 应虚函数的指针。编译器还会在此类中隐含插入一个指针 vptr(对 vc 编译器来说,它插在类的第一个位 置上)指向虚函数表。调用此类的构造函数时,在类的构造函数中,编译器会隐含执行 vptr 与 vtable 的 关联代码,将 vptr 指向对应的 vtable,将类与此类的 vtable 联系了起来。另外在调用类的构造函数时, 指向基础类的指针此时已经变成指向具体的类的 this 指针,这样依靠此 this 指针即可得到正确的 vtable,。 如此才能真正与函数体进行连接,这就是动态联编,实现多态的基本原理。\r\n注意:一定要区分虚函数,纯虚函数、虚拟继承的关系和区别。牢记虚函数实现原理,因为多态 C++面试的重要考点之一,而虚函数是实现多态的基础。\r\n"
        },
        {
            "ID": "220",
            "typeID": "12",
            "question": "简述类成员函数的重写、重载和隐藏的区别",
            "answer": "(1)重写和重载主要有以下几点不同。\r\n 范围的区别:被重写的和重写的函数在两个类中,而重载和被重载的函数在同一个类中。\r\n 参数的区别:被重写函数和重写函数的参数列表一定相同,而被重载函数和重载函数的参数列表一\r\n定不同。\r\n virtual 的区别:重写的基类中被重写的函数必须要有 virtual 修饰,而重载函数和被重载函数可以被\r\n6\r\nB::g A::f B::h\r\nvirtual 修饰,也可以没有。\r\n(2)隐藏和重写、重载有以下几点不同。\r\n 与重载的范围不同:和重写一样,隐藏函数和被隐藏函数不在同一个类中。\r\n 参数的区别:隐藏函数和被隐藏的函数的参数列表可以相同,也可不同,但是函数名肯定要相同。\r\n当参数不相同时,无论基类中的参数是否被 virtual 修饰,基类的函数都是被隐藏,而不是被重写。\r\n说明:虽然重载和覆盖都是实现多态的基础,但是两者实现的技术完全不相同,达到的目的也是完 全不同的,覆盖是动态态绑定的多态,而重载是静态绑定的多态。\r\n"
        },
        {
            "ID": "219",
            "typeID": "12",
            "question": "访问基类的私有虚函数",
            "answer": "写出以下程序的输出结果:\r\n#include <iostream.h> class A\r\n5\r\n\r\n{\r\nvirtual void g()\r\n{\r\ncout << \"A::g\" << endl;\r\n} private:\r\nvirtual void f() {\r\ncout << \"A::f\" << endl; }\r\n};\r\nclass B : public A {\r\nvoid g() {\r\ncout << \"B::g\" << endl; }\r\nvirtual void h() {\r\ncout << \"B::h\" << endl; }\r\n};\r\ntypedef void( *Fun )( void ); void main()\r\n{\r\nB b;\r\nFun pFun;\r\nfor(int i = 0 ; i < 3; i++) {\r\npFun = ( Fun )*( ( int* ) * ( int* )( &b ) + i );\r\npFun(); }\r\n}\r\n输出结果:\r\n注意:本题主要考察了面试者对虚函数的理解程度。一个对虚函数不了解的人很难正确的做出本题。 在学习面向对象的多态性时一定要深刻理解虚函数表的工作原理。"
        },
        {
            "ID": "217",
            "typeID": "12",
            "question": "谈谈你对拷贝构造函数和赋值运算符的认识",
            "answer": "拷贝构造函数和赋值运算符重载有以下两个不同之处: (1)拷贝构造函数生成新的类对象,而赋值运算符不能。 (2)由于拷贝构造函数是直接构造一个新的类对象,所以在初始化这个对象之前不用检验源对象\r\n是否和新建对象相同。而赋值运算符则需要这个操作,另外赋值运算中如果原来的对象中有内存分配要 先把内存释放掉\r\n  注意:当有类中有指针类型的成员变量时,一定要重写拷贝构造函数和赋值运算符,不要使用默认\r\n的。"
        },
        {
            "ID": "216",
            "typeID": "12",
            "question": "C++的空类有哪些成员函数",
            "answer": "缺省构造函数。\r\n 缺省拷贝构造函数。\r\n 缺省析构函数。\r\n 缺省赋值运算符。\r\n 缺省取址运算符。\r\n 缺省取址运算符 const。\r\n注意:有些书上只是简单的介绍了前四个函数。没有提及后面这两个函数。但后面这两个函数也是 空类的默认函数。另外需要注意的是,只有当实际使用这些函数的时候,编译器才会去定义它们。\r\n"
        },
        {
            "ID": "215",
            "typeID": "12",
            "question": "面向对象的三大特征",
            "answer": "面向对象的三大特征是封装性、继承性和多态性:\r\n 封装性:将客观事物抽象成类,每个类对自身的数据和方法实行 protection(private, protected,\r\npublic)。\r\n 继承性:广义的继承有三种实现形式:实现继承(使用基类的属性和方法而无需额外编码的能力)、可\r\n视继承(子窗体使用父窗体的外观和实现代码)、接口继承(仅使用属性和方法,实现滞后到子类实现)。\r\n 多态性:是将父类对象设置成为和一个或更多它的子对象相等的技术。用子类对象给父类对象赋值\r\n之后,父类对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。\r\n说明:面向对象的三个特征是实现面向对象技术的关键,每一个特征的相关技术都非常的复杂,程 序员应该多看、多练。"
        },
        {
            "ID": "214",
            "typeID": "12",
            "question": "设置地址为 0x67a9 的整型变量的值为 0xaa66",
            "answer": "\r\n说明:这道题就是强制类型转换的典型例子,无论在什么平台地址长度和整型数据的长度是一样的, 即一个整型数据可以强制转换成地址指针类型,只要有意义即可。"
        },
        {
            "ID": "213",
            "typeID": "12",
            "question": "简述 strcpy、sprintf 与 memcpy 的区别",
            "answer": "三者主要有以下不同之处:\r\n(1)操作对象不同,strcpy的两个操作对象均为字符串,sprintf的操作源对象可以是多种数据类型, 目的操作对象是字符串,memcpy 的两个对象就是两个任意可操作的内存地址,并不限于何种数据类型。\r\n(2)执行效率不同,memcpy 最高,strcpy 次之,sprintf 的效率最低。\r\n(3)实现功能不同,strcpy 主要实现字符串变量间的拷贝,sprintf 主要实现其他数据类型格式到字 符串的转化,memcpy 主要是内存块间的拷贝。\r\n说明:strcpy、sprintf 与 memcpy 都可以实现拷贝的功能,但是针对的对象不同,根据实际需求,来 选择合适的函数实现拷贝功能。"
        },
        {
            "ID": "212",
            "typeID": "12",
            "question": "简述 C、C++程序编译的内存分配情况",
            "answer": "C、C++中内存分配方式可以分为三种:\r\n(1)从静态存储区域分配: 内存在程序编译时就已经分配好,这块内存在程序的整个运行期间都存在。速度快、不容易出错,\r\n因为有系统会善后。例如全局变量,static 变量等。\r\n(2)在栈上分配: 在执行函数时,函数内局部变量的存储单元都在栈上创建,函数执行结束时这些存储单元自动被释\r\n放。栈内存分配运算内置于处理器的指令集中,效率很高,但是分配的内存容量有限。 (3)从堆上分配:\r\n即动态内存分配。程序在运行的时候用 malloc 或 new 申请任意大小的内存,程序员自己负责在何\r\n时用 free 或 delete 释放内存。动态内存的生存期由程序员决定,使用非常灵活。如果在堆上分配了空间, 就有责任回收它,否则运行的程序会出现内存泄漏,另外频繁地分配和释放不同大小的堆空间将会产生 堆内碎块。\r\n一个 C、C++程序编译时内存分为 5 大存储区:堆区、栈区、全局区、文字常量区、程序代码区。\r\n"
        },
        {
            "ID": "211",
            "typeID": "12",
            "question": "a 和&a 有什么区别",
            "answer": "请写出以下代码的打印结果,主要目的是考察 a 和&a 的区别。\r\n#include<stdio.h> void main( void ) {\r\nint a[5]={1,2,3,4,5}; int *ptr=(int *)(&a+1);\r\nprintf(\"%d,%d\",*(a+1),*(ptr-1));\r\nreturn; }\r\n输出结果:2,5。\r\n注意:数组名 a 可以作数组的首地址,而&a 是数组的指针。思考,将原式的 int *ptr=(int *)(&a+1); 改为 int *ptr=(int *)(a+1);时输出结果将是什么呢?"
        },
        {
            "ID": "210",
            "typeID": "12",
            "question": "一个指针可以是 volatile 吗",
            "answer": "可以,因为指针和普通变量一样,有时也有变化程序的不可控性。常见例:子中断服务子程序修改 一个指向一个 buffer 的指针时,必须用 volatile 来修饰这个指针。\r\n说明:指针是一种普通的变量,从访问上没有什么不同于其他变量的特性。其保存的数值是个整型 数据,和整型变量不同的是,这个整型数据指向的是一段内存地址。\r\n"
        },
        {
            "ID": "209",
            "typeID": "12",
            "question": "写一个“标准”宏 MIN",
            "answer": "#define min(a,b)((a)<=(b)?(a):(b))\r\n注意:在调用时一定要注意这个宏定义的副作用,如下调用:\r\n((++*p)<=(x)?(++*p):(x)。\r\np 指针就自加了两次,违背了 MIN 的本意。"
        },
        {
            "ID": "208",
            "typeID": "12",
            "question": "C中的 malloc 和C++中的 new 有什么区别",
            "answer": "malloc 和 new 有以下不同:\r\n(1)new、delete 是操作符,可以重载,只能在 C++中使用。\r\n(2)malloc、free 是函数,可以覆盖,C、C++中都可以使用。\r\n(3)new 可以调用对象的构造函数,对应的 delete 调用相应的析构函数。\r\n(4)malloc 仅仅分配内存,free 仅仅回收内存,并不执行构造和析构函数\r\n(5)new、delete 返回的是某种数据类型指针,malloc、free 返回的是 void 指针。\r\n注意:malloc 申请的内存空间要用 free 释放,而 new 申请的内存空间要用 delete 释放,不要混用。\r\n因为两者实现的机理不同。"
        },
        {
            "ID": "207",
            "typeID": "12",
            "question": "C 语言的关键字 static 和 C++ 的关键字 static 有什么区别",
            "answer": "在 C 中 static 用来修饰局部静态变量和外部静态变量、函数。而 C++中除了上述功能外,还用来定 义类的成员变量和函数。即静态成员和静态成员函数。\r\n注意:编程时 static 的记忆性,和全局性的特点可以让在不同时期调用的函数进行通信,传递信息, 而 C++的静态成员则可以在多个对象实例间进行通信,传递信息。"
        },
        {
            "ID": "206",
            "typeID": "12",
            "question": "sizeof 和 strlen 的区别",
            "answer": "sizeof 和 strlen 有以下区别:\r\n sizeof 是一个操作符,strlen 是库函数。\r\n sizeof 的参数可以是数据的类型,也可以是变量,而 strlen 只能以结尾为‘\u0000‘的字符串作参数。\r\n 编译器在编译时就计算出了 sizeof 的结果。而 strlen 函数必须在运行时才能计算出来。并且 sizeof\r\n计算的是数据类型占内存的大小,而 strlen 计算的是字符串实际的长度。\r\n 数组做 sizeof 的参数不退化,传递给 strlen 就退化为指针了。\r\n注意:有些是操作符看起来像是函数,而有些函数名看起来又像操作符,这类容易混淆的名称一定 要加以区分,否则遇到数组名这类特殊数据类型作参数时就很容易出错。最容易混淆为函数的操作符就 是 sizeof。"
        },
        {
            "ID": "205",
            "typeID": "12",
            "question": "写出 bool 、int、 float、指针变量与“零值”比较的 if 语句",
            "answer": "bool 型数据:\r\nint 型数据:\r\n指针型数:\r\nfloat 型数据:\r\nif( flag )\r\n{\r\nA;\r\n} else {\r\nB; }\r\nif( 0 != flag )\r\n{\r\nA;\r\n} else {\r\nB; }\r\nif( NULL == flag ) {\r\nA; }\r\nelse\r\n{\r\nB;\r\n}\r\nif ( ( flag >= NORM ) && ( flag <= NORM ) ) {\r\nA;\r\n\r\n}\r\n注意:应特别注意在 int、指针型变量和“零值”比较的时候,把“零值”放在左边,这样当把“==” 误写成“=”时,编译器可以报错,否则这种逻辑错误不容易发现,并且可能导致很严重的后果。"
        },
        {
            "ID": "204",
            "typeID": "12",
            "question": "变量的声明和定义有什么区别？",
            "answer": "为变量分配地址和存储空间的称为定义,不分配地址的称为声明。一个变量可以在多个地方声明, 但是只在一个地方定义。加入 extern 修饰的是变量的声明,说明此变量将在文件以外或在文件后面部分 定义。\r\n说明:很多时候一个变量,只是声明不分配内存空间,直到具体使用时才初始化,分配内存空间, 如外部变量。"
        },
        {
            "ID": "24",
            "typeID": "12",
            "question": "如何打印出当前源文件的文件名以及源文件的当前行号？",
            "answer": "cout << __FILE__ ;\r\ncout<<__LINE__ ;\r\n__FILE__和__LINE__是系统预定义宏，这种宏并不是在某个文件中定义的，而是由编译器定义的。"
        },
        {
            "ID": "23",
            "typeID": "12",
            "question": "类成员函数的重载、覆盖和隐藏区别？",
            "answer": "a.成员函数被重载的特征：\r\n（1）相同的范围（在同一个类中）；\r\n（2）函数名字相同；\r\n（3）参数不同；\r\n（4）virtual 关键字可有可无。\r\nb.覆盖是指派生类函数覆盖基类函数，特征是：\r\n（1）不同的范围（分别位于派生类与基类）；\r\n（2）函数名字相同；\r\n（3）参数相同；\r\n（4）基类函数必须有virtual 关键字。\r\nc.“隐藏”是指派生类的函数屏蔽了与其同名的基类函数，规则如下：\r\n（1）如果派生类的函数与基类的函数同名，但是参数不同。此时，不论有无virtual关键字，基类的函数将被隐藏（注意别与重载混淆）。\r\n（2）如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有virtual 关键字。此时，基类的函数被隐藏（注意别与覆盖混淆）"
        },
        {
            "ID": "22",
            "typeID": "12",
            "question": "请说出const与#define 相比，有何优点？",
            "answer": "1） const 常量有数据类型，而宏常量没有数据类型。编译器可以对前者进行类型安全检查。而对后者只进行字符替换，没有类型安全检查，并且在字符替换可能会产生意料不到的错误。\r\n      2） 有些集成化的调试工具可以对const 常量进行调试，但是不能对宏常量进行调试。"
        },
        {
            "ID": "21",
            "typeID": "12",
            "question": "分别写出BOOL,int,float,指针类型的变量a 与“零”的比较语句？",
            "answer": "BOOL :    if ( !a ) or if(a)\r\nint :     if ( a == 0)\r\nfloat :   const EXPRESSION EXP = 0.000001\r\n          if ( a < EXP && a >-EXP)\r\npointer : if ( a != NULL) or if(a == NULL)"
        },
        {
            "ID": "20",
            "typeID": "12",
            "question": "C++是不是类型安全的？",
            "answer": "不是。两个不同类型的指针之间可以强制转换（用reinterpret cast)。C#是类型安全的。"
        },
        {
            "ID": "19",
            "typeID": "12",
            "question": "New delete 与malloc free 的联系与区别?",
            "answer": "都是在堆(heap)上进行动态的内存操作。用malloc函数需要指定内存分配的字节数并且不能初始化对象，new 会自动调用对象的构造函数。delete 会调用对象的destructor，而free 不会调用对象的destructor."
        },
        {
            "ID": "18",
            "typeID": "12",
            "question": " Ado与Ado.net的相同与不同？",
            "answer": "除了“能够让应用程序处理存储于DBMS 中的数据“这一基本相似点外，两者没有太多共同之处。但是Ado使用OLE DB 接口并基于微软的COM 技术，而ADO.NET 拥有自己的ADO.NET 接口并且基于微软的.NET 体系架构。众所周知.NET 体系不同于COM 体系，ADO.NET 接口也就完全不同于ADO和OLE DB 接口，这也就是说ADO.NET 和ADO是两种数据访问方式。ADO.net 提供对XML 的支持。"
        },
        {
            "ID": "17",
            "typeID": "12",
            "question": "多态的作用？",
            "answer": "主要是两个：1. 隐藏实现细节，使得代码能够模块化；扩展代码模块，实现代码重用；2. 接口重用：为了类在继承和派生的时候，保证使用家族中任一类的实例的某一属性时的正确调用。"
        },
        {
            "ID": "16",
            "typeID": "12",
            "question": "已知strcpy的函数原型：char *strcpy(char *strDest, const char *strSrc)其中strDest 是目的字符串，strSrc 是源字符串。不调用C++/C 的字符串库函数，请编写函数 strcpy。",
            "answer": "char *strcpy(char *strDest, const char *strSrc)\r\n{\r\nif ( strDest == NULL || strSrc == NULL)\r\nreturn NULL ;\r\nif ( strDest == strSrc)\r\nreturn strDest ;\r\nchar *tempptr = strDest ;\r\nwhile( (*strDest++ = *strSrc++) != ‘/0’)\r\n;\r\nreturn tempptr ;\r\n}"
        },
        {
            "ID": "15",
            "typeID": "12",
            "question": "结构与联合有和区别？",
            "answer": "1. 结构和联合都是由多个不同的数据类型成员组成, 但在任何同一时刻, 联合中只存放了一个被选中的成员（所有成员共用一块地址空间）, 而结构的所有成员都存在（不同成员的存放地址不同）。 \r\n 2. 对于联合的不同成员赋值, 将会对其它成员重写,  原来成员的值就不存在了, 而对于结构的不同成员赋值是互不影响的。"
        },
        {
            "ID": "14",
            "typeID": "12",
            "question": " “引用”与指针的区别是什么？",
            "answer": "指针通过某个指针变量指向一个对象后，对它所指向的变量间接操作。程序中使用指针，程序的可读性差；而引用本身就是目标变量的别名，对引用的操作就是对目标变量的操作。此外，就是上面提到的对函数传ref和pointer的区别。"
        }
    ]


