[
        {
            "ID": "1250",
            "typeID": "11",
            "question": "Java中你怎样唤醒一个阻塞的线程？",
            "answer": "如果线程因为调用wait()、sleep()、或者join()方法而导致的阻塞，可以中断线程，并且通过抛出InterruptedException来唤醒它。"
        },
        {
            "ID": "1249",
            "typeID": "11",
            "question": "为什么我们调用start()方法时会执行run()方法，为什么我们不能直接调用run()方法？",
            "answer": "当调用start()方法时你将创建新的线程，并且执行在run()方法里的代码。但是如果直接调用run()方法，它不会创建新的线程也不会执行调用线程的代码。"
        },
        {
            "ID": "1248",
            "typeID": "11",
            "question": "你将如何使用thread dump？你将如何分析Thread dump？",
            "answer": "在UNIX中你可以使用kill -3，然后thread dump将会打印日志，在windows中你可以使用”CTRL+Break”。非常简单和专业的线程面试问题，但是如果他问你怎样分析它，就会很棘手。"
        },
        {
            "ID": "1247",
            "typeID": "11",
            "question": "用Java编程一个会导致死锁的程序，你将怎么解决？",
            "answer": "因为即使死锁问题在写多线程并发程序时非常普遍，但是很多侯选者并不能写deadlock free code（无死锁代码？），他们很挣扎。只要告诉他们，你有N个资源和N个线程，并且你需要所有的资源来完成一个操作。为了简单这里的n可以替换为2，越大的数据会使问题看起来更复杂。通过避免Java中的死锁来得到关于死锁的更多信息。"
        },
        {
            "ID": "1246",
            "typeID": "11",
            "question": "用Java写代码来解决生产者——消费者问题？",
            "answer": "这个问题更经典，有些时候面试都会问下面的问题。在Java中怎么解决生产者——消费者问题，当然有很多解决方法，一种用阻塞队列实现的方法。有些时候他们甚至会问怎么实现哲学家进餐问题。"
        },
        {
            "ID": "1245",
            "typeID": "11",
            "question": "如何用Java实现阻塞队列？",
            "answer": "这是一个相对艰难的多线程面试问题，它能达到很多的目的。第一，它可以检测侯选者是否能实际的用Java线程写程序；第二，可以检测侯选者对并发场景的理解，并且你可以根据这个问很多问题。如果他用wait()和notify()方法来实现阻塞队列，你可以要求他用最新的Java 5中的并发类来再写一次。"
        },
        {
            "ID": "1244",
            "typeID": "11",
            "question": "在java中wait和sleep方法的不同？",
            "answer": "通常会在电话面试中经常被问到的Java线程面试问题。最大的不同是在等待时wait会释放锁，而sleep一直持有锁。Wait通常被用于线程间交互，sleep通常被用于暂停执行。"
        },
        {
            "ID": "1243",
            "typeID": "11",
            "question": "在Java中Lock接口比synchronized块的优势是什么？你需要实现一个高效的缓存，它允许多个用户读，但只允许一个用户写，以此来保持它的完整性，你会怎样去实现它？",
            "answer": "lock接口在多线程和并发编程中最大的优势是它们为读和写分别提供了锁，它能满足你写像ConcurrentHashMap这样的高性能数据结构和有条件的阻塞。Java线程面试的问题越来越会根据面试者的回答来提问。我强烈建议在你去参加多线程的面试之前认真读一下Locks，因为当前其大量用于构建电子交易终统的客户端缓存和交易连接空间。"
        },
        {
            "ID": "1242",
            "typeID": "11",
            "question": "现在有T1、T2、T3三个线程，你怎样保证T2在T1执行完后执行，T3在T2执行完后执行？",
            "answer": "这个线程问题通常会在第一轮或电话面试阶段被问到，目的是检测你对”join”方法是否熟悉。这个多线程问题比较简单，可以用join方法实现。"
        },
        {
            "ID": "1241",
            "typeID": "11",
            "question": "Iterator是什么？",
            "answer": "Iterator接口提供遍历任何Collection的接口。我们可以从一个Collection中使用迭代器方法来获取迭代器实例。迭代器取代了Java集合框架中的Enumeration。迭代器允许调用者在迭代过程中移除元素。"
        },
        {
            "ID": "1240",
            "typeID": "11",
            "question": "为何Map接口不继承Collection接口？",
            "answer": "尽管Map接口和它的实现也是集合框架的一部分，但Map不是集合，集合也不是Map。因此，Map继承Collection毫无意义，反之亦然。\r\n如果Map继承Collection接口，那么元素去哪儿？Map包含key-value对，它提供抽取key或value列表集合的方法，但是它不适合“一组对象”规范。"
        },
        {
            "ID": "1239",
            "typeID": "11",
            "question": "为何Collection不从Cloneable和Serializable接口继承？",
            "answer": "Collection接口指定一组对象，对象即为它的元素。如何维护这些元素由Collection的具体实现决定。例如，一些如List的Collection实现允许重复的元素，而其它的如Set就不允许。很多Collection实现有一个公有的clone方法。然而，把它放到集合的所有实现中也是没有意义的。这是因为Collection是一个抽象表现。重要的是实现。\r\n当与具体实现打交道的时候，克隆或序列化的语义和含义才发挥作用。所以，具体实现应该决定如何对它进行克隆或序列化，或它是否可以被克隆或序列化。\r\n在所有的实现中授权克隆和序列化，最终导致更少的灵活性和更多的限制。特定的实现应该决定它是否可以被克隆和序列化。"
        },
        {
            "ID": "1238",
            "typeID": "11",
            "question": "Java集合框架的基础接口有哪些？",
            "answer": "Collection为集合层级的根接口。一个集合代表一组对象，这些对象即为它的元素。Java平台不提供这个接口任何直接的实现。\r\nSet是一个不能包含重复元素的集合。这个接口对数学集合抽象进行建模，被用来代表集合，就如一副牌。\r\nList是一个有序集合，可以包含重复元素。你可以通过它的索引来访问任何元素。List更像长度动态变换的数组。\r\nMap是一个将key映射到value的对象。一个Map不能包含重复的key：每个key最多只能映射一个value。\r\n一些其它的接口有Queue、Dequeue、SortedSet、SortedMap和ListIterator。"
        },
        {
            "ID": "1237",
            "typeID": "11",
            "question": "集合框架中的泛型有什么优点？",
            "answer": "Java1.5引入了泛型，所有的集合接口和实现都大量地使用它。泛型允许我们为集合提供一个可以容纳的对象类型，因此，如果你添加其它类型的任何元素，它会在编译时报错。这避免了在运行时出现ClassCastException，因为你将会在编译时得到报错信息。泛型也使得代码整洁，我们不需要使用显式转换和instanceOf操作符。它也给运行时带来好处，因为不会产生类型检查的字节码指令。"
        },
        {
            "ID": "1236",
            "typeID": "11",
            "question": "Java集合框架是什么？说出一些集合框架的优点？",
            "answer": "每种编程语言中都有集合，最初的Java版本包含几种集合类：Vector、Stack、HashTable和Array。随着集合的广泛使用，Java1.2提出了囊括所有集合接口、实现和算法的集合框架。在保证线程安全的情况下使用泛型和并发集合类，Java已经经历了很久。它还包括在Java并发包中，阻塞接口以及它们的实现。集合框架的部分优点如下：\r\n（1）使用核心集合类降低开发成本，而非实现我们自己的集合类。\r\n\r\n（2）随着使用经过严格测试的集合框架类，代码质量会得到提高。\r\n\r\n（3）通过使用JDK附带的集合类，可以降低代码维护成本。\r\n\r\n（4）复用性和可操作性。"
        },
        {
            "ID": "1175",
            "typeID": "11",
            "question": "Java 中能创建 volatile 数组吗？ ",
            "answer": "能，Java 中可以创建 volatile 类型数组，不过只是一个指向数组的引用，而不是整个数组。我的意思是，如果改变引用指向的数组，将会受到 volatile 的保护，但是如果多个线程同时改变数组的元素，volatile 标示符就不能起到之前的保护作用了。 "
        },
        {
            "ID": "1174",
            "typeID": "11",
            "question": "volatile 能使得一个非原子操作变成原子操作吗？ ",
            "answer": "一个典型的例子是在类中有一个 long 类型的成员变量。如果你知道该成员变量会被多个线程访问，如计数器、价格等，你最好是将其设置为 volatile。为什么？因为 Java 中读取 long 类型变量不是原子的，需要分成两步，如果一个线程正在修改该 long 变量的值，另一个线程可能只能看到该值的一半（前 32 位）。但是对一个 volatile 型的 long 或 double 变量的读写是原子。 "
        },
        {
            "ID": "1173",
            "typeID": "11",
            "question": "volatile 修饰符的有过什么实践？ ",
            "answer": "一种实践是用 volatile 修饰 long 和 double 变量，使其能按原子类型来读写。double 和 long 都是64位宽，因此对这两种类型的读是分为两部分的，第一次读取第一个 32 位，然后再读剩下的 32 位，这个过程不是原子的，但 Java 中 volatile 型的 long 或 double 变量的读写是原子的。volatile 修复符的另一个作用是提供内存屏障（memory barrier），例如在分布式框架中的应用。简单的说，就是当你写一个 volatile 变量之前，Java 内存模型会插入一个写屏障（write barrier），读一个 volatile 变量之前，会插入一个读屏障（read barrier）。意思就是说，在你写一个 volatile 域时，能保证任何线程都能看到你写的值，同时，在写之前，也能保证任何数值的更新对所有线程是可见的，因为内存屏障会将其他所有写的值更新到缓存。 \r\n"
        },
        {
            "ID": "1172",
            "typeID": "11",
            "question": "volatile 类型变量提供什么保证？ ",
            "answer": "volatile 变量提供顺序和可见性保证，例如，JVM 或者 JIT为了获得更好的性能会对语句重排序，但是 volatile 类型变量即使在没有同步块的情况下赋值也不会与其他语句重排序。 volatile 提供 happens-before 的保证，确保一个线程的修改能对其他线程是可见的。某些情况下，volatile 还能提供原子性，如读 64 位数据类型，像 long 和 double 都不是原子的，但 volatile 类型的 double 和 long 就是原子的。"
        },
        {
            "ID": "1171",
            "typeID": "11",
            "question": "你是如何调用 wait（）方法的？使用 if 块还是循环？为什么？ ",
            "answer": "wait() 方法应该在循环调用，因为当线程获取到 CPU 开始执行的时候，其他条件可能还没有满足，所以在处理前，循环检测条件是否满足会更好。下面是一段标准的使用 wait 和 notify 方法的代码： \r\n\r\n// The standard idiom for using the wait method \r\nsynchronized (obj) { \r\nwhile (condition does not hold) \r\nobj.wait(); // (Releases lock, and reacquires on wakeup) \r\n... // Perform action appropriate to condition \r\n} "
        },
        {
            "ID": "1170",
            "typeID": "11",
            "question": "什么是多线程环境下的伪共享（false sharing）？ ",
            "answer": "伪共享是多线程系统（每个处理器有自己的局部缓存）中一个众所周知的性能问题。伪共享发生在不同处理器的上的线程对变量的修改依赖于相同的缓存行"
        },
        {
            "ID": "1169",
            "typeID": "11",
            "question": "什么是 Busy spin？我们为什么要使用它？ ",
            "answer": "Busy spin 是一种在不释放 CPU 的基础上等待事件的技术。它经常用于避免丢失 CPU 缓存中的数据（如果线程先暂停，之后在其他CPU上运行就会丢失）。所以，如果你的工作要求低延迟，并且你的线程目前没有任何顺序，这样你就可以通过循环检测队列中的新消息来代替调用 sleep() 或 wait() 方法。它唯一的好处就是你只需等待很短的时间，如几微秒或几纳秒。LMAX 分布式框架是一个高性能线程间通信的库，该库有一个 BusySpinWaitStrategy 类就是基于这个概念实现的，使用 busy spin 循环 EventProcessors 等待屏障。"
        },
        {
            "ID": "1168",
            "typeID": "11",
            "question": "什么是线程局部变量？ ",
            "answer": "线程局部变量是局限于线程内部的变量，属于线程自身所有，不在多个线程间共享。Java 提供 ThreadLocal 类来支持线程局部变量，是一种实现线程安全的方式。但是在管理环境下（如 web 服务器）使用线程局部变量的时候要特别小心，在这种情况下，工作线程的生命周期比任何应用变量的生命周期都要长。任何线程局部变量一旦在工作完成后没有释放，Java 应用就存在内存泄露的风险。 "
        },
        {
            "ID": "1167",
            "typeID": "11",
            "question": "Java 中 sleep 方法和 wait 方法的区别？",
            "answer": "虽然两者都是用来暂停当前运行的线程，但是 sleep() 实际上只是短暂停顿，因为它不会释放锁，而 wait() 意味着条件等待，这就是为什么该方法要释放锁，因为只有这样，其他等待的线程才能在满足条件时获取到该锁。 "
        },
        {
            "ID": "1166",
            "typeID": "11",
            "question": "什么是不可变对象（immutable object）？Java 中怎么创建一个不可变对象？ ",
            "answer": "不可变对象指对象一旦被创建，状态就不能再改变。任何修改都会创建一个新的对象，如 String、Integer及其它包装类。 \r\n"
        },
        {
            "ID": "1165",
            "typeID": "11",
            "question": "我们能创建一个包含可变对象的不可变对象吗？ ",
            "answer": "是的，我们是可以创建一个包含可变对象的不可变对象的，你只需要谨慎一点，不要共享可变对象的引用就可以了，如果需要变化时，就返回原对象的一个拷贝。最常见的例子就是对象中包含一个日期对象的引用。 \r\n"
        },
        {
            "ID": "1164",
            "typeID": "11",
            "question": "Java 中应该使用什么数据类型来代表价格？ ",
            "answer": "如果不是特别关心内存和性能的话，使用BigDecimal，否则使用预定义精度的 double 类型。 \r\n"
        },
        {
            "ID": "1163",
            "typeID": "11",
            "question": "怎么将 byte 转换为 String？ ",
            "answer": "可以使用 String 接收 byte[] 参数的构造器来进行转换，需要注意的点是要使用的正确的编码，否则会使用平台默认编码，这个编码可能跟原来的编码相同，也可能不同。 "
        },
        {
            "ID": "1162",
            "typeID": "11",
            "question": "我们能将 int 强制转换为 byte 类型的变量吗？如果该值大于 byte 类型的范围，将会出现什么现象？ ",
            "answer": "是的，我们可以做强制转换，但是 Java 中 int 是 32 位的，而 byte 是 8 位的，所以，如果强制转化是，int 类型的高 24 位将会被丢弃，byte 类型的范围是从 -128 到 128。 "
        },
        {
            "ID": "1161",
            "typeID": "11",
            "question": "Java 中 ++ 操作符是线程安全的吗？ ",
            "answer": "不是线程安全的操作。它涉及到多个指令，如读取变量值，增加，然后存储回内存，这个过程可能会出现多个线程交差。 "
        },
        {
            "ID": "1160",
            "typeID": "11",
            "question": "a = a + b 与 a += b 的区别？ ",
            "answer": "+= 隐式的将加操作的结果类型强制转换为持有结果的类型。如果两这个整型相加，如 byte、short 或者 int，首先会将它们提升到 int 类型，然后在执行加法操作。如果加法操作的结果比 a 的最大值要大，则 a+b 会出现编译错误，但是 a += b 没问题，如下： \r\nbyte a = 127; \r\nbyte b = 127; \r\nb = a + b; // error : cannot convert from int to byte \r\nb += a; // ok \r\n\r\n注：其实无论 a+b 的值为多少，编译器都会报错，因为 a+b 操作会将 a、b 提升为 int 类型，所以将 int 类型赋值给 byte 就会编译出错 \r\n"
        },
        {
            "ID": "1159",
            "typeID": "11",
            "question": "我能在不进行强制转换的情况下将一个 double 值赋值给 long 类型的变量吗？ ",
            "answer": "不行，你不能在没有强制类型转换的前提下将一个 double 值赋值给 long 类型的变量，因为 double 类型的范围比 long 类型更广，所以必须要进行强制转换。 \r\n"
        },
        {
            "ID": "1158",
            "typeID": "11",
            "question": "3*0.1 == 0.3 将会返回什么？true 还是 false？ ",
            "answer": "false，因为有些浮点数不能完全精确的表示出来。 "
        },
        {
            "ID": "1157",
            "typeID": "11",
            "question": "int 和 Integer 哪个会占用更多的内存？ ",
            "answer": "Integer 对象会占用更多的内存。Integer 是一个对象，需要存储对象的元数据。但是 int 是一个原始类型的数据，所以占用的空间更少。 "
        },
        {
            "ID": "1156",
            "typeID": "11",
            "question": "为什么 Java 中的 String 是不可变的（Immutable）？ ",
            "answer": "Java 中的 String 不可变是因为 Java 的设计者认为字符串使用非常频繁，将字符串设置为不可变可以允许多个客户端之间共享相同的字符串。 "
        },
        {
            "ID": "1155",
            "typeID": "11",
            "question": "Java 中的构造器链是什么？ ",
            "answer": "当你从一个构造器中调用另一个构造器，就是Java 中的构造器链。这种情况只在重载了类的构造器的时候才会出现。"
        },
        {
            "ID": "1154",
            "typeID": "11",
            "question": "64 位 JVM 中，int 的长度是多数？ ",
            "answer": "Java 中，int 类型变量的长度是一个固定值，与平台无关，都是 32 位。意思就是说，在 32 位 和 64 位 的Java 虚拟机中，int 类型的长度是相同的。 "
        },
        {
            "ID": "1153",
            "typeID": "11",
            "question": "Serial 与 Parallel GC之间的不同之处？ ",
            "answer": "Serial 与 Parallel 在GC执行的时候都会引起 stop-the-world。它们之间主要不同 serial 收集器是默认的复制收集器，执行 GC 的时候只有一个线程，而 parallel 收集器使用多个 GC 线程来执行。"
        },
        {
            "ID": "1152",
            "typeID": "11",
            "question": "32 位和 64 位的 JVM，int 类型变量的长度是多数？ ",
            "answer": "32 位和 64 位的 JVM 中，int 类型变量的长度是相同的，都是 32 位或者 4 个字节。 \r\n"
        },
        {
            "ID": "1151",
            "typeID": "11",
            "question": "Java 中 WeakReference 与 SoftReference的区别？ ",
            "answer": "虽然 WeakReference 与 SoftReference 都有利于提高 GC 和 内存的效率，但是 WeakReference ，一旦失去最后一个强引用，就会被 GC 回收，而软引用虽然不能阻止被回收，但是可以延迟到 JVM 内存不足的时候。 "
        },
        {
            "ID": "1150",
            "typeID": "11",
            "question": "WeakHashMap 是怎么工作的？ ",
            "answer": "WeakHashMap 的工作与正常的 HashMap 类似，但是使用弱引用作为 key，意思就是当 key 对象没有任何引用时，key/value 将会被回收。 "
        },
        {
            "ID": "1149",
            "typeID": "11",
            "question": "JVM 选项 -XX:+UseCompressedOops 有什么作用？为什么要使用？ ",
            "answer": "当你将你的应用从 32 位的 JVM 迁移到 64 位的 JVM 时，由于对象的指针从 32 位增加到了 64 位，因此堆内存会突然增加，差不多要翻倍。这也会对 CPU 缓存（容量比内存小很多）的数据产生不利的影响。因为，迁移到 64 位的 JVM 主要动机在于可以指定最大堆大小，通过压缩 OOP 可以节省一定的内存。通过 -XX:+UseCompressedOops 选项，JVM 会使用 32 位的 OOP，而不是 64 位的 OOP。 \r\n"
        },
        {
            "ID": "1148",
            "typeID": "11",
            "question": "怎样通过 Java 程序来判断 JVM 是 32 位 还是 64 位？ ",
            "answer": "你可以检查某些系统属性如 sun.arch.data.model 或 os.arch 来获取该信息。 \r\n"
        },
        {
            "ID": "1147",
            "typeID": "11",
            "question": "32 位 JVM 和 64 位 JVM 的最大堆内存分别是多数？ ",
            "answer": "理论上说上 32 位的 JVM 堆内存可以到达 2^32，即 4GB，但实际上会比这个小很多。不同操作系统之间不同，如 Windows 系统大约 1.5 GB，Solaris 大约 3GB。64 位 JVM允许指定最大的堆内存，理论上可以达到 2^64，这是一个非常大的数字，实际上你可以指定堆内存大小到 100GB。甚至有的 JVM，如 Azul，堆内存到 1000G 都是可能的。 "
        },
        {
            "ID": "1146",
            "typeID": "11",
            "question": "JRE、JDK、JVM 及 JIT 之间有什么不同？ ",
            "answer": "JRE 代表 Java 运行时（Java run-time），是运行 Java 引用所必须的。JDK 代表 Java 开发工具（Java development kit），是 Java 程序的开发工具，如 Java 编译器，它也包含 JRE。JVM 代表 Java 虚拟机（Java virtual machine），它的责任是运行 Java 应用。JIT 代表即时编译（Just In Time compilation），当代码执行的次数超过一定的阈值时，会将 Java 字节码转换为本地代码，如，主要的热点代码会被准换为本地代码，这样有利大幅度提高 Java 应用的性能。 \r\n"
        },
        {
            "ID": "1145",
            "typeID": "11",
            "question": "解释 Java 堆空间及 GC？ ",
            "answer": "当通过 Java 命令启动 Java 进程的时候，会为它分配内存。内存的一部分用于创建堆空间，当程序中创建对象的时候，就从对空间中分配内存。GC 是 JVM 内部的一个进程，回收无效对象的内存用于将来的分配。 "
        },
        {
            "ID": "1144",
            "typeID": "11",
            "question": "你能保证 GC 执行吗？ ",
            "answer": "不能，虽然你可以调用 System.gc() 或者 Runtime.gc()，但是没有办法保证 GC 的执行。 \r\n"
        },
        {
            "ID": "1143",
            "typeID": "11",
            "question": "怎么获取 Java 程序使用的内存？堆使用的百分比？ ",
            "answer": "可以通过 java.lang.Runtime 类中与内存相关方法来获取剩余的内存，总内存及最大堆内存。通过这些方法你也可以获取到堆使用的百分比及堆内存的剩余空间。Runtime.freeMemory() 方法返回剩余空间的字节数，Runtime.totalMemory() 方法总内存的字节数，Runtime.maxMemory() 返回最大内存的字节数。 "
        },
        {
            "ID": "1142",
            "typeID": "11",
            "question": "Java 中堆和栈有什么区别？ ",
            "answer": "JVM 中堆和栈属于不同的内存区域，使用目的也不同。栈常用于保存方法帧和局部变量，而对象总是在堆上分配。栈通常都比堆小，也不会在多个线程之间共享，而堆被整个 JVM 的所有线程共享。 \r\n"
        },
        {
            "ID": "1141",
            "typeID": "11",
            "question": "“a==b”和”a.equals(b)”有什么区别？ ",
            "answer": "如果 a 和 b 都是对象，则 a==b 是比较两个对象的引用，只有当 a 和 b 指向的是堆中的同一个对象才会返回 true，而 a.equals(b) 是进行逻辑比较，所以通常需要重写该方法来提供逻辑一致性的比较。例如，String 类重写 equals() 方法，所以可以用于两个不同对象，但是包含的字母相同的比较。 \r\n"
        },
        {
            "ID": "1140",
            "typeID": "11",
            "question": "a.hashCode() 有什么用？与 a.equals(b) 有什么关系？ ",
            "answer": "hashCode() 方法是相应对象整型的 hash 值。它常用于基于 hash 的集合类，如 Hashtable、HashMap、LinkedHashMap等等。它与 equals() 方法关系特别紧密。根据 Java 规范，两个使用 equal() 方法来判断相等的对象，必须具有相同的 hash code。 \r\n"
        },
        {
            "ID": "1139",
            "typeID": "11",
            "question": "final、finalize 和 finally 的不同之处？ ",
            "answer": "final 是一个修饰符，可以修饰变量、方法和类。如果 final 修饰变量，意味着该变量的值在初始化后不能被改变。finalize 方法是在对象被回收之前调用的方法，给对象自己最后一个复活的机会，但是什么时候调用 finalize 没有保证。finally 是一个关键字，与 try 和 catch 一起用于异常的处理。finally 块一定会被执行，无论在 try 块中是否有发生异常。 \r\n"
        },
        {
            "ID": "1138",
            "typeID": "11",
            "question": "Java 中的编译期常量是什么？使用它又什么风险？ ",
            "answer": "公共静态不可变（public static final ）变量也就是我们所说的编译期常量，这里的 public 可选的。实际上这些变量在编译时会被替换掉，因为编译器知道这些变量的值，并且知道这些变量在运行时不能改变。这种方式存在的一个问题是你使用了一个内部的或第三方库中的公有编译时常量，但是这个值后面被其他人改变了，但是你的客户端仍然在使用老的值，甚至你已经部署了一个新的jar。为了避免这种情况，当你在更新依赖 JAR 文件时，确保重新编译你的程序。 "
        },
        {
            "ID": "1137",
            "typeID": "11",
            "question": " List、Set、Map 和 Queue 之间的区别？ ",
            "answer": "List 是一个有序集合，允许元素重复。它的某些实现可以提供基于下标值的常量访问时间，但是这不是 List 接口保证的。Set 是一个无序集合。 \r\n"
        },
        {
            "ID": "1136",
            "typeID": "11",
            "question": "poll() 方法和 remove() 方法的区别？ ",
            "answer": "poll() 和 remove() 都是从队列中取出一个元素，但是 poll() 在获取元素失败的时候会返回空，但是 remove() 失败的时候会抛出异常。 \r\n"
        },
        {
            "ID": "1135",
            "typeID": "11",
            "question": "Java 中 LinkedHashMap 和 PriorityQueue 的区别是什么？ ",
            "answer": "PriorityQueue 保证最高或者最低优先级的的元素总是在队列头部，但是 LinkedHashMap 维持的顺序是元素插入的顺序。当遍历一个 PriorityQueue 时，没有任何顺序保证，但是 LinkedHashMap 课保证遍历顺序是元素插入的顺序。 \r\n"
        },
        {
            "ID": "1134",
            "typeID": "11",
            "question": "ArrayList 与 LinkedList 的不区别？ ",
            "answer": "最明显的区别是 ArrrayList 底层的数据结构是数组，支持随机访问，而 LinkedList 的底层数据结构书链表，不支持随机访问。使用下标访问一个元素，ArrayList 的时间复杂度是 O(1)，而 LinkedList 是 O(n)。 "
        },
        {
            "ID": "1133",
            "typeID": "11",
            "question": "用哪两种方式来实现集合的排序？ ",
            "answer": "你可以使用有序集合，如 TreeSet 或 TreeMap，你也可以使用有顺序的的集合，如 list，然后通过 Collections.sort() 来排序。 "
        },
        {
            "ID": "1132",
            "typeID": "11",
            "question": "Java 中怎么打印数组？ ",
            "answer": "你可以使用 Arrays.toString() 和 Arrays.deepToString() 方法来打印数组。由于数组没有实现 toString() 方法，所以如果将数组传递给 System.out.println() 方法，将无法打印出数组的内容，但是 Arrays.toString() 可以打印每个元素。 \r\n"
        },
        {
            "ID": "1131",
            "typeID": "11",
            "question": "Hashtable 与 HashMap 有什么不同之处？ ",
            "answer": "这两个类有许多不同的地方，下面列出了一部分： \r\na) Hashtable 是 JDK 1 遗留下来的类，而 HashMap 是后来增加的。 \r\nb）Hashtable 是同步的，比较慢，但 HashMap 没有同步策略，所以会更快。 \r\nc）Hashtable 不允许有个空的 key，但是 HashMap 允许出现一个 null key。 "
        },
        {
            "ID": "1130",
            "typeID": "11",
            "question": "Java 中的 HashSet，内部是如何工作的？ ",
            "answer": "HashSet 的内部采用 HashMap来实现。由于 Map 需要 key 和 value，所以所有 key 的都有一个默认 value。类似于 HashMap，HashSet 不允许重复的 key，只允许有一个null key，意思就是 HashSet 中只允许存储一个 null 对象。 "
        },
        {
            "ID": "1129",
            "typeID": "11",
            "question": "写一段代码在遍历 ArrayList 时移除一个元素？ ",
            "answer": "该问题的关键在于面试者使用的是 ArrayList 的 remove() 还是 Iterator 的 remove()方法。这有一段示例代码，是使用正确的方式来实现在遍历的过程中移除元素，而不会出现 ConcurrentModificationException 异常的示例代码。 "
        },
        {
            "ID": "1128",
            "typeID": "11",
            "question": "我们能自己写一个容器类，然后使用 for-each 循环码？ ",
            "answer": "可以，你可以写一个自己的容器类。如果你想使用 Java 中增强的循环来遍历，你只需要实现 Iterable 接口。如果你实现 Collection 接口，默认就具有该属性。 \r\n"
        },
        {
            "ID": "1127",
            "typeID": "11",
            "question": "ArrayList 和 HashMap 的默认大小是多数？ ",
            "answer": "在 Java 7 中，ArrayList 的默认大小是 10 个元素，HashMap 的默认大小是16个元素（必须是2的幂）。这就是 Java 7 中 ArrayList 和 HashMap 类的代码片段： \r\n\r\n// from ArrayList.java JDK 1.7 \r\nprivate static final int DEFAULT_CAPACITY = 10; \r\n\r\n//from HashMap.java JDK 7 \r\nstatic final int DEFAULT_INITIAL_CAPACITY = 1 << 4; // aka 16 "
        },
        {
            "ID": "1126",
            "typeID": "11",
            "question": "有没有可能两个不相等的对象有有相同的 hashcode？ ",
            "answer": "有可能，两个不相等的对象可能会有相同的 hashcode 值，这就是为什么在 hashmap 中会有冲突。相等 hashcode 值的规定只是说如果两个对象相等，必须有相同的hashcode 值，但是没有关于不相等对象的任何规定。"
        },
        {
            "ID": "1125",
            "typeID": "11",
            "question": "两个相同的对象会有不同的的 hash code 吗？ ",
            "answer": "不能，根据 hash code 的规定，这是不可能的。 "
        },
        {
            "ID": "1124",
            "typeID": "11",
            "question": "我们可以在 hashcode() 中使用随机数字吗？ ",
            "answer": "不行，因为对象的 hashcode 值必须是相同的。参见答案获取更多关于 Java 中重写 hashCode() 方法的知识。"
        },
        {
            "ID": "1123",
            "typeID": "11",
            "question": "Java 中，Comparator 与 Comparable 有什么不同？ ",
            "answer": "Comparable 接口用于定义对象的自然顺序，而 comparator 通常用于定义用户定制的顺序。Comparable 总是只有一个，但是可以有多个 comparator 来定义对象的顺序。 "
        },
        {
            "ID": "1122",
            "typeID": "11",
            "question": "为什么在重写 equals 方法的时候需要重写 hashCode 方法？ ",
            "answer": "因为有强制的规范指定需要同时重写 hashcode 与 equal 是方法，许多容器类，如 HashMap、HashSet 都依赖于 hashcode 与 equals 的规定。 "
        },
        {
            "ID": "1121",
            "typeID": "11",
            "question": "Java 中，编写多线程程序的时候你会遵循哪些最佳实践？ ",
            "answer": "a）给线程命名，这样可以帮助调试。 \r\nb）最小化同步的范围，而不是将整个方法同步，只对关键部分做同步。 \r\nc）如果可以，更偏向于使用 volatile 而不是 synchronized。 \r\nd）使用更高层次的并发工具，而不是使用 wait() 和 notify() 来实现线程间通信，如 BlockingQueue，CountDownLatch 及 Semeaphore。 \r\ne）优先使用并发集合，而不是对集合进行同步。并发集合提供更好的可扩展性。 "
        },
        {
            "ID": "1120",
            "typeID": "11",
            "question": "说出几点 Java 中使用 Collections 的最佳实践？ ",
            "answer": "a）使用正确的集合类，例如，如果不需要同步列表，使用 ArrayList 而不是 Vector。 \r\nb）优先使用并发集合，而不是对集合进行同步。并发集合提供更好的可扩展性。 \r\nc）使用接口代表和访问集合，如使用List存储 ArrayList，使用 Map 存储 HashMap 等等。 \r\nd）使用迭代器来循环集合。 \r\ne）使用集合的时候使用泛型。 \r\n"
        },
        {
            "ID": "1119",
            "typeID": "11",
            "question": "说出在 Java 中使用线程的最佳实践？ ",
            "answer": "a）对线程命名 \r\nb）将线程和任务分离，使用线程池执行器来执行 Runnable 或 Callable。 \r\nc）使用线程池 \r\n"
        },
        {
            "ID": "1118",
            "typeID": "11",
            "question": "说出 IO 的最佳实践？ ",
            "answer": "a）使用有缓冲区的 IO 类，而不要单独读取字节或字符。 \r\nb）使用 NIO 和 NIO2 \r\nc）在 finally 块中关闭流，或者使用 try-with-resource 语句。 \r\nd）使用内存映射文件获取更快的 IO。 "
        },
        {
            "ID": "1117",
            "typeID": "11",
            "question": "列出应该遵循的 JDBC 最佳实践？ ",
            "answer": "a）使用批量的操作来插入和更新数据 \r\nb）使用 PreparedStatement 来避免 SQL 异常，并提高性能。 \r\nc）使用数据库连接池 \r\nd）通过列名来获取结果集，不要使用列的下标来获取。 "
        },
        {
            "ID": "1116",
            "typeID": "11",
            "question": "说出几条 Java 中方法重载的最佳实践？ ",
            "answer": "a）不要重载这样的方法：一个方法接收 int 参数，而另个方法接收 Integer 参数。 \r\nb）不要重载参数数量一致，而只是参数顺序不同的方法。 \r\nc）如果重载的方法参数个数多于 5 个，采用可变参数。 "
        },
        {
            "ID": "1115",
            "typeID": "11",
            "question": "在多线程环境下，SimpleDateFormat 是线程安全的吗？ ",
            "answer": "不是，非常不幸，DateFormat 的所有实现，包括 SimpleDateFormat 都不是线程安全的，因此你不应该在多线程序中使用，除非是在对外线程安全的环境中使用，如 将 SimpleDateFormat 限制在 ThreadLocal 中。如果你不这么做，在解析或者格式化日期的时候，可能会获取到一个不正确的结果。因此，从日期、时间处理的所有实践来说，我强力推荐 joda-time 库。 \r\n"
        },
        {
            "ID": "1114",
            "typeID": "11",
            "question": "Java 中如何格式化一个日期？如格式化为 ddMMyyyy 的形式？ ",
            "answer": "Java 中，可以使用 SimpleDateFormat 类或者 joda-time 库来格式日期。DateFormat 类允许你使用多种流行的格式来格式化日期。参见答案中的示例代码，代码中演示了将日期格式化成不同的格式，如 dd-MM-yyyy 或 ddMMyyyy。"
        },
        {
            "ID": "1113",
            "typeID": "11",
            "question": "接口是什么？为什么要使用接口而不是直接使用具体类？ ",
            "answer": "接口用于定义 API。它定义了类必须得遵循的规则。同时，它提供了一种抽象，因为客户端只使用接口，这样可以有多重实现，如 List 接口，你可以使用可随机访问的 ArrayList，也可以使用方便插入和删除的 LinkedList。接口中不允许写代码，以此来保证抽象，但是 Java 8 中你可以在接口声明静态的默认方法，这种方法是具体的。 "
        },
        {
            "ID": "1112",
            "typeID": "11",
            "question": "Java 中，抽象类与接口之间有什么不同？ ",
            "answer": "Java 中，抽象类和接口有很多不同之处，但是最重要的一个是 Java 中限制一个类只能继承一个类，但是可以实现多个接口。抽象类可以很好的定义一个家族类的默认行为，而接口能更好的定义类型，有助于后面实现多态机制。关于这个问题的讨论请查看答案。 \r\n"
        },
        {
            "ID": "1111",
            "typeID": "11",
            "question": "除了单例模式，你在生产环境中还用过什么设计模式？ ",
            "answer": "这需要根据你的经验来回答。一般情况下，你可以说依赖注入，工厂模式，装饰模式或者观察者模式，随意选择你使用过的一种即可。不过你要准备回答接下的基于你选择的模式的问题。 "
        },
        {
            "ID": "1110",
            "typeID": "11",
            "question": "适配器模式是什么？什么时候使用？ ",
            "answer": "适配器模式提供对接口的转换。如果你的客户端使用某些接口，但是你有另外一些接口，你就可以写一个适配去来连接这些接口。 "
        },
        {
            "ID": "1109",
            "typeID": "11",
            "question": "构造器注入和 setter 依赖注入，那种方式更好？ ",
            "answer": "每种方式都有它的缺点和优点。构造器注入保证所有的注入都被初始化，但是 setter 注入提供更好的灵活性来设置可选依赖。如果使用 XML 来描述依赖，Setter 注入的可读写会更强。经验法则是强制依赖使用构造器注入，可选依赖使用 setter 注入。 \r\n"
        },
        {
            "ID": "1108",
            "typeID": "11",
            "question": "依赖注入和工程模式之间有什么不同？ ",
            "answer": "虽然两种模式都是将对象的创建从应用的逻辑中分离，但是依赖注入比工程模式更清晰。通过依赖注入，你的类就是 POJO，它只知道依赖而不关心它们怎么获取。使用工厂模式，你的类需要通过工厂来获取依赖。因此，使用 DI 会比使用工厂模式更容易测试。 "
        },
        {
            "ID": "1107",
            "typeID": "11",
            "question": "适配器模式和装饰器模式有什么区别？ ",
            "answer": "虽然适配器模式和装饰器模式的结构类似，但是每种模式的出现意图不同。适配器模式被用于桥接两个接口，而装饰模式的目的是在不修改类的情况下给类增加新的功能。 "
        },
        {
            "ID": "1106",
            "typeID": "11",
            "question": "适配器模式和代理模式之前有什么不同？ ",
            "answer": "这个问题与前面的类似，适配器模式和代理模式的区别在于他们的意图不同。由于适配器模式和代理模式都是封装真正执行动作的类，因此结构是一致的，但是适配器模式用于接口之间的转换，而代理模式则是增加一个额外的中间层，以便支持分配、控制或智能访问。 "
        },
        {
            "ID": "1105",
            "typeID": "11",
            "question": "什么是模板方法模式？ ",
            "answer": "模板方法提供算法的框架，你可以自己去配置或定义步骤。例如，你可以将排序算法看做是一个模板。它定义了排序的步骤，但是具体的比较，可以使用 Comparable 或者其语言中类似东西，具体策略由你去配置。列出算法概要的方法就是众所周知的模板方法。 "
        },
        {
            "ID": "1104",
            "typeID": "11",
            "question": "什么时候使用访问者模式？ ",
            "answer": "访问者模式用于解决在类的继承层次上增加操作，但是不直接与之关联。这种模式采用双派发的形式来增加中间层。 "
        },
        {
            "ID": "1103",
            "typeID": "11",
            "question": "什么时候使用组合模式？ ",
            "answer": "组合模式使用树结构来展示部分与整体继承关系。它允许客户端采用统一的形式来对待单个对象和对象容器。当你想要展示对象这种部分与整体的继承关系时采用组合模式。 "
        },
        {
            "ID": "1102",
            "typeID": "11",
            "question": "继承和组合之间有什么不同？ ",
            "answer": "虽然两种都可以实现代码复用，但是组合比继承共灵活，因为组合允许你在运行时选择不同的实现。用组合实现的代码也比继承测试起来更加简单。 "
        },
        {
            "ID": "1101",
            "typeID": "11",
            "question": "描述 Java 中的重载和重写？ ",
            "answer": "重载和重写都允许你用相同的名称来实现不同的功能，但是重载是编译时活动，而重写是运行时活动。你可以在同一个类中重载方法，但是只能在子类中重写方法。重写必须要有继承。 \r\n"
        },
        {
            "ID": "1100",
            "typeID": "11",
            "question": "Java 中，嵌套公共静态类与顶级类有什么不同？ ",
            "answer": "类的内部可以有多个嵌套公共静态类，但是一个 Java 源文件只能有一个顶级公共类，并且顶级公共类的名称与源文件名称必须一致。 "
        },
        {
            "ID": "1099",
            "typeID": "11",
            "question": "OOP 中的 组合、聚合和关联有什么区别？ ",
            "answer": "如果两个对象彼此有关系，就说他们是彼此相关联的。组合和聚合是面向对象中的两种形式的关联。组合是一种比聚合更强力的关联。组合中，一个对象是另一个的拥有者，而聚合则是指一个对象使用另一个对象。如果对象 A 是由对象 B 组合的，则 A 不存在的话，B一定不存在，但是如果 A 对象聚合了一个对象 B，则即使 A 不存在了，B 也可以单独存在。 \r\n"
        },
        {
            "ID": "1098",
            "typeID": "11",
            "question": "给我一个符合开闭原则的设计模式的例子？ ",
            "answer": "开闭原则要求你的代码对扩展开放，对修改关闭。这个意思就是说，如果你想增加一个新的功能，你可以很容易的在不改变已测试过的代码的前提下增加新的代码。有好几个设计模式是基于开闭原则的，如策略模式，如果你需要一个新的策略，只需要实现接口，增加配置，不需要改变核心逻辑。一个正在工作的例子是 Collections.sort() 方法，这就是基于策略模式，遵循开闭原则的，你不需为新的对象修改 sort() 方法，你需要做的仅仅是实现你自己的 Comparator 接口。 "
        },
        {
            "ID": "1097",
            "typeID": "11",
            "question": "什么时候使用享元模式？ ",
            "answer": "享元模式通过共享对象来避免创建太多的对象。为了使用享元模式，你需要确保你的对象是不可变的，这样你才能安全的共享。JDK 中 String 池、Integer 池以及 Long 池都是很好的使用了享元模式的例子。 "
        },
        {
            "ID": "1096",
            "typeID": "11",
            "question": "讲讲 Java 中的集合有多少种，区别是什么？",
            "answer": "ArrayList、LinkedList、Vector的区别：ArrayList 和Vector底层是采用数组方式存储数据，Vector由于使用了synchronized方法（线程安全）所以性能上比ArrayList要差，LinkedList使用双向链表实现存储，随机存取比较慢\r\nHashMap的底层源码实现：当我们往HashMap中put元素的时候，先根据key的hashCode重新计算hash值，根据hash值得到这个元素在数组中的位置（即下标），如果数组该位置上已经存放有其他元素了，那么在这个位置上的元素将以链表的形式存放，新加入的放在链头，最先加入的放在链尾。如果数组该位置上没有元素，就直接将该元素放到此数组中的该位置上。\r\nFail-Fast机制:在使用迭代器的过程中有其他线程修改了map，那么将抛出ConcurrentModificationException，这就是所谓fail-fast机制。这一机制在源码中的实现是通过modCount域，modCount顾名思义就是修改次数，对HashMap内容的修改都将增加这个值，那么在迭代器初始化过程中会将这个值赋给迭代器的expectedModCount。在迭代过程中，判断modCount跟expectedModCount是否相等，如果不相等就表示已经有其他线程修改了Map.\r\nHashMap和 HashTable 的区别：\r\nHashTable比较老，是基于Dictionary 类实现的，HashTable 则是基于 Map接口实现的\r\nHashTable 是线程安全的， HashMap 则是线程不安全的\r\nHashMap可以让你将空值作为一个表的条目的key或value"
        },
        {
            "ID": "1095",
            "typeID": "11",
            "question": "JAVA 垃圾回收机制？",
            "answer": "什么是垃圾回收机：释放那些不再持有引用的对象的内存\r\n怎么判断一个对象是否需要收集？\r\n引用计数（最简单古老的方法）：指将资源（可以是对象、内存或磁盘空间等等）的被引用次数保存起来，当被引用次数变为零时就将其释放的过程\r\n对象引用遍历（现在大多数 jvm 使用的方法）：对象引用遍历从一组对象开始，沿着整个对象图上的每条链接，递归确定可到达（reachable）的对象。如果某对象不能从这些根对象的一个（至少一个）到达，则将它作为垃圾收集\r\n几种垃圾回收机制 \r\n标记回收法：遍历对象图并且记录可到达的对象，以便删除不可到达的对象，一般使用单线程工作并且可能产生内存碎片\r\n标记-压缩回收法：前期与第一种方法相同，只是多了一步，将所有的存活对象压缩到内存的一端，这样内存碎片就可以合成一大块可再利用的内存区域，提高了内存利用率\r\n复制回收法：把现有内存空间分成两部分，gc运行时，它把可到达对象复制到另一半空间，再清空正在使用的空间的全部对象。这种方法适用于短生存期的对象，持续复制长生存期的对象则导致效率降低。 \r\n分代回收发：把内存空间分为两个或者多个域，如年轻代和老年代，年轻代的特点是对象会很快被回收，因此在年轻代使用效率比较高的算法。当一个对象经过几次回收后依然存活，对象就会被放入称为老年的内存空间，老年代则采取标记-压缩算法"
        },
        {
            "ID": "1094",
            "typeID": "11",
            "question": "JAVA多态的实现原理？",
            "answer": "抽象的来讲，多态的意思就是同一消息可以根据发送对象的不同而采用多种不同的行为方式。（发送消息就是函数调用）\r\n实现的原理是动态绑定，程序调用的方法在运行期才动态绑定，追溯源码可以发现，JVM 通过参数的自动转型来找到合适的办法。"
        },
        {
            "ID": "1093",
            "typeID": "11",
            "question": "JAVA 中堆和栈的区别，说下java 的内存机制？",
            "answer": "基本数据类型比变量和对象的引用都是在栈分配的\r\n堆内存用来存放由new创建的对象和数组\r\n类变量（static修饰的变量），程序在一加载的时候就在堆中为类变量分配内存，堆中的内存地址存放在栈中\r\n实例变量：当你使用java关键字new的时候，系统在堆中开辟并不一定是连续的空间分配给变量，是根据零散的堆内存地址，通过哈希算法换算为一长串数字以表征这个变量在堆中的\"物理位置”,实例变量的生命周期--当实例变量的引用丢失后，将被GC（垃圾回收器）列入可回收“名单”中，但并不是马上就释放堆中内存\r\n局部变量: 由声明在某方法，或某代码段里（比如for循环），执行到它的时候在栈中开辟内存，当局部变量一但脱离作用域，内存立即释放"
        },
        {
            "ID": "1092",
            "typeID": "11",
            "question": "wait()和sleep()的区别？",
            "answer": "sleep来自Thread类，和wait来自Object类\r\n调用sleep()方法的过程中，线程不会释放对象锁。而 调用 wait 方法线程会释放对象锁\r\nsleep睡眠后不出让系统资源，wait让出系统资源其他线程可以占用CPU\r\nsleep(milliseconds)需要指定一个睡眠时间，时间一到会自动唤醒"
        },
        {
            "ID": "1091",
            "typeID": "11",
            "question": "解析XML的几种方式的原理与特点：DOM、SAX、PULL",
            "answer": "DOM：消耗内存：先把xml文档都读到内存中，然后再用DOM API来访问树形结构，并获取数据。这个写起来很简单，但是很消耗内存。要是数据过大，手机不够牛逼，可能手机直接死机\r\nSAX：解析效率高，占用内存少，基于事件驱动的：更加简单地说就是对文档进行顺序扫描，当扫描到文档(document)开始与结束、元素(element)开始与结束、文档(document)结束等地方时通知事件处理函数，由事件处理函数做相应动作，然后继续同样的扫描，直至文档结束。\r\nSAX：与 SAX 类似，也是基于事件驱动，我们可以调用它的next（）方法，来获取下一个解析事件（就是开始文档，结束文档，开始标签，结束标签），当处于某个元素时可以调用XmlPullParser的getAttributte()方法来获取属性的值，也可调用它的nextText()获取本节点的值。"
        },
        {
            "ID": "1090",
            "typeID": "11",
            "question": "抽象类和接口的区别？",
            "answer": "一个类只能继承单个类，但是可以实现多个接口\r\n接口强调特定功能的实现，而抽象类强调所属关系\r\n抽象类中的所有方法并不一定要是抽象的，你可以选择在抽象类中实现一些基本的方法。而接口要求所有的方法都必须是抽象的"
        },
        {
            "ID": "1089",
            "typeID": "11",
            "question": "Override和Overload的含义去区别",
            "answer": "Overload顾名思义是重新加载，它可以表现类的多态性，可以是函数里面可以有相同的函数名但是参数名、返回值、类型不能相同；或者说可以改变参数、类型、返回值但是函数名字依然不变。\r\n就是ride(重写)的意思，在子类继承父类的时候子类中可以定义某方法与其父类有相同的名称和参数，当子类在调用这一函数时自动调用子类的方法，而父类相当于被覆盖（重写）了。"
        },
        {
            "ID": "1088",
            "typeID": "11",
            "question": "String、StringBuffer与StringBuilder的区别",
            "answer": "String 类型和 StringBuffer 类型的主要性能区别其实在于 String 是不可变的对象\r\nStringBuffer和StringBuilder底层是 char[]数组实现的\r\nStringBuffer是线程安全的，而StringBuilder是线程不安全的\r\n"
        },
        {
            "ID": "1087",
            "typeID": "11",
            "question": "Hashcode的作用，与 equal 有什么区别",
            "answer": "同样用于鉴定2个对象是否相等的，java集合中有 list 和 set 两类，其中 set不允许元素重复实现，那个这个不允许重复实现的方法，如果用 equal 去比较的话，如果存在1000个元素，你 new 一个新的元素出来，需要去调用1000次 equal 去逐个和他们比较是否是同一个对象，这样会大大降低效率。hashcode实际上是返回对象的存储地址，如果这个位置上没有元素，就把元素直接存储在上面，如果这个位置上已经存在元素，这个时候才去调用equal方法与新元素进行比较，相同的话就不存了，散列到其他地址上"
        },
        {
            "ID": "1086",
            "typeID": "11",
            "question": "Java的四种引用，强弱软虚，用到的场景",
            "answer": "强引用：如果一个对象具有强引用，它就不会被垃圾回收器回收。即使当前内存空间不足，JVM也不会回收它，而是抛出 OutOfMemoryError 错误，使程序异常终止。如果想中断强引用和某个对象之间的关联，可以显式地将引用赋值为null，这样一来的话，JVM在合适的时间就会回收该对象\r\n软引用：在使用软引用时，如果内存的空间足够，软引用就能继续被使用，而不会被垃圾回收器回收，只有在内存不足时，软引用才会被垃圾回收器回收。\r\n弱引用：具有弱引用的对象拥有的生命周期更短暂。因为当 JVM 进行垃圾回收，一旦发现弱引用对象，无论当前内存空间是否充足，都会将弱引用回收。不过由于垃圾回收器是一个优先级较低的线程，所以并不一定能迅速发现弱引用对象\r\n虚引用：顾名思义，就是形同虚设，如果一个对象仅持有虚引用，那么它相当于没有引用，在任何时候都可能被垃圾回收器回收。\r\n使用场景：\r\n利用软引用和弱引用解决OOM问题：用一个HashMap来保存图片的路径和相应图片对象关联的软引用之间的映射关系，在内存不足时，JVM会自动回收这些缓存图片对象所占用的空间，从而有效地避免了OOM的问题\r\n通过软可及对象重获方法实现Java对象的高速缓存:比如我们创建了一Employee的类，如果每次需要查询一个雇员的信息。哪怕是几秒中之前刚刚查询过的，都要重新构建一个实例，这是需要消耗很多时间的。我们可以通过软引用和 HashMap 的结合，先是保存引用方面：以软引用的方式对一个Employee对象的实例进行引用并保存该引用到HashMap 上，key 为此雇员的 id，value为这个对象的软引用，另一方面是取出引用，缓存中是否有该Employee实例的软引用，如果有，从软引用中取得。如果没有软引用，或者从软引用中得到的实例是null，重新构建一个实例，并保存对这个新建实例的软引用"
        },
        {
            "ID": "1085",
            "typeID": "11",
            "question": "Object有哪些公用方法？",
            "answer": "方法equals测试的是两个对象是否相等\r\n方法clone进行对象拷贝\r\n方法getClass返回和当前对象相关的Class对象\r\n方法notify,notifyall,wait都是用来对给定对象进行线程同步的"
        },
        {
            "ID": "1084",
            "typeID": "11",
            "question": "equals与==的区别？",
            "answer": "==是判断两个变量或实例是不是指向同一个内存空间 \r\nequals是判断两个变量或实例所指向的内存空间的值是不是相同 "
        },
        {
            "ID": "1083",
            "typeID": "11",
            "question": "Switch能否用string做参数？",
            "answer": "在 Java 7  之前, switch 只能支持byte,short,char,int 或者其对应的封装类以及 Enum 类型。在JAVA 7中,String 支持被加上了。 "
        },
        {
            "ID": "1061",
            "typeID": "11",
            "question": "Android dvm的进程和Linux的进程, 应用程序的进程是否为同一个概念 ",
            "answer": "DVM指dalivk的虚拟机。每一个Android应用程序都在它自己的进程中运行，都拥有一个独立的Dalvik虚拟机实例。而每一个DVM都是在Linux 中的一个进程，所以说可以认为是同一个概念。"
        },
        {
            "ID": "1060",
            "typeID": "11",
            "question": "android系统的优势和不足",
            "answer": "Android平台手机 5大优势： \r\n⑴开放性 \r\n在优势方面，Android平台首先就是其开发性，开发的平台允许任何移动终端厂商加入到Android联盟中来。显著的开放性可以使其拥有更多的开发者，随着用户和应用的日益丰富，一个崭新的平台也将很快走向成熟。开放性对于Android的发展而言，有利于积累人气，这里的人气包括消费者和厂商，而对于消费者来讲，随大的受益正是丰富的软件资源。开放的平台也会带来更大竞争，如此一来，消费者将可以用更低的价位购得心仪的手机。\r\n⑵挣脱运营商的束缚 \r\n在过去很长的一段时间，特别是在欧美地区，手机应用往往受到运营商制约，使用什么功能接入什么网络，几乎都受到运营商的控制。从去年iPhone 上市 ，用户可以更加方便地连接网络，运营商的制约减少。随着EDGE、HSDPA这些2G至3G移动网络的逐步过渡和提升，手机随意接入网络已不是运营商口中的笑谈，当你可以通过手机IM软件方便地进行即时聊天时，再回想不久前天价的彩信和图铃下载业务，是不是像噩梦一样？互联网巨头Google推动的Android终端天生就有网络特色，将让用户离互联网更近。\r\n⑶丰富的硬件选择 \r\n这一点还是与Android平台的开放性相关，由于Android的开放性，众多的厂商会推出千奇百怪，功能特色各具的多种产品。功能上的差异和特色，却不会影响到数据同步、甚至软件的兼容，好比你从诺基亚 Symbian风格手机 一下改用苹果 iPhone ，同时还可将Symbian中优秀的软件带到iPhone上使用、联系人等资料更是可以方便地转移，是不是非常方便呢？\r\n⑷不受任何限制的开发商 \r\nAndroid平台提供给第三方开发商一个十分宽泛、自由的环境，不会受到各种条条框框的阻扰，可想而知，会有多少新颖别致的软件会诞生。但也有其两面性，血腥、暴力、情色方面的程序和游戏如可控制正是留给Android难题之一。\r\n⑸无缝结合的Google应用 \r\n如今叱诧互联网的Google已经走过10年度历史，从搜索巨人到全面的互联网渗透，Google服务如地图、邮件、搜索等已经成为连接用户和互联网的重要纽带，而Android平台手机将无缝结合这些优秀的Google服务。\r\n再说Android的5大不足：\r\n⑴安全和隐私 \r\n由于手机 与互联网的紧密联系，个人隐私很难得到保守。除了上网过程中经意或不经意留下的个人足迹，Google这个巨人也时时站在你的身后，洞穿一切，因此，互联网的深入将会带来新一轮的隐私危机。\r\n⑵首先开卖Android手机的不是最大运营商 \r\n众所周知，T-Mobile在23日，于美国纽约发布 了Android首款手机G1。但是在北美市场，最大的两家运营商乃AT&T和Verizon，而目前所知取得Android手机销售权的仅有 T-Mobile和Sprint，其中T-Mobile的3G网络相对于其他三家也要逊色不少，因此，用户可以买账购买G1，能否体验到最佳的3G网络服务则要另当别论了！\r\n⑶运营商仍然能够影响到Android手机 \r\n在国内市场，不少用户对购得移动定制机不满，感觉所购的手机被人涂画了广告一般。这样的情况在国外市场同样出现。Android手机的另一发售运营商Sprint就将在其机型中内置其手机商店程序。\r\n⑷同类机型用户减少 \r\n在不少手机论坛都会有针对某一型号的子论坛，对一款手机的使用心得交流，并分享软件资源。而对于Android平台手机，由于厂商丰富，产品类型多样，这样使用同一款机型的用户越来越少，缺少统一机型的程序强化。举个稍显不当的例子，现在山寨机泛滥，品种各异，就很少有专门针对某个型号山寨机的讨论和群组，除了哪些功能异常抢眼、颇受追捧的机型以外。\r\n⑸过分依赖开发商缺少标准配置 \r\n在使用PC端的Windows Xp系统的时候，都会内置微软Windows Media Player这样一个浏览器程序，用户可以选择更多样的播放器，如Realplay或暴风影音等。但入手开始使用默认的程序同样可以应付多样的需要。在 Android平台中，由于其开放性，软件更多依赖第三方厂商，比如Android系统的SDK中就没有内置音乐 播放器，全部依赖第三方开发，缺少了产品的统一性。\r\n"
        },
        {
            "ID": "1059",
            "typeID": "11",
            "question": "系统上安装了多种浏览器，能否指定某浏览器访问指定页面？请说明原由",
            "answer": "通过直接发送Uri把参数带过去，或者通过manifest里的intentfilter里的data属性"
        },
        {
            "ID": "1058",
            "typeID": "11",
            "question": "请解释下Android程序运行时权限与文件系统权限的区别",
            "answer": "运行时权限Dalvik( android授权) \r\n文件系统 linux 内核授权\r\n"
        },
        {
            "ID": "1057",
            "typeID": "11",
            "question": "AIDL的全称是什么？如何工作？能处理哪些类型的数据",
            "answer": "全称是：Android Interface Define Language\r\n在Android中, 每个应用程序都可以有自己的进程. 在写UI应用的时候, 经常要用到Service. 在不同的进程中, 怎样传递对象呢?显然, Java中不允许跨进程内存共享. 因此传递对象, 只能把对象拆分成操作系统能理解的简单形式, 以达到跨界对象访问的目的. 在J2EE中,采用RMI的方式, 可以通过序列化传递对象. 在Android中, 则采用AIDL的方式. 理论上AIDL可以传递Bundle,实际上做起来却比较麻烦。\r\nAIDL(AndRoid接口描述语言)是一种借口描述语言; 编译器可以通过aidl文件生成一段代码，通过预先定义的接口达到两个进程内部通信进程的目的. 如果需要在一个Activity中, 访问另一个Service中的某个对象, 需要先将对象转化成AIDL可识别的参数(可能是多个参数), 然后使用AIDL来传递这些参数, 在消息的接收端, 使用这些参数组装成自己需要的对象.\r\nAIDL的IPC的机制和COM或CORBA类似, 是基于接口的，但它是轻量级的。它使用代理类在客户端和实现层间传递值. 如果要使用AIDL, 需要完成2件事情: 1. 引入AIDL的相关类.; 2. 调用aidl产生的class.\r\nAIDL的创建方法:\r\nAIDL语法很简单,可以用来声明一个带一个或多个方法的接口，也可以传递参数和返回值。 由于远程调用的需要, 这些参数和返回值并不是任何类型.下面是些AIDL支持的数据类型:\r\n1)不需要import声明的简单Java编程语言类型(int,boolean等)\r\n2) String, CharSequence不需要特殊声明\r\n3) List, Map和Parcelables类型, 这些类型内所包含的数据成员也只能是简单数据类型, String等其他比支持的类型.\r\n(另外: 我没尝试Parcelables, 在Eclipse+ADT下编译不过, 或许以后会有所支持)\r\n"
        },
        {
            "ID": "1056",
            "typeID": "11",
            "question": "如何退出Activity？如何安全退出已调用多个Activity的Application",
            "answer": "对于单一Activity的应用来说，退出很简单，直接finish()即可。当然，也可以用killProcess()和System.exit()这样的方法。\r\n对于多个activity:\r\n1)记录打开的Activity：每打开一个Activity，就记录下来。在需要退出时，关闭每一个Activity即可\r\n2)发送特定广播：在需要结束应用时，发送一个特定的广播，每个Activity收到广播后，关闭即可。\r\n3)递归退出：在打开新的Activity时使用startActivityForResult，然后自己加标志，在onActivityResult中处理，递归关闭。为了编程方便，最好定义一个Activity基类，处理这些共通问题。\r\n在2.1之前，可以使用ActivityManager的restartPackage方法。\r\n它可以直接结束整个应用。在使用时需要权限android.permission.RESTART_PACKAGES。\r\n注意不要被它的名字迷惑。\r\n可是，在2.2，这个方法失效了。在2.2添加了一个新的方法，killBackground Processes()，需要权限 android.permission.KILL_BACKGROUND_PROCESSES。可惜的是，它和2.2的restartPackage一样，根本起不到应有的效果。\r\n另外还有一个方法，就是系统自带的应用程序管理里，强制结束程序的方法，forceStopPackage()。它需要权限android.permission.FORCE_STOP_PACKAGES。并且需要添加android:sharedUserId=\"android.uid.system\"属性。同样可惜的是，该方法是非公开的，他只能运行在系统进程，第三方程序无法调用。\r\n因为需要在Android.mk中添加LOCAL_CERTIFICATE := platform。\r\n而Android.mk是用于在Android源码下编译程序用的。\r\n从以上可以看出，在2.2，没有办法直接结束一个应用，而只能用自己的办法间接办到。\r\n现提供几个方法，供参考：\r\n1)抛异常强制退出：\r\n该方法通过抛异常，使程序Force Close。\r\n验证可以，但是，需要解决的问题是，如何使程序结束掉，而不弹出Force Close的窗口。\r\n2)记录打开的Activity：\r\n每打开一个Activity，就记录下来。在需要退出时，关闭每一个Activity即可。\r\n3)发送特定广播：\r\n在需要结束应用时，发送一个特定的广播，每个Activity收到广播后，关闭即可。\r\n4)递归退出\r\n在打开新的Activity时使用startActivityForResult，然后自己加标志，在onActivityResult中处理，递归关闭。\r\n除了第一个，都是想办法把每一个Activity都结束掉，间接达到目的。但是这样做同样不完美。你会发现，如果自己的应用程序对每一个Activity都设置了nosensor，在两个Activity结束的间隙，sensor可能有效了。但至少，我们的目的达到了，而且没有影响用户使用。为了编程方便，最好定义一个Activity基类，处理这些共通问题。\r\n"
        },
        {
            "ID": "1055",
            "typeID": "11",
            "question": "如何将一个Activity设置成窗口的样式？",
            "answer": "<activity>中配置：android :theme=\"@android:style/Theme.Dialog\" \r\n另外android:theme=\"@android:style/Theme.Translucent\" 是设置透明\r\n"
        },
        {
            "ID": "1054",
            "typeID": "11",
            "question": "如果后台的Activity由于某原因被系统回收了，如何在被系统回收之前保存当前状态？",
            "answer": "重写onSaveInstanceState()方法，在此方法中保存需要保存的数据，该方法将会在activity被回收之前调用。通过重写onRestoreInstanceState()方法可以从中提取保存好的数据"
        },
        {
            "ID": "1053",
            "typeID": "11",
            "question": "IntentService有何优点？",
            "answer": "Acitivity的进程，当处理Intent的时候，会产生一个对应的Service； Android的进程处理器现在会尽可能的不kill掉你；非常容易使用"
        },
        {
            "ID": "1052",
            "typeID": "11",
            "question": "Android本身的api并未声明会抛出异常，则其在运行时有无可能抛出runtime异常，你遇到过吗？诺有的话会导致什么问题？如何解决？",
            "answer": "会，比如nullpointerException。我遇到过，比如textview.setText()时，textview没有初始化。会导致程序无法正常运行出现forceclose。打开控制台查看logcat信息找出异常信息并修改程序。"
        },
        {
            "ID": "1051",
            "typeID": "11",
            "question": "Service和Thread的区别?",
            "answer": "servie是系统的组件，它由系统进程托管（servicemanager）；它们之间的通信类似于client和server，是一种轻量级的ipc通信，这种通信的载体是binder，它是在linux层交换信息的一种ipc。而thread是由本应用程序托管。 1). Thread：Thread 是程序执行的最小单元，它是分配CPU的基本单位。可以用 Thread 来执行一些异步的操作。\r\n2). Service：Service 是android的一种机制，当它运行的时候如果是Local Service，那么对应的 Service 是运行在主进程的 main 线程上的。如：onCreate，onStart 这些函数在被系统调用的时候都是在主进程的 main 线程上运行的。如果是Remote Service，那么对应的 Service 则是运行在独立进程的 main 线程上。\r\n既然这样，那么我们为什么要用 Service 呢？其实这跟 android 的系统机制有关，我们先拿 Thread 来说。Thread 的运行是独立于 Activity 的，也就是说当一个 Activity 被 finish 之后，如果你没有主动停止 Thread 或者 Thread 里的 run 方法没有执行完毕的话，Thread 也会一直执行。因此这里会出现一个问题：当 Activity 被 finish 之后，你不再持有该 Thread 的引用。另一方面，你没有办法在不同的 Activity 中对同一 Thread 进行控制。 \r\n举个例子：如果你的 Thread 需要不停地隔一段时间就要连接服务器做某种同步的话，该 Thread 需要在 Activity 没有start的时候也在运行。这个时候当你 start 一个 Activity 就没有办法在该 Activity 里面控制之前创建的 Thread。因此你便需要创建并启动一个 Service ，在 Service 里面创建、运行并控制该 Thread，这样便解决了该问题（因为任何 Activity 都可以控制同一 Service，而系统也只会创建一个对应 Service 的实例）。 \r\n因此你可以把 Service 想象成一种消息服务，而你可以在任何有 Context 的地方调用 Context.startService、Context.stopService、Context.bindService，Context.unbindService，来控制它，你也可以在 Service 里注册 BroadcastReceiver，在其他地方通过发送 broadcast 来控制它，当然这些都是 Thread 做不到的。\r\n"
        },
        {
            "ID": "1050",
            "typeID": "11",
            "question": "请介绍下ContentProvider是如何实现数据共享的",
            "answer": "一个程序可以通过实现一个Content provider的抽象接口将自己的数据完全暴露出去，而且Content providers是以类似数据库中表的方式将数据暴露。Content providers存储和检索数据，通过它可以让所有的应用程序访问到，这也是应用程序之间唯一共享数据的方法。\r\n要想使应用程序的数据公开化，可通过2种方法：创建一个属于你自己的Content provider或者将你的数据添加到一个已经存在的Content provider中，前提是有相同数据类型并且有写入Content provider的权限。\r\n如何通过一套标准及统一的接口获取其他应用程序暴露的数据\r\n\tAndroid提供了ContentResolver，外界的程序可以通过ContentResolver接口访问ContentProvider提供的数据\r\n"
        },
        {
            "ID": "1049",
            "typeID": "11",
            "question": "什么情况会导致Force Close ？如何避免？能否捕获导致其的异常",
            "answer": "程序出现异常，比如nullpointer。\r\n避免：编写程序时逻辑连贯，思维缜密。能捕获异常，在logcat中能看到异常信息\r\n"
        },
        {
            "ID": "1048",
            "typeID": "11",
            "question": "说明handler机制的原理?",
            "answer": "一个Handler允许你发送和处理Message和Runable对象，每个线程都有自己的Looper，每个Looper中封装着MessageQueue。 Looper负责不断的从自己的消息队列里取出队头的任务或消息执行。每个handler也和线程关联，Handler负责把Message和Runable\r\n对象传递给MessageQueue（用到post，sendMessage等方法），而且在这些对象离开MessageQueue时，Handler负责执行他们（用到handleMessage方法）。\r\n其中Message类就是定义了一个信息，这个信息中包含一个描述符和任意的数据对象，这个信息被用来传递给Handler.Message对象\r\n"
        },
        {
            "ID": "1047",
            "typeID": "11",
            "question": "请解释下在单线程模型中Message、Handler、Message Queue、Looper之间的关系",
            "answer": "简单的说，Handler获取当前线程中的looper对象，looper用来从存放Message的MessageQueue中取出Message，再有Handler进行Message的分发和处理.\r\nMessage Queue(消息队列)：用来存放\r\nHandler发布的消息，通常附属于某一个创建它的线程，可以通过Looper.myQueue()得到当前线程的消息队列\r\nHandler：可以发布或者处理一个消息或者操作一个Runnable，通过Handler发布消息，消息将只会发送到与它关联的消息队列，然也只能处理该消息队列中的消息\r\nLooper：是Handler和消息队列之间通讯桥梁，程序组件首先通过Handler把消息传递给Looper，Looper把消息放入队列。Looper也把消息队列里的消息广播给所有的\r\nHandler：Handler接受到消息后调用handleMessage进行处理\r\nMessage：消息的类型，在Handler类中的handleMessage方法中得到单个的消息进行处理\r\n在单线程模型下，为了线程通信问题，Android设计了一个Message Queue(消息队列)， 线程间可以通过该Message Queue并结合Handler和Looper组件进行信息交换。下面将对它们进行分别介绍：\r\n1） Message \r\n Message消息，理解为线程间交流的信息，处理数据后台线程需要更新UI，则发送Message内含一些数据给UI线程。\r\n2） Handler \r\n Handler处理者，是Message的主要处理者，负责Message的发送，Message内容的执行处理。后台线程就是通过传进来的 Handler对象引用来sendMessage(Message)。而使用Handler，需要implement 该类的 handleMessage(Message)方法，它是处理这些Message的操作内容，例如Update UI。通常需要子类化Handler来实现handleMessage方法。\r\n3） Message Queue \r\n Message Queue消息队列，用来存放通过Handler发布的消息，按照先进先出执行。\r\n 每个message queue都会有一个对应的Handler。Handler会向message queue通过两种方法发送消息：sendMessage或post。这两种消息都会插在message queue队尾并按先进先出执行。但通过这两种方法发送的消息执行的方式略有不同：通过sendMessage发送的是一个message对象,会被 Handler的handleMessage()函数处理；而通过post方法发送的是一个runnable对象，则会自己执行。\r\n4） Looper \r\n Looper是每条线程里的Message Queue的管家。Android没有Global的Message Queue，而Android会自动替主线程(UI线程)建立Message Queue，但在子线程里并没有建立Message Queue。所以调用Looper.getMainLooper()得到的主线程的Looper不为NULL，但调用Looper.myLooper() 得到当前线程的Looper就有可能为NULL。对于子线程使用Looper，API Doc提供了正确的使用方法：这个Message机制的大概流程：\r\n ①在Looper.loop()方法运行开始后，循环地按照接收顺序取出Message Queue里面的非NULL的Message。\r\n② 一开始Message Queue里面的Message都是NULL的。当Handler.sendMessage(Message)到Message Queue，该函数里面设置了那个Message对象的target属性是当前的Handler对象。随后Looper取出了那个Message，则调用 该Message的target指向的Hander的dispatchMessage函数对Message进行处理。在dispatchMessage方法里，如何处理Message则由用户指定，三个判断，优先级从高到低：\r\na)\tMessage里面的Callback，一个实现了Runnable接口的对象，其中run函数做处理工作；\r\nb)\tHandler里面的mCallback指向的一个实现了Callback接口的对象，由其handleMessage进行处理；\r\nc)\t处理消息Handler对象对应的类继承并实现了其中handleMessage函数，通过这个实现的handleMessage函数处理消息。\r\n 由此可见，我们实现的handleMessage方法是优先级最低的！\r\n ③ Handler处理完该Message (update UI) 后，Looper则设置该Message为NULL，以便回收！\r\n 在网上有很多文章讲述主线程和其他子线程如何交互，传送信息，最终谁来执行处理信息之类的，个人理解是最简单的方法——判断Handler对象里面的Looper对象是属于哪条线程的，则由该线程来执行！ \r\n①当Handler对象的构造函数的参数为空，则为当前所在线程的Looper； \r\n②Looper.getMainLooper()得到的是主线程的Looper对象，Looper.myLooper()得到的是当前线程的Looper对象。\r\n"
        },
        {
            "ID": "1046",
            "typeID": "11",
            "question": "如何启用Service，如何停用Service?",
            "answer": "服务的开发比较简单，如下：\r\n第一步：继承Service类\r\npublic class SMSService extends Service {}\r\n第二步：在AndroidManifest.xml文件中的<application>节点里对服务进行配置:<service android:name=\".SMSService\" />\r\n服务不能自己运行，需要通过调用Context.startService()或Context.bindService()方法启动服务。这两个方法都可以启动Service，但是它们的使用场合有所不同。使用startService()方法启用服务，调用者与服务之间没有关连，即使调用者退出了，服务仍然运行。使用bindService()方法启用服务，调用者与服务绑定在了一起，调用者一旦退出，服务也就终止，大有“不求同时生，必须同时死”的特点。\r\n如果打算采用Context.startService()方法启动服务，在服务未被创建时，系统会先调用服务的onCreate()方法，接着调用onStart()方法。如果调用startService()方法前服务已经被创建，多次调用startService()方法并不会导致多次创建服务，但会导致多次调用onStart()方法。采用startService()方法启动的服务，只能调用Context.stopService()方法结束服务，服务结束时会调用onDestroy()方法。\r\n如果打算采用Context.bindService()方法启动服务，在服务未被创建时，系统会先调用服务的onCreate()方法，接着调用onBind()方法。这个时候调用者和服务绑定在一起，调用者退出了，系统就会先调用服务的onUnbind()方法，接着调用onDestroy()方法。如果调用bindService()方法前服务已经被绑定，多次调用bindService()方法并不会导致多次创建服务及绑定(也就是说onCreate()和onBind()方法并不会被多次调用)。如果调用者希望与正在绑定的服务解除绑定，可以调用unbindService()方法，调用该方法也会导致系统调用服务的onUnbind()-->onDestroy()方法。\r\n服务常用生命周期回调方法如下： \r\nonCreate() 该方法在服务被创建时调用，该方法只会被调用一次，无论调用多少次startService()或bindService()方法，服务也只被创建一次。\r\nonDestroy()该方法在服务被终止时调用。\r\n与采用Context.startService()方法启动服务有关的生命周期方法\r\nonStart() 只有采用Context.startService()方法启动服务时才会回调该方法。该方法在服务开始运行时被调用。多次调用startService()方法尽管不会多次创建服务，但onStart() 方法会被多次调用。\r\n与采用Context.bindService()方法启动服务有关的生命周期方法\r\nonBind()只有采用Context.bindService()方法启动服务时才会回调该方法。该方法在调用者与服务绑定时被调用，当调用者与服务已经绑定，多次调用Context.bindService()方法并不会导致该方法被多次调用。\r\nonUnbind()只有采用Context.bindService()方法启动服务时才会回调该方法。该方法在调用者与服务解除绑定时被调用\r\n"
        },
        {
            "ID": "1045",
            "typeID": "11",
            "question": "activity的启动模式有哪些？是什么含义",
            "answer": "在android里，有4种activity的启动模式，分别为： \r\n“standard” (默认) \r\n“singleTop” \r\n“singleTask” \r\n“singleInstance”\r\n它们主要有如下不同：\r\n1)如何决定所属task \r\n“standard”和”singleTop”的activity的目标task，和收到的Intent的发送者在同一个task内，除非intent包括参数FLAG_ACTIVITY_NEW_TASK。 \r\n如果提供了FLAG_ACTIVITY_NEW_TASK参数，会启动到别的task里。 \r\n“singleTask”和”singleInstance”总是把activity作为一个task的根元素，他们不会被启动到一个其他task里。\r\n2)是否允许多个实例 \r\n“standard”和”singleTop”可以被实例化多次，并且存在于不同的task中，且一个task可以包括一个activity的多个实例； \r\n“singleTask”和”singleInstance”则限制只生成一个实例，并且是task的根元素。 singleTop要求如果创建intent的时候栈顶已经有要创建 的Activity的实例，则将intent发送给该实例，而不发送给新的实例。\r\n3)是否允许其它activity存在于本task内 \r\n“singleInstance”独占一个task，其它activity不能存在那个task里；如果它启动了一个新的activity，不管新的activity的launch mode 如何，新的activity都将会到别的task里运行（如同加了FLAG_ACTIVITY_NEW_TASK参数）。 \r\n而另外三种模式，则可以和其它activity共存。\r\n4)是否每次都生成新实例 \r\n“standard”对于没一个启动Intent都会生成一个activity的新实例； \r\n“singleTop”的activity如果在task的栈顶的话，则不生成新的该activity的实例，直接使用栈顶的实例，否则，生成该activity的实例。 \r\n比如现在task栈元素为A-B-C-D（D在栈顶），这时候给D发一个启动intent，如果D是 “standard”的，则生成D的一个新实例，栈变为A－B－C－D－D。 \r\n如果D是singleTop的话，则不会生产D的新实例，栈状态仍为A-B-C-D \r\n如果这时候给B发Intent的话，不管B的launchmode是”standard” 还是 “singleTop” ，都会生成B的新实例，栈状态变为A-B-C-D-B。\r\n“singleInstance”是其所在栈的唯一activity，它会每次都被重用。\r\n“singleTask”如果在栈顶，则接受intent，否则，该intent会被丢弃，但是该task仍会回到前台。\r\n当已经存在的activity实例处理新的intent时候，会调用onNewIntent()方法 如果收到intent生成一个activity实例，那么用户可以通过back键回到上一个状态；如果是已经存在的一个activity来处理这个intent的话，用户不能通过按back键返回到这之前的状态。\r\n"
        },
        {
            "ID": "1044",
            "typeID": "11",
            "question": "android中的动画有哪几类，它们的特点和区别是什么 ",
            "answer": "两种，一种是Tween动画、还有一种是Frame动画。Tween动画，这种实现方式可以使视图组件移动、放大、缩小以及产生透明度的变化;另一种Frame动画，传统的动画方法，通过顺序的播放排列好的图片来实现，类似电影。"
        },
        {
            "ID": "1043",
            "typeID": "11",
            "question": "请介绍下Android中常用的五种布局",
            "answer": "常用五种布局方式，分别是：FrameLayout（框架布局），LinearLayout （线性布局），AbsoluteLayout（绝对布局），RelativeLayout（相对布局），TableLayout（表格布局）。\r\n1)FrameLayout：所有东西依次都放在左上角，会重叠，这个布局比较简单，也只能放一点比较简单的东西。2)LinearLayout：线性布局，每一个LinearLayout里面又可分为垂直布局（android:orientation=\"vertical\"）和水平布局（android:orientation=\"horizontal\" ）。当垂直布局时，每一行就只有一个元素，多个元素依次垂直往下；水平布局时，只有一行，每一个元素依次向右排列。\r\n3)AbsoluteLayout：绝对布局用X,Y坐标来指定元素的位置，这种布局方式也比较简单，但是在屏幕旋转时，往往会出问题，而且多个元素的时候，计算比较麻烦。\r\n4)RelativeLayout：相对布局可以理解为某一个元素为参照物，来定位的布局方式。主要属性有：相对于某一个元素android:layout_below、 android:layout_toLeftOf相对于父元素的地方android:layout_alignParentLeft、android:layout_alignParentRigh;\r\n5)TableLayout：表格布局，每一个TableLayout里面有表格行TableRow，TableRow里面可以具体定义每一个元素。每一个布局都有自己适合的方式，这五个布局元素可以相互嵌套应用，做出美观的界面。\r\n"
        },
        {
            "ID": "1042",
            "typeID": "11",
            "question": "客户端如何实现自动登录？",
            "answer": "通过SharedPreferences存储用户名,密码,当存储不为空时实现自动登录功能。"
        },
        {
            "ID": "1041",
            "typeID": "11",
            "question": "实现手风琴效果？",
            "answer": "问：哪个组件可以实现手风琴效果，用来实现设置界面的类，实现抽屉效果, 悬浮窗口？\r\n答：\r\n实现手风琴效果（ExpandableListView）\r\n设置界面的类（preferenceActivity）保存到sharedpreference中\r\n抽屉效果（slidingDrawer）组件\r\n悬浮窗口: PopWindow,可以实现类似Dialog和菜单的效果\r\n"
        },
        {
            "ID": "1040",
            "typeID": "11",
            "question": "谈谈UI中， Padding和Margin有什么区别,gravity与layout_gravity的区别？",
            "answer": "Padding 用来指定组件内的内容距离组件边界的距离;\r\nMargin 用来指定控件与控件之间的距离\r\nGravity 用来指定组件内的内容相对于组件本身的位置\r\nLayout_gravity 用来指定组件相对于其父组件的位置\r\n"
        },
        {
            "ID": "1039",
            "typeID": "11",
            "question": "如何将一个Activity设置成窗口的样式？",
            "answer": "在清单文件AndroidManifest.xml中相应的<activity>标签内设置属性android:theme=”@android:style/Theme.Dialog”"
        },
        {
            "ID": "1038",
            "typeID": "11",
            "question": "AndroidManifest.xml清单文件涵义？",
            "answer": "\b问：\r\nAndroidManifest.xml清单文件<Activity>标签中属性的含义\r\nAndroidManifest.xml清单文件<Activity>标签中属性android:excludeFromRecents=\"true\" android:screenOrientation=\"portrait\" android:configChanges=\"orientation|locale\"的含义\r\n答:\r\n android:excludeFromRecents表示是否可被显示在最近打开的activity列表里,true表示否,false表示是\r\nandroid:screenOrientation表示activity显示的模式, 一般用来设置activity横屏显示(horizontal)或竖屏显示(portrait)\r\nandroid:configChanges=[oneormoreof:\"mcc\"\"mnc\"\"locale\"\"touchscreen\"\"keyboard\"\"keyboardHidden\"\"navigation\"\"orientation\"\"fontScale\"]\r\n是当所指定属性(Configuration Changes)发生改变时，通知程序调用 onConfigurationChanged()函数,比如orientation屏幕方向发生改变,locale语言环境发生改变时\r\n"
        },
        {
            "ID": "1037",
            "typeID": "11",
            "question": "如何实现一键退出",
            "answer": "定义一个类继承Application，定义一个集合存放所有的activity， 定义一个添加的方法，再写一个退出的方法，使用for循环全部调用finish方法，然后在每个Activity的onCreate方法中调用自定义类里的添加方法，然后在需要使用一键退出的地方调用类中的退出方法即可。\r\n"
        },
        {
            "ID": "1036",
            "typeID": "11",
            "question": "NDK开发流程？（JNI运行原理）",
            "answer": "NDK应用的开发流程(在应用中定义本地接口(native), 编译成.h头文件,交由C程序员实现,将.c实现通过NDK编译成.so动态链接库,导入项目中libs/armeabi,代码中调用该本地接口)\r\n应用场景: 音频,视频解码,拍摄车牌号,识别车牌号\r\n"
        },
        {
            "ID": "1035",
            "typeID": "11",
            "question": "播放视频有哪些实现方式？",
            "answer": "1)使用系统自带的播放器来播放，指定Action为ACTION_VIEW,Data为Uri，Type为其MIME类型。\r\n\t\t\t//调用系统自带的播放器 \r\n Intent intent = new Intent(Intent.ACTION_VIEW); \r\n intent.setDataAndType(uri, \"video/mp4\"); \r\n startActivity(intent);\r\n2)使用VideoView组件来播放, 可以结合MediaController来实现播控, 只是不能随意更改视频的大小及位置。\r\n3)使用MediaPlayer和SurfaceView来实现，这种方式很灵活,可以自定义视频播放的大小和位置。\r\n"
        },
        {
            "ID": "1034",
            "typeID": "11",
            "question": "说说版本更新的实现思路",
            "answer": "在服务器相应URL上有版本文件, 客户端同时存储该应用当前版本号 (SharedPreferences/Sqlite), 每次打开应用,去检测服务器版本号与本地版本号是否一致,如果不一 致,则自定义对话框提示是否下载更新。"
        },
        {
            "ID": "1033",
            "typeID": "11",
            "question": "自定义组件实现思路？",
            "answer": "自定义组件有三种实现思路:\r\n1) 继承某个现有组件，在其基础上添加额外功能,如继承Gallery实现CoverFlow效果\r\n2) 继承某个Layout，实现复合组件自定义，如TextView和EditText组合实现登录注册组件\r\n3) 继承View，实现onDraw()方法，实现自己绘制组件，如翻页效果组件\r\n"
        },
        {
            "ID": "1032",
            "typeID": "11",
            "question": "MVC在Android中的应用？",
            "answer": "Android中界面部分也采用了当前比较流行的MVC框架，在Android中： \r\n1) 视图层（View）：一般采用XML文件进行界面的描述，使用的时候可以非常方便的引入。也可以使用JavaScript+HTML等的方式作为View层，通过WebView组件加载,同时可以实现Java和JavaScript之间的通信。 \r\n2) 控制层（Controller）：这句话也就暗含了不要在Acitivity中写代码，要通过Activity交割Model业务逻辑层处理，这样做的另外一个原因是Android中的Acitivity的响应时间是5s，如果耗时的操作放在这里，Android的控制层的重任通常落在了众多的Acitvity的肩上，程序就很容易被回收掉。\r\n3) 模型层（Model）：对数据库的操作、对网络等的操作都应该在Model里面处理，当然对业务计算等操作也是必须放在的该层的。\r\n 在Android SDK中的数据绑定，也都是采用了与MVC框架类似的方法来显示数据。在控制层上将数据按照视图模型的要求（也就是Android SDK中的Adapter）封装就可以直接在视图模型上显示了，从而实现了数据绑定。比如显示Cursor中所有数据的ListActivity，其视图层就是一个ListView，将数据封装为ListAdapter，并传递给ListView，数据就在ListView中显示。\r\n"
        },
        {
            "ID": "1031",
            "typeID": "11",
            "question": "如何实现消息推送，有哪些方式，各自优缺点，最常使用哪种？",
            "answer": "实现消息推送的方式有五种，分别是轮询，SMS,C2DM,MQTT,XMPP最常使用的是XMPP, 我们做项目时采用的是XMPP协议\r\n1)XMPP协议，它是一种基于XML的传递协议，具有很强的灵活性和可扩展性。它的特点是将复杂性从客户端转移到了服务器端。GTalk、QQ、IM等都用这个协议。\r\n2)轮询:客户端定时去服务端取或者保持一个长Socket，从本质讲这个不叫推送，而是去服务端拽数据。但是实现简单，主要缺点：耗电,浪费用户流量等\r\n3)Google的C2DM，具体不细说，缺点，服务器在国外，不是很稳定。\r\n4)通过短信方式, 但是很难找到免费短信平台\r\n5.)MQTT协议, IBM提供的一种推送服务,不太灵活"
        },
        {
            "ID": "1030",
            "typeID": "11",
            "question": "简述Android缓存机制？",
            "answer": "客户端缓存机制是android应用开发中非常重要的一项工作,使用缓存机制不仅仅可以为用户节省3G流量,同时在用户体验方面也是非常好的选择，比如有些新闻客户端支持离线模式，也是通过缓存机制实现的.缓存机制分为两部分,一部分是文字缓存,另一部分是多媒体文件缓存.\r\n文字缓存有两种实现：\r\n1）可以将与服务器交互得到的json数据或者xml数据存入sd卡中，并在数据库添加该数据的记录.添加数据库记录时,提供两个关键字段,一个是请求的URL,另一个则是本地保存后的文件地址，每次加载数据之前都会根据URL在数据库中检索\r\n2）将JSON数据解析后装入List<Map>对象中,然后遍历List,将数据统统写入相应的数据库表结构中,以后每次向服务器发起请求之前可以先在数据库中检索,如果有直接返回.\r\n多媒体文件缓存：主要指图片缓存\r\n图片的缓存可以根据当前日期,时间为名字缓存到SD卡中的指定图片缓存目录,同时数据库中做相应记录,记录办法可以采用两个关键字段控制,一个字段是该图片的URL地址,另一个字段是该图片的本机地址.取图片时根据URL在数据中检索,如果没有则连接服务器下载,下载之后再服务器中作出相应记录\r\n缓存文件删除策略:\r\n1) 每一个模块在每次客户端自动或者用户手动更新的时候删除相应模块的缓存文件,并重新下载新的缓存文件.\r\n2)在设置界面中提供删除缓存的功能,点击后删除本机所有缓存.\r\n"
        },
        {
            "ID": "1029",
            "typeID": "11",
            "question": "加载大图片的时候如何防止内存溢出?",
            "answer": "Android系统给图片分配的内存只有8M,当加载大量图片时往往会出现OOM。\r\nAndroid加载大量图片内存溢出解决方案：\r\n1）尽量不要使用setImageBitmap或setImageResource或BitmapFactory.decodeResource来设置一张大图，因为这些函数在完成decode后，最终都是通过java层的createBitmap来完成的，需要消耗更多内存，可以通过BitmapFactory.decodeStream方法，创建出一个bitmap，再将其设为ImageView的 source \r\n2）使用BitmapFactory.Options对图片进行压缩\r\n InputStream is = this.getResources().openRawResource(R.drawable.pic1);\r\n BitmapFactory.Options options=new BitmapFactory.Options();\r\n options.inJustDecodeBounds = false;\r\n options.inSampleSize = 10; //width，hight设为原来的十分一\r\n Bitmap btp =BitmapFactory.decodeStream(is,null,options); \r\n3）运用Java软引用，进行图片缓存，将需要经常加载的图片放进缓存里，避免反复加载\r\n及时销毁不再使用的Bitmap对象\r\n if(!bmp.isRecycle() ){\r\n bmp.recycle() //回收图片所占的内存\r\n system.gc() //提醒系统及时回收\r\n } \r\n"
        },
        {
            "ID": "1028",
            "typeID": "11",
            "question": "内存的优化?",
            "answer": "内存泄露容易导致内存溢出，又称为OOM。\r\n内存优化策略：\r\n1）在循环内尽量不要使用局部变量\r\n2）不用的对象即时释放，即指向NULL \r\n3）数据库的cursor即时关闭。\r\n4）构造adapter时使用缓存contentview\r\n5）调用registerReceiver()后在对应的生命周期方法中调用unregisterReceiver()\r\n6）即时关闭InputStream/OutputStream。\r\n7）android系统给图片分配的内存只有8M, 图片尽量使用软引用, 较大图片可通过BitmapFactory缩放后再使用,并及时recycle \r\n8）尽量避免static成员变量引用资源耗费过多的实例。"
        },
        {
            "ID": "1027",
            "typeID": "11",
            "question": "GC内存泄露在什么情况下会出现？怎么解决",
            "answer": "a)\t查询数据库没有关闭游标\r\nb)\t构造Adapter时，没有使用缓存的 convertView\r\nc)\tBitmap对象不在使用时调用recycle()释放内存\r\nd)\t不用的对象没有及时释放对象的引用\r\n"
        },
        {
            "ID": "1026",
            "typeID": "11",
            "question": "百度地图核心类，及实现的功能",
            "answer": "BMapManager:地图引擎管理类,负责初始化，开启地图API，终止百度地图API等工作\r\nMKSearch：搜索服务.用于位置检索、周边检索、范围检索、公交检索、驾乘检索、步行检索\r\nMKSearchListener搜索结果通知接口。该接口返回poi搜索,公交搜索,驾乘路线,步行路线结果\r\nMapView:显示地图的View\r\nMyLocationOverlay:一个负责显示用户当前位置的Overlay。\r\nOverlay:Overlay是一个基类，它表示可以显示在地图上方的覆盖物。\r\n"
        },
        {
            "ID": "1025",
            "typeID": "11",
            "question": "SAX解析代码",
            "answer": "首先SAXParserFactory来创建一个SAXParserFactory实例\r\nSAXParserFactory factory = SAXParserFactory.newInstance();\r\n根据SAXParserFactory实例来创建SAXParser\r\nSAXParser产生SAXReader\r\nXMLReader reader = factory.newSAXParser().getXMLReader();\r\nXMLReader 加载XML，然后解析XML，在解析的过程中触发相对于接口中的事件处理程序\r\n"
        },
        {
            "ID": "1024",
            "typeID": "11",
            "question": "XML解析有哪几种？各自优缺点，官方推荐使用哪种",
            "answer": "基本的解析方式有三种: DOM,SAX,Pull\r\n1)dom解析解析器读入整个文档，然后构建一个驻留内存的树结构，然后代码就可以使用 DOM 接口来操作这个树结构的优点是对文档增删改查比较方便，缺点占用内存比较大。\r\n2)sax解析基于事件驱动型,优点占用内存少，解析速度快，缺点是只适合做文档的读取，不适合做文档的增删改查。\r\n3)pull解析同样基于事件驱动型,android 官方API提供,可随时终止,调用next() 方法提取它们（主动提取事件）\r\n"
        },
        {
            "ID": "1023",
            "typeID": "11",
            "question": "Java中垃圾回收有什么目的？什么时候进行垃圾回收？",
            "answer": "垃圾回收的目的是识别并且丢弃应用不再使用的对象来释放和重用资源。"
        },
        {
            "ID": "865",
            "typeID": "11",
            "question": "说说Json与xml的区别？",
            "answer": "1)JSON和XML的数据可读性基本相同\r\n2)JSON和XML同样拥有丰富的解析手段\r\n3)JSON相对于XML来讲，数据的体积小\r\n4)JSON与JavaScript的交互更加方便\r\n5)JSON对数据的描述性比XML较差\r\n"
        },
        {
            "ID": "864",
            "typeID": "11",
            "question": "说说HttpClient的通信过程?",
            "answer": "1)生成请求对象（HttpGet get，HttpPost post）\r\n2)生成客户端对象 HttpClient client\r\n3)执行请求接收相应 HttpResponse response = client.execute(post)\r\nHttpEntity entity = response.getEntity()\r\n4)得到数据流\r\nInputStream inputStream = entity.getContent();\r\n5)最后关闭过期连接\r\n"
        },
        {
            "ID": "863",
            "typeID": "11",
            "question": "Android哪几种方式访问网络",
            "answer": "http协议：超文本传输协议\r\n(最底层的是Socket,接着是URLConnection，HttpClient)\r\nHttpURLConnection \r\nHttpClient方式（HttpGet和HttpPost类）\r\n"
        },
        {
            "ID": "862",
            "typeID": "11",
            "question": "Android程序入口如何判断？",
            "answer": "action节点中的android.intent.action.MAIN表明它所在的Activity是整个应用程序的入口点"
        },
        {
            "ID": "861",
            "typeID": "11",
            "question": "简述Android中的IPC机制？",
            "answer": "IPC（Inter-Process Communication，进程间通信）,aidl是 Android Interface definition language的缩写，它是一种android内部进程通信接口的描述语言，通过它我们可以定义进程间的通信接口.编译器可以通过扩展名为aidl的文件生成一段代码，通过预先定义的接口达到两个进程内部通信进程的目的.\r\nBroadcastReceiver也可以实现进程间通信\r\nContentProvider 提供进程间数据共享\r\n"
        },
        {
            "ID": "860",
            "typeID": "11",
            "question": "如何实现屏幕分辨率的自适应（布局、九线图、目录）?",
            "answer": "最好可以通过权重(layout_weight)的方式来分配每个组件的大小，也可以通过具体的像素(dip)来确定大小。\r\n尽量使用Relativelayout 。\r\n已知应用支持平台设备的分辨率,可以提供多个layout_320*480 ...\r\ndrawable-,drawable-mdpi,drawable-ldpi分别代表分辨率为480*800,360*480,240*360, hdpi放置图片大小相差1.5倍\r\n最后还需要在AndroidManifest.xml里添加下面一段，没有这一段自适应就不能实现：\r\n<supports-screens\r\nandroid:largeScreens=\"true\"\r\nandroid:normalScreens=\"true\"\r\n android:anyDensity = \"true\"/>\r\n在</application>标签和</manifest> 标签之间添加上面那段代码。即可。\r\n备注：三者的解析度不一样，就像你把电脑的分辨率调低，图片会变大一样，反之分辨率高，图片缩小\r\n还可以通过.9.png实现图片的自适应\r\n"
        },
        {
            "ID": "859",
            "typeID": "11",
            "question": "Intent的原理、作用、可以传递哪些类型的参数?",
            "answer": "intent是连接Activity, Service, BroadcastReceiver, ContentProvider四大组件的信使,，可以传递八种基本数据类型以及string, Bundle类型，以及实现了Serializable或者Parcelable的类型。\r\nIntent可以划分成显式意图和隐式意图。 \r\n显式意图：调用Intent.setComponent()或Intent.setClass()方法明确指定了组件名的Intent为显式意图，显式意图明确指定了Intent应该传递给哪个组件。 \r\n隐式意图：没有明确指定组件名的Intent为隐式意图。 Android系统会根据隐式意图中设置的动作(action)、类别(category)、数据（URI和数据类型）找到最合适的组件来处理这个意图。\r\n"
        },
        {
            "ID": "858",
            "typeID": "11",
            "question": "ListView图片异步加载实现思路?",
            "answer": "1)先从内存缓存中获取图片显示（内存缓冲） \r\n2)获取不到的话从SD卡里获取（SD卡缓冲，从SD卡获取图片是放在子线程里执行的，否则快速滑屏的话会不够流畅） \r\n3)都获取不到的话从网络下载图片并保存到SD卡同时加入内存并显示（视情况看是否要显示）\r\n"
        },
        {
            "ID": "857",
            "typeID": "11",
            "question": "ListView分页加载实现思路?",
            "answer": "实现OnScrollListener 接口重写onScrollStateChanged 和onScroll方法，使用onscroll方法实现”滑动“后处理检查是否还有新的记录，如果有，调用 addFooterView，添加记录到adapter, adapter调用 notifyDataSetChanged 更新数据;如果没有记录了，把自定义的mFooterView去掉。使用onScrollStateChanged可以检测是否滚到最后一行且停止滚动然后执行加载 "
        },
        {
            "ID": "856",
            "typeID": "11",
            "question": "listview优化策略?",
            "answer": "1)对convetView进行判空，是当convertView不为空的时候直接重新使用convertView\r\n从而减少了很多不必要的View的创建 \r\n2)定义一个ViewHolder，将convetView的tag设置为ViewHolder,不为空时重新使用即可\r\n3)当ListView加载数据量较大时可以采用分页加载和图片异步加载\r\n"
        },
        {
            "ID": "855",
            "typeID": "11",
            "question": "什么是ANR 如何避免它？（Android线程间的通信方式 ）",
            "answer": "ANR：Application Not Responding(应用程序无响应).当出现下列情况时，Android就会显示ANR对话框了： 对输入事件（如按键、触摸屏事件）的响应超过5秒 意向接受器（intentReceiver）超过10秒钟仍未执行完毕Android应用程序完全运行在一个独立的线程中（例如main）。这就意味着，任何在主线程中运行的，需要消耗大量时间的操作都会引发ANR。\r\n解决方案有两种:\r\n1)AsyncTask异步任务中，doInBackground()和onPostExecute(Result)两个方法非常重要\r\ndoInBackground() 这个方法运行在后台线程中，主要负责执行那些很耗时的操作，如移动护理系统中的网络连接、解析XML等操作。该方法必须重载。\r\nonPostExecute(Result) 这个方法也运行于UI线程，在doInBackground(Params…)方法执行后调用，该方法用于处理后台任务执行后返回的结果。\r\n2) 子thread + handler\r\n"
        },
        {
            "ID": "854",
            "typeID": "11",
            "question": "Android中的五种存储方式及其应用场景?",
            "answer": "1)SharedPreferences \r\n存储路径:(data/data/packagename/shares_prefs), 轻量级存储,以键值对的形式存储在xml中,一般用来保存应用中的设置属性\r\n 2)文件存储 SD卡存储多媒体文件, 文件缓存\r\n 3) Sqlite数据库 存储路径:(data/data/packagename/databases), 一种嵌入式数据库,支持sql语言,存储大量结构性数据\r\n 4)ContentProvider 进程(应用程序)间数据共享,数据源可以是sqlite,也可以是xml,相关类: ContentResolver(内容解析器), ContentObserver(数据 观察者)\r\n 5) 网络存储 天气数据的xml,json格式等等,通过HttpUrlConnection,HttpClient,或者SOAP协议获取数据\r\n"
        },
        {
            "ID": "853",
            "typeID": "11",
            "question": "Android中asset文件夹和raw文件夹区别?",
            "answer": "res/raw和assets的相同点：\r\n两者目录下的文件在打包后会原封不动的保存在apk包中，不会被编译成二进制。\r\nres/raw和assets的不同点：\r\n1）res/raw中的文件会被映射到R.java文件中，访问的时候直接使用资源ID即 R.raw.filename；assets文件夹下的文件不会被映射到R.java中，访问的时候需要AssetManager类。\r\n2）res/raw不可以有目录结构，而assets则可以有目录结构，也就是assets目录下可以再建立文件夹\r\n3）读取文件资源举例：\r\n读取res/raw下的文件资源，通过以下方式获取输入流来进行写操作\r\nInputStream is = getResources().openRawResource(R.raw.filename); \r\n读取assets下的文件资源，通过以下方式获取输入流来进行写操作\r\nAssetManager am = null; \r\nam = getAssets(); \r\nInputStream is = am.open(\"filename\"); \r\n"
        },
        {
            "ID": "852",
            "typeID": "11",
            "question": "Activity在屏幕旋转时的生命周期?",
            "answer": "不设置Activity的android:configChanges时，切屏会重新调用各个生命周期，切横屏时会执行一次，切竖屏时会执行两次；设置Activity的android:configChanges=\"orientation\"时，切屏还是会重新调用各个生命周期，切横、竖屏时只会执行一次；设置Activity的android:configChanges=\"orientation|keyboardHidden\"时，切屏不会重新调用各个生命周期，只会执行onConfigurationChanged方法"
        },
        {
            "ID": "851",
            "typeID": "11",
            "question": "解释Activity的 onSaveInstanceState() 和 onRestoreInstanceState()？",
            "answer": "Activity的 onSaveInstanceState() 和 onRestoreInstanceState()并不是生命周期方法，它们不同于 onCreate()、onPause()等生命周期方法，它们并不一定会被触发。当应用遇到意外情况（如：内存不足、用户直接按Home键）由系统销毁一个Activity时，onSaveInstanceState() 会被调用。但是当用户主动去销毁一个Activity时，例如在应用中按返回键，onSaveInstanceState()就不会被调用。因为在这种情况下，用户的行为决定了不需要保存Activity的状态。通常onSaveInstanceState()只适合用于保存一些临时性的状态，而onPause()适合用于数据的持久化保存。\r\n另外，当屏幕的方向发生了改变， Activity会被摧毁并且被重新创建，如果你想在Activity被摧毁前缓存一些数据，并且在Activity被重新创建后恢复缓存的数据。可以重写Activity的 onSaveInstanceState() 和 onRestoreInstanceState()方法。\r\n"
        },
        {
            "ID": "850",
            "typeID": "11",
            "question": "Activity生命周期？",
            "answer": "共有七个周期函数： \r\nvoid onCreate(Bundle savedInstanceState) 第一次创建时调用\r\nvoid onStart() 被用户可见时调用\r\nvoid onRestart() 当Activity处于stop状态又被重新启动时调用\r\nvoid onResume() 当获得焦点即可与用户交互时调用\r\nvoid onPause() 当失去焦点时调用\r\nvoid onStop() 当不可见时调用\r\nvoid onDestroy() 当销毁时调用\r\n"
        },
        {
            "ID": "849",
            "typeID": "11",
            "question": "Android的四大组件是什么？它们的作用是什么?",
            "answer": "Android有四大组件：Activity、Service、Broadcast Receiver、Content Provider。 \r\nActivity :应用程序中，一个Activity通常就是一个单独的屏幕，它上面可以显示一些控件也可以监听并处理用户的事件做出响应。Activity之间通过Intent进行通信。\r\nService 服务:一个Service 是一段长生命周期的，没有用户界面的程序，可以用来开发如监控类程序。\r\nBroadcastReceive广播接收器:你的应用可以使用它对外部事件进行过滤只对感兴趣的外部事件(如当电话呼入时，或者数据网络可用时)进行接收并做出响应。广播接收器没有用户界面。然而，它们可以启动一个activity或serice 来响应它们收到的信息。\r\nContent Provider内容提供者 :主要用于多个应用间数据共享。这些数据可以存储在文件系统中或SQLite数据库。\r\n"
        },
        {
            "ID": "848",
            "typeID": "11",
            "question": "Android系统架构?",
            "answer": "1）应用程序层 java语言 应用程序开发\r\n2）应用程序框架层 java语言 OS定制 framework层开发\r\n3）系统运行库层 C C++ 实现 so库\r\n4）Linux内核层\r\n"
        },
        {
            "ID": "847",
            "typeID": "11",
            "question": "广播如何调用，有什么方式，各自的区别，实现广播的意图是什么，哪里用到？",
            "answer": "程序中发送广播通过sendBroadcastReceiver（）实现\r\n接收广播通过定义一个类继承BroadcastReceiver并重写onReceive（）方法实现\r\n注册广播有两种方式：\r\n第一种静态方式:在清单文件中通过<receive>标签声明\r\n第二种代码动态方式:\r\nIntentFilter filter = new IntentFilter(\"android.provider.Telephony.SMS_RECEIVED\");\r\nIncomingSMSReceiver receiver = new IncomgSMSReceiver();\r\nregisterReceiver(receiver.filter);\r\n 1)第一种不是常驻型广播，也就是说广播跟随activity的生命周期。注意: 在activity结束前，移除广播接收器。\r\n 2)第二种是常驻型，也就是说当应用程序关闭后，如果有信息广播来，程序也会被系统调用自动运行。\r\n"
        },
        {
            "ID": "846",
            "typeID": "11",
            "question": "常用设计模式及应用场景？",
            "answer": "常用设计模式: \r\n 单例模式: Calendar实例的获取\r\n 适配器模式: Adapter 为ListView GridView等添加数据\r\n工厂模式: Spring IOC 反转控制\r\n代理模式: Spring AOP 面向切面编程\r\n观察者模式: ContentObserver监听内容改变\r\n（懒汉式）程序执行过程中需要这个类的对象时再实例化该类的对象\r\n步骤\r\n1)定义静态私有对象\r\n2)构造方法私有化保证在类的外部无法实例化该类的对象\r\n3)定义对外开放的静态方法在调用方法是判断对象是否为空，为空再创建对象返回\r\n\t\tpublic class Singleton {\r\n private static Singleton singleton;\r\n // 构造方法私有化，保证在类的外部无法实例化该类的对象\r\n private Singleton() {\r\n }\r\n public static synchronized Singleton getSingletonInstance() {\r\n if (singleton == null) {\r\n singleton = new Singleton();\r\n }\r\n return singleton;\r\n }\r\n}\r\n（饿汉式）类加载的时候就实例化该类的对象\r\npublic class Singleton {\r\n private static Singleton singleton = new Singleton();\r\n // 构造方法私有化，保证在类的外部无法实例化该类的对象\r\n private Singleton() {\r\n }\r\n public static Singleton getSingletonInstance() {\r\n return singleton;\r\n }\r\n}\r\n"
        },
        {
            "ID": "845",
            "typeID": "11",
            "question": "开发中都用到了那些设计模式?用在什么场合？",
            "answer": "每个模式都描述了一个在我们的环境中不断出现的问题，然后描述了该问题的解决方案的核心。通过这种方式，你可以无数次地使用那些已有的解决方案，无需在重复相同的工作。主要用到了MVC的设计模式。用来开发JSP/Servlet或者J2EE的相关应用。简单工厂模式等。"
        },
        {
            "ID": "844",
            "typeID": "11",
            "question": "j2ee常用的设计模式？说明工厂模式",
            "answer": "Java中的23种设计模式：\r\nFactory（工厂模式），Builder（建造模式），FactoryMethod（工厂方法模式），\r\nPrototype（原始模型模式），Singleton（单例模式），Facade（门面模式），\r\nAdapter（适配器模式），Bridge（桥梁模式），Composite（合成模式），\r\nDecorator（装饰模式），Flyweight（享元模式），Proxy（代理模式），\r\nCommand（命令模式），Interpreter（解释器模式），Visitor（访问者模式），\r\nIterator（迭代子模式），Mediator（调停者模式），Memento（备忘录模式），\r\nObserver（观察者模式），State（状态模式），Strategy（策略模式），\r\nTemplateMethod（模板方法模式），ChainOfResponsibleity（责任链模式）\r\n工厂模式：工厂模式是一种经常被使用到的模式，根据工厂模式实现的类可以根据提供的数据生成一组类中某一个类的实例，通常这一组类有一个公共的抽象父类并且实现了相同的方法，但是这些方法针对不同的数据进行了不同的操作。首先需要定义一个基类，该类的子类通过不同的方法实现了基类中的方法。然后需要定义一个工厂类，工厂类可以根据条件生成不同的子类实例。当得到子类的实例后，开发人员可以调用基类中的方法而不必考虑到底返回的是哪一个子类的实例。\r\n"
        },
        {
            "ID": "843",
            "typeID": "11",
            "question": "J2EE是什么？请对以下在J2EE中常用的名词进行解释(或简单描述)",
            "answer": "2EE是Sun公司提出的多层(multi-diered),分布式(distributed),基于组件(component-base)的企业级应用模型(enterprieseapplicationmodel).在这样的一个应用系统中，可按照功能划分为不同的组件，这些组件又可在不同计算机上，并且处于相应的层次(tier)中。所属层次包括客户层(clietntier)组件,web层和组件,Business层和组件,企业信息系统(EIS)层。"
        },
        {
            "ID": "842",
            "typeID": "11",
            "question": "Final、finally、finanlize()的区别？",
            "answer": "final用于声明属性，方法和类，分别表示属性不可变，方法不可覆盖，类不可继承。\r\nfinally是异常处理语句结构的一部分，表示总是执行。\r\nfinalize是Object类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，可以覆盖此方法提供垃圾收集时的其他资源回收，例如关闭文件等。\r\n"
        },
        {
            "ID": "841",
            "typeID": "11",
            "question": "线程有几种状态,分别是哪些（调用run()和调用start()的区别）",
            "answer": "1)新建状态(New)：新创建了一个线程对象。\r\n　　2)就绪状态(Runnable)：线程对象创建后，其他线程调用了该对象的start()方法。该状态的线程位于可运行线程池中，变得可运行，等待获取CPU的使用权。\r\n　　3)运行状态(Running)：就绪状态的线程获取了CPU，执行run()方法。\r\n　　4)阻塞状态(Blocked)：阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。阻塞的情况分三种：\r\n①等待阻塞：运行的线程执行wait()方法，JVM会把该线程放入等待池中。\r\n②同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池中。\r\n③其他阻塞：运行的线程执行sleep()或join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。\r\n5)死亡状态(Dead)：线程执行完了或者因异常退出了run()方法，该线程结束生命周期。\r\n当调用start方法的时候，该线程就进入就绪状态。等待CPU进行调度执行，此时还没有真正执行线程。\r\n当调用run方法的时候，是已经被CP U进行调度，执行线程的主要任务。\r\n1.\t线程的实现方式\r\n答：线程的实现有两种方式，一是继承Thread类，二是实现Runnable接口\r\n2.\tsleep() 与 wait()的区别\r\n答：①这两个方法来自不同的类分别是，sleep来自Thread类，和wait来自Object\r\n\t类。\r\n\t②最主要是sleep方法没有释放锁，而wait方法释放了锁，使得其他线程可\r\n\t以使用同步控制块或者方法。sleep不出让系统资源；wait是进入线程等待池\r\n\t等待，出让系统资源，其他线程可以占用CPU。一般wait不会加时间限制， \r\n\t因为如果wait线程的运行资源不够，再出来也没用，要等待其他线程调用\r\n\tnotify/notifyAll唤醒等待池中的所有线程，才会进入就绪队列等待OS分配系\r\n\t统资源。sleep(milliseconds)可以用时间指定使它自动唤醒过来，如果时间不到\r\n\t只能调用interrupt()强行打断。\r\n3.wait，notify和notifyAll只能在同步控制方法或者同步控制块里面使用，而\r\nsleep可以在任何地方使用\r\n4. Sleep需要捕获异常,而wait不需要\r\n3.\t线程中wait，join，sleep，yield, notify，notifyall，synchronized，区别及联系\r\n答：1).sleep()方法\r\n在指定时间内让当前正在执行的线程暂停执行，但不会释放“锁标志”。不推荐使用。sleep()使当前线程进入阻塞状态，在指定时间内不会执行。\r\n2).wait()方法\r\n在其他线程调用对象的notify或notifyAll方法前，导致当前线程等待。线程会释放掉它所占有的“锁标志”，从而使别的线程有机会抢占该锁。\r\n唤醒当前对象锁的等待线程使用notify或notifyAll方法,waite() 和notify()必须在synchronized函数或synchronized　block中进行调用。3.yield方法\r\n暂停当前正在执行的线程对象。yield()只是使当前线程重新回到可执行状态，所以执行3)yield()的线程有可能在进入到可执行状态后马上又被执行。yield()只能使同优先级或更高优先级的线程有执行的机会。\r\n4).join方法\r\n等待该线程终止。等待调用join方法的线程结束，再继续执行。如：t.join();//主要用于等待t线程运行结束，若无此句，main则会执行完毕，导致结果不可预测。\r\n"
        },
        {
            "ID": "840",
            "typeID": "11",
            "question": "集合的实现类与区别？",
            "answer": "Collection接口，集合结构总的父接口，有两个子接口list和set\r\n List接口 元素有序可重复.\r\n 实现类有：ArrayList 数组实现轻量级，运行快，线程不安全。JDK1.2 查询快\r\n\t\t Vector 数组实现重量级，运行慢，线程安全。JDK1.0\r\n\t\t LinkedList链表实现 常用语堆栈与队列的实现 增删操作快\r\nSet 接口 元素无序不可重复\r\n实现类有：HashSet，底层用hashCode()算法实现，保证元素的无序唯一，自定义对象存进HashSet为了保证元素内容不重复需要覆盖hashCode()与equals()方法。\r\n SortedSet(不重要) 元素有序（Unicode升序）唯一\r\n TreeSet要求元素有序，自定义的对象需要实现Comparable接口的 compareTo（object o）方法\r\n Map(接口): 与Collection接口无关,有一个子接口SortedMap特点: 元素是key-value, key \r\n 唯一,无序; value可重复\r\n\t实现类: HashMap 轻量级 线程不安全的,允许key或value为null JDK1.2\r\n HashTable 重量级 线程安全的 不允许key或value为null JDK1.0\r\n \t Properties是HashTable的子类,主键和值都是字符串\r\n\tSortedMap:(不重要)\r\n\t特点: key唯一,有序(Unicode升序)\r\n\t实现类:TreeMap\r\n"
        },
        {
            "ID": "839",
            "typeID": "11",
            "question": "抽象类与接口的区别（abstract与interface的区别）",
            "answer": "abstract可以修饰抽象方法，而一个类只要有一个抽象方法，就必须用abstract定义该类，即抽象类。抽象类，被继承，实现它里面的方法，可以只有普通方法\r\n用interface修饰的类，里面的方法都是抽象方法（不能实例化），因此在定义接口的时候，可以直接不加那些修饰，系统会默认的添上去。接口里面的字段都是公有常量，即public static final修饰的字段。可以没有函数原型，里面可以是空的。\r\n"
        },
        {
            "ID": "838",
            "typeID": "11",
            "question": "实现一个字符串倒序？",
            "answer": "字符串“abcde”通过写一个函数不让调用第三方的字符串，实现一个字符串倒序，比如字符串“abcde” 变成“edcba”\r\n\r\n\r\nString src = \"ABCDEF \";\r\nString dst = new StringBuffer(src).reverse().toString();\r\n"
        },
        {
            "ID": "837",
            "typeID": "11",
            "question": "String 和StringBuffer的区别？",
            "answer": "STRING的长度是不可变的，STRINGBUFFER的长度是可变的。如果你对字符串中的内容经常进行操作，特别是内容要修改时，那么使用StringBuffer，如果最后需要String，那么使用StringBuffer（缓存）的toString()方法。 \r\nStringBuilder：节约内存，创建字符串；\r\n"
        },
        {
            "ID": "836",
            "typeID": "11",
            "question": "Overload和Override的区别？",
            "answer": "Overloaded的方法是否可以改变返回值的类型?\r\n方法的重写Overriding和重载Overloading是Java多态性的不同表现。重写Overriding是父类与子类之间多态性的一种表现，重载Overloading是一个类中多态性的一种表现。如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写 (Overriding)。子类的对象使用这个方法时，将调用子类中的定义，对它而言，父类中的定义如同被\"屏蔽\"了。如果在一个类中定义了多个同名的方法，它们或有不同的参数个数或有不同的参数类型，则称为方法的重载(Overloading)。Overloaded的方法是可以改变返回值的类型。\r\n"
        },
        {
            "ID": "835",
            "typeID": "11",
            "question": "进程和线程之间有什么不同？",
            "answer": "一个进程是一个独立(self contained)的运行环境，它可以被看作一个程序或者一个应用。而线程是在进程中执行的一个任务。Java运行环境是一个包含了不同的类和程序的单一进程。线程可以被称为轻量级进程。线程需要较少的资源来创建和驻留在进程中，并且可以共享进程中的资源。"
        },
        {
            "ID": "834",
            "typeID": "11",
            "question": "多线程编程的好处是什么？",
            "answer": "在多线程程序中，多个线程被并发的执行以提高程序的效率，CPU不会因为某个线程需要等待资源而进入空闲状态。多个线程共享堆内存(heap memory)，因此创建多个线程去执行一些任务会比创建多个进程更好。举个例子，Servlets比CGI更好，是因为Servlets支持多线程而CGI不支持。"
        },
        {
            "ID": "833",
            "typeID": "11",
            "question": "用户线程和守护线程有什么区别？",
            "answer": "当我们在Java程序中创建一个线程，它就被称为用户线程。一个守护线程是在后台执行并且不会阻止JVM终止的线程。当没有用户线程在运行的时候，JVM关闭程序并且退出。一个守护线程创建的子线程依然是守护线程。"
        },
        {
            "ID": "832",
            "typeID": "11",
            "question": "我们如何创建一个线程？",
            "answer": "有两种创建线程的方法：一是实现Runnable接口，然后将它传递给Thread的构造函数，创建一个Thread对象；二是直接继承Thread类。"
        },
        {
            "ID": "831",
            "typeID": "11",
            "question": "有哪些不同的线程生命周期？",
            "answer": "当我们在Java程序中新建一个线程时，它的状态是New。当我们调用线程的start()方法时，状态被改变为Runnable。线程调度器会为Runnable线程池中的线程分配CPU时间并且讲它们的状态改变为Running。其他的线程状态还有Waiting，Blocked 和Dead。"
        },
        {
            "ID": "830",
            "typeID": "11",
            "question": "可以直接调用Thread类的run()方法么？",
            "answer": "当然可以，但是如果我们调用了Thread的run()方法，它的行为就会和普通的方法一样，为了在新的线程中执行我们的代码，必须使用Thread.start()方法。"
        },
        {
            "ID": "829",
            "typeID": "11",
            "question": "如何让正在运行的线程暂停一段时间？",
            "answer": "我们可以使用Thread类的Sleep()方法让线程暂停一段时间。需要注意的是，这并不会让线程终止，一旦从休眠中唤醒线程，线程的状态将会被改变为Runnable，并且根据线程调度，它将得到执行。"
        },
        {
            "ID": "828",
            "typeID": "11",
            "question": "你对线程优先级的理解是什么？",
            "answer": "每一个线程都是有优先级的，一般来说，高优先级的线程在运行时会具有优先权，但这依赖于线程调度的实现，这个实现是和操作系统相关的(OS dependent)。我们可以定义线程的优先级，但是这并不能保证高优先级的线程会在低优先级的线程前执行。线程优先级是一个int变量(从1-10)，1代表最低优先级，10代表最高优先级。"
        },
        {
            "ID": "827",
            "typeID": "11",
            "question": "什么是线程调度器(Thread Scheduler)和时间分片(Time Slicing)？",
            "answer": "线程调度器是一个操作系统服务，它负责为Runnable状态的线程分配CPU时间。一旦我们创建一个线程并启动它，它的执行便依赖于线程调度器的实现。时间分片是指将可用的CPU时间分配给可用的Runnable线程的过程。分配CPU时间可以基于线程优先级或者线程等待的时间。线程调度并不受到Java虚拟机控制，所以由应用程序来控制它是更好的选择（也就是说不要让你的程序依赖于线程的优先级）。"
        },
        {
            "ID": "826",
            "typeID": "11",
            "question": "在多线程中，什么是上下文切换(context-switching)？",
            "answer": "上下文切换是存储和恢复CPU状态的过程，它使得线程执行能够从中断点恢复执行。上下文切换是多任务操作系统和多线程环境的基本特征。"
        },
        {
            "ID": "825",
            "typeID": "11",
            "question": "你如何确保main()方法所在的线程是Java程序最后结束的线程？",
            "answer": "我们可以使用Thread类的joint()方法来确保所有程序创建的线程在main()方法退出前结束。"
        },
        {
            "ID": "824",
            "typeID": "11",
            "question": "线程之间是如何通信的？",
            "answer": "当线程间是可以共享资源时，线程间通信是协调它们的重要的手段。Object类中wait()\notify()\notifyAll()方法可以用于线程间通信关于资源的锁的状态。"
        },
        {
            "ID": "823",
            "typeID": "11",
            "question": "为什么线程通信的方法wait(), notify()和notifyAll()被定义在Object类里？",
            "answer": "Java的每个对象中都有一个锁(monitor，也可以成为监视器) 并且wait()，notify()等方法用于等待对象的锁或者通知其他线程对象的监视器可用。在Java的线程中并没有可供任何对象使用的锁和同步器。这就是为什么这些方法是Object类的一部分，这样Java的每一个类都有用于线程间通信的基本方法。"
        },
        {
            "ID": "822",
            "typeID": "11",
            "question": "为什么wait(), notify()和notifyAll()必须在同步方法或者同步块中被调用？",
            "answer": "当一个线程需要调用对象的wait()方法的时候，这个线程必须拥有该对象的锁，接着它就会释放这个对象锁并进入等待状态直到其他线程调用这个对象上的notify()方法。同样的，当一个线程需要调用对象的notify()方法时，它会释放这个对象的锁，以便其他在等待的线程就可以得到这个对象锁。由于所有的这些方法都需要线程持有对象的锁，这样就只能通过同步来实现，所以他们只能在同步方法或者同步块中被调用。"
        },
        {
            "ID": "821",
            "typeID": "11",
            "question": "为什么Thread类的sleep()和yield()方法是静态的？",
            "answer": "Thread类的sleep()和yield()方法将在当前正在执行的线程上运行。所以在其他处于等待状态的线程上调用这些方法是没有意义的。这就是为什么这些方法是静态的。它们可以在当前正在执行的线程中工作，并避免程序员错误的认为可以在其他非运行线程调用这些方法。"
        },
        {
            "ID": "820",
            "typeID": "11",
            "question": "如何确保线程安全？",
            "answer": "在Java中可以有很多方法来保证线程安全——同步，使用原子类(atomic concurrent classes)，实现并发锁，使用volatile关键字，使用不变类和线程安全类。"
        },
        {
            "ID": "819",
            "typeID": "11",
            "question": "volatile关键字在Java中有什么作用？",
            "answer": "当我们使用volatile关键字去修饰变量的时候，所以线程都会直接读取该变量并且不缓存它。这就确保了线程读取到的变量是同内存中是一致的。"
        },
        {
            "ID": "818",
            "typeID": "11",
            "question": "同步方法和同步块，哪个是更好的选择？",
            "answer": "同步块是更好的选择，因为它不会锁住整个对象（当然你也可以让它锁住整个对象）。同步方法会锁住整个对象，哪怕这个类中有多个不相关联的同步块，这通常会导致他们停止执行并需要等待获得这个对象上的锁。"
        },
        {
            "ID": "817",
            "typeID": "11",
            "question": "如何创建守护线程？",
            "answer": "使用Thread类的setDaemon(true)方法可以将线程设置为守护线程，需要注意的是，需要在调用start()方法前调用这个方法，否则会抛出IllegalThreadStateException异常。"
        },
        {
            "ID": "816",
            "typeID": "11",
            "question": "什么是ThreadLocal?",
            "answer": "ThreadLocal用于创建线程的本地变量，我们知道一个对象的所有线程会共享它的全局变量，所以这些变量不是线程安全的，我们可以使用同步技术。但是当我们不想使用同步的时候，我们可以选择ThreadLocal变量。\r\n每个线程都会拥有他们自己的Thread变量，它们可以使用get()set()方法去获取他们的默认值或者在线程内部改变他们的值。ThreadLocal实例通常是希望它们同线程状态关联起来是private static属性。"
        },
        {
            "ID": "815",
            "typeID": "11",
            "question": " 什么是Thread Group？为什么建议使用它？",
            "answer": "ThreadGroup是一个类，它的目的是提供关于线程组的信息。\r\nThreadGroup API比较薄弱，它并没有比Thread提供了更多的功能。它有两个主要的功能：一是获取线程组中处于活跃状态线程的列表；二是设置为线程设置未捕获异常处理器(ncaught exception handler)。但在Java 1.5中Thread类也添加了setUncaughtExceptionHandler(UncaughtExceptionHandler eh) 方法，所以ThreadGroup是已经过时的，不建议继续使用。\r\n\r\nt1.setUncaughtExceptionHandler(new UncaughtExceptionHandler(){\r\n \r\n@Override\r\npublic void uncaughtException(Thread t, Throwable e) {\r\nSystem.out.println(\"exception occured:\"+e.getMessage());\r\n}\r\n \r\n});"
        },
        {
            "ID": "814",
            "typeID": "11",
            "question": "什么是Java线程转储(Thread Dump)，如何得到它？",
            "answer": "线程转储是一个JVM活动线程的列表，它对于分析系统瓶颈和死锁非常有用。有很多方法可以获取线程转储——使用Profiler，Kill -3命令，jstack工具等等。我更喜欢jstack工具，因为它容易使用并且是JDK自带的。由于它是一个基于终端的工具，所以我们可以编写一些脚本去定时的产生线程转储以待分析。"
        },
        {
            "ID": "813",
            "typeID": "11",
            "question": "什么是死锁(Deadlock)？如何分析和避免死锁？",
            "answer": "死锁是指两个以上的线程永远阻塞的情况，这种情况产生至少需要两个以上的线程和两个以上的资源。\r\n分析死锁，我们需要查看Java应用程序的线程转储。我们需要找出那些状态为BLOCKED的线程和他们等待的资源。每个资源都有一个唯一的id，用这个id我们可以找出哪些线程已经拥有了它的对象锁。"
        },
        {
            "ID": "812",
            "typeID": "11",
            "question": "什么是Java Timer类？如何创建一个有特定时间间隔的任务？",
            "answer": "java.util.Timer是一个工具类，可以用于安排一个线程在未来的某个特定时间执行。Timer类可以用安排一次性任务或者周期任务。\r\njava.util.TimerTask是一个实现了Runnable接口的抽象类，我们需要去继承这个类来创建我们自己的定时任务并使用Timer去安排它的执行。"
        },
        {
            "ID": "811",
            "typeID": "11",
            "question": "什么是线程池？如何创建一个Java线程池？",
            "answer": "一个线程池管理了一组工作线程，同时它还包括了一个用于放置等待执行的任务的队列。\r\njava.util.concurrent.Executors提供了一个 java.util.concurrent.Executor接口的实现用于创建线程池。线程池例子展现了如何创建和使用线程池，或者阅读ScheduledThreadPoolExecutor例子，了解如何创建一个周期任务。"
        },
        {
            "ID": "810",
            "typeID": "11",
            "question": "什么是原子操作？在Java Concurrency API中有哪些原子类(atomic classes)？",
            "answer": "原子操作是指一个不受其他操作影响的操作任务单元。原子操作是在多线程环境下避免数据不一致必须的手段。\r\nint++并不是一个原子操作，所以当一个线程读取它的值并加1时，另外一个线程有可能会读到之前的值，这就会引发错误。\r\n为了解决这个问题，必须保证增加操作是原子的，在JDK1.5之前我们可以使用同步技术来做到这一点。到JDK1.5，java.util.concurrent.atomic包提供了int和long类型的装类，它们可以自动的保证对于他们的操作是原子的并且不需要使用同步。"
        },
        {
            "ID": "809",
            "typeID": "11",
            "question": "Java Concurrency API中的Lock接口(Lock interface)是什么？对比同步它有什么优势？",
            "answer": "Lock接口比同步方法和同步块提供了更具扩展性的锁操作。他们允许更灵活的结构，可以具有完全不同的性质，并且可以支持多个相关类的条件对象。\r\n它的优势有：\r\n可以使锁更公平\r\n可以使线程在等待锁的时候响应中断\r\n可以让线程尝试获取锁，并在无法获取锁的时候立即返回或者等待一段时间\r\n可以在不同的范围，以不同的顺序获取和释放锁"
        },
        {
            "ID": "808",
            "typeID": "11",
            "question": "什么是Executors框架？",
            "answer": "Executor框架同java.util.concurrent.Executor 接口在Java 5中被引入。Executor框架是一个根据一组执行策略调用，调度，执行和控制的异步任务的框架。\r\n无限制的创建线程会引起应用程序内存溢出。所以创建一个线程池是个更好的的解决方案，因为可以限制线程的数量并且可以回收再利用这些线程。"
        },
        {
            "ID": "807",
            "typeID": "11",
            "question": "什么是阻塞队列？如何使用阻塞队列来实现生产者-消费者模型？",
            "answer": "java.util.concurrent.BlockingQueue的特性是：当队列是空的时，从队列中获取或删除元素的操作将会被阻塞，或者当队列是满时，往队列里添加元素的操作会被阻塞。\r\n阻塞队列不接受空值，当你尝试向队列中添加空值的时候，它会抛出NullPointerException。\r\n阻塞队列的实现都是线程安全的，所有的查询方法都是原子的并且使用了内部锁或者其他形式的并发控制。\r\nBlockingQueue 接口是java collections框架的一部分，它主要用于实现生产者-消费者问题。"
        },
        {
            "ID": "806",
            "typeID": "11",
            "question": "什么是Callable和Future?",
            "answer": "ava 5在concurrency包中引入了java.util.concurrent.Callable 接口，它和Runnable接口很相似，但它可以返回一个对象或者抛出一个异常。\r\nCallable接口使用泛型去定义它的返回类型。Executors类提供了一些有用的方法去在线程池中执行Callable内的任务。由于Callable任务是并行的，我们必须等待它返回的结果。java.util.concurrent.Future对象为我们解决了这个问题。在线程池提交Callable任务后返回了一个Future对象，使用它我们可以知道Callable任务的状态和得到Callable返回的执行结果。Future提供了get()方法让我们可以等待Callable结束并获取它的执行结果。"
        },
        {
            "ID": "805",
            "typeID": "11",
            "question": "什么是FutureTask?",
            "answer": "FutureTask是Future的一个基础实现，我们可以将它同Executors使用处理异步任务。通常我们不需要使用FutureTask类，单当我们打算重写Future接口的一些方法并保持原来基础的实现是，它就变得非常有用。我们可以仅仅继承于它并重写我们需要的方法。"
        },
        {
            "ID": "804",
            "typeID": "11",
            "question": "什么是并发容器的实现？",
            "answer": "Java集合类都是快速失败的，这就意味着当集合被改变且一个线程在使用迭代器遍历集合的时候，迭代器的next()方法将抛出ConcurrentModificationException异常。\r\n并发容器支持并发的遍历和并发的更新。\r\n主要的类有ConcurrentHashMap, CopyOnWriteArrayList 和CopyOnWriteArraySet，阅读这篇文章了解如何避免ConcurrentModificationException。"
        },
        {
            "ID": "803",
            "typeID": "11",
            "question": "Executors类是什么？",
            "answer": "Executors为Executor，ExecutorService，ScheduledExecutorService，ThreadFactory和Callable类提供了一些工具方法。\r\nExecutors可以用于方便的创建线程池。"
        },
        {
            "ID": "710",
            "typeID": "11",
            "question": "java之HashMap、LinkedHashMap和TreeMap的区别?",
            "answer": "1.HashMap的内部结构是一个数组，线性顺序存储，二次结构使用线性的单链表。使用key的hashCode做二次hash之后，再截取小于数组长度的值为索引值。key可以为null，存在索引为0的位置上。由于使用了数组，所以有一个负载因子loadFactor的概念（临界阈值threshold）和resize。resize比较耗时，冲突时链式遍历查找也比较耗时，所以选定一个合适的初始容易比较重要。存取性能都较高。迭代遍历时一维使用数组，二维使用链表。\r\n\r\n\r\n2.LinkedHashMap是HashMap的子类。内部结构是一个数组，线性顺序存储，二次结构使用线性的单链表，但同时内部维护了一个双向循环链表。access-order=false默认为使用新增存储顺序，access-order=true则指定使用读取和访问顺序。removeEldestEntry=false（当指定为true时，就是实现LRU算法的缓存容器，当然要指定淘汰时的使用频率和容量上限，其实是一个最近最少使用-->最近使用access-order=true/最新存储access-order=false）。存取性能较HashMap差－些，但相差不大。header.after为尾方向，header.before为首方向。迭代遍历时entrySet().iterator()跟HashMap一样(有点困惑，为什么不按线性顺序进行迭代，只能重写entrySet(),keySet()和values()方法)。适用于有缓存设计需求的情况（需继承）。\r\n\r\n\r\n3.TreeMap的内部结构是一棵红黑树（又叫排序数，是二叉树的一种），使用链式存储，可以指定比较器Comparator，key需实现Comparable接口。key不能为null。存结点性能稍差，因为需要调整树结构；取结点用的是链表遍历，但是属于有序比较，性能中等。迭代遍历时用的树的中序遍历，是一个有序序列。适用于有排序需求的情况。"
        },
        {
            "ID": "669",
            "typeID": "11",
            "question": "编程题: 写一个Singleton出来？",
            "answer": " Singleton模式主要作用是保证在Java应用程序中，一个类Class只有一个实例存在。 \r\n一般Singleton模式通常有几种种形式: \r\n第一种形式: 定义一个类，它的构造函数为private的，它有一个static的private的该类变量，在类初始化时实例话，通过一个public的getInstance方法获取对它的引用,继而调用其中的方法。\r\n\r\npublic class Singleton { \r\nprivate Singleton(){} \r\n//在自己内部定义自己一个实例，是不是很奇怪？ \r\n//注意这是private 只供内部调用 \r\nprivate static Singleton instance = new Singleton(); \r\n//这里提供了一个供外部访问本class的静态方法，可以直接访问 \r\npublic static Singleton getInstance() { \r\nreturn instance; \r\n}  \r\n}  \r\n\r\n\r\n第二种形式:\r\n\r\npublic class Singleton {  \r\nprivate static Singleton instance = null; \r\npublic static synchronized Singleton getInstance() { \r\n//这个方法比上面有所改进，不用每次都进行生成对象，只是第一次 \r\n//使用时生成实例，提高了效率！ \r\nif (instance==null) \r\ninstance＝new Singleton(); \r\nreturn instance; }  \r\n}  \r\n其他形式: \r\n定义一个类，它的构造函数为private的，所有方法为static的。 \r\n一般认为第一种形式要更加安全些。"
        },
        {
            "ID": "668",
            "typeID": "11",
            "question": "swtich是否能作用在byte上，是否能作用在long上，是否能作用在String上? \r\n",
            "answer": "switch（expr1）中，expr1是一个整数表达式。因此传递给 switch 和 case 语句的参数应该是 int、 short、 char 或者 byte。long,string 都不能作用于swtich。"
        },
        {
            "ID": "667",
            "typeID": "11",
            "question": "编程题: 用最有效率的方法算出2乘以8等於几? ",
            "answer": "小编注：C背景的程序员特别喜欢问这种问题，你先猜猜——=-\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n2 << 3"
        },
        {
            "ID": "666",
            "typeID": "11",
            "question": "try {}里有一个return语句，那么紧跟在这个try后的finally {}里的code会不会被执行，什么时候被执行，在return前还是后? ",
            "answer": "会执行，在return前执行。"
        },
        {
            "ID": "665",
            "typeID": "11",
            "question": "当一个线程进入一个对象的一个synchronized方法后，其它线程是否可进入此对象的其它方法? ",
            "answer": "不能，一个对象的一个synchronized方法只能由一个线程访问。"
        },
        {
            "ID": "664",
            "typeID": "11",
            "question": "是否可以继承String类? ",
            "answer": "String类是final类故不可以继承。"
        },
        {
            "ID": "663",
            "typeID": "11",
            "question": "构造器Constructor是否可被override? ",
            "answer": "构造器Constructor不能被继承，因此不能重写Overriding，但可以被重载Overloading。"
        },
        {
            "ID": "662",
            "typeID": "11",
            "question": "启动一个线程是用run()还是start()? ",
            "answer": "启动一个线程是调用start()方法，使线程所代表的虚拟处理机处于可运行状态，这意味着它可以由JVM调度并执行。这并不意味着线程就会立即运行。run()方法可以产生必须退出的标志来停止一个线程。"
        },
        {
            "ID": "661",
            "typeID": "11",
            "question": "接口是否可继承接口? 抽象类是否可实现(implements)接口? 抽象类是否可继承实体类(concrete class)? ",
            "answer": "接口可以继承接口。\r\n抽象类可以实现(implements)接口，抽象类是否可继承实体类，但前提是实体类必须有明确的构造函数。"
        },
        {
            "ID": "660",
            "typeID": "11",
            "question": "abstract的method是否可同时是static,是否可同时是native，是否可同时是synchronized? ",
            "answer": "都不能"
        },
        {
            "ID": "659",
            "typeID": "11",
            "question": "abstract class和interface有什么区别? ",
            "answer": "声明方法的存在而不去实现它的类被叫做抽象类（abstract class），它用于要创建一个体现某些基本行为的类，并为该类声明方法，但不能在该类中实现该类的情况。不能创建abstract 类的实例。然而可以创建一个变量，其类型是一个抽象类，并让它指向具体子类的一个实例。不能有抽象构造函数或抽象静态方法。Abstract 类的子类为它们父类中的所有抽象方法提供实现，否则它们也是抽象类为。取而代之，在子类中实现该方法。知道其行为的其它类可以在类中实现这些方法。 \r\n接口（interface）是抽象类的变体。在接口中，所有方法都是抽象的。多继承性可通过实现这样的接口而获得。接口中的所有方法都是抽象的，没有一个 有程序体。接口只可以定义static final成员变量。接口的实现与子类相似，除了该实现类不能从接口定义中继承行为。当类实现特殊接口时，它定义（即将程序体给予）所有这种接口的方法。 然后，它可以在实现了该接口的类的任何对象上调用接口的方法。由于有抽象类，它允许使用接口名作为引用变量的类型。通常的动态联编将生效。引用可以转换到 接口类型或从接口类型转换，instanceof 运算符可以用来决定某对象的类是否实现了接口。"
        },
        {
            "ID": "658",
            "typeID": "11",
            "question": "List, Set, Map是否继承自Collection接口? ",
            "answer": "List，Set是 \r\nMap不是"
        },
        {
            "ID": "657",
            "typeID": "11",
            "question": "给我一个你最常见到的runtime exception?",
            "answer": "参考如下： \r\nArithmeticException,  \r\nArrayStoreException,  \r\nBufferOverflowException,  \r\nBufferUnderflowException,  \r\nCannotRedoException,  \r\nCannotUndoException,  \r\nClassCastException,  \r\nCMMException,  \r\nConcurrentModificationException,  \r\nDOMException,  \r\nEmptyStackException,  \r\nIllegalArgumentException,  \r\nIllegalMonitorStateException,  \r\nIllegalPathStateException,  \r\nIllegalStateException,  \r\nImagingOpException,  \r\nIndexOutOfBoundsException,  \r\nMissingResourceException,  \r\nNegativeArraySizeException,  \r\nNoSuchElementException,  \r\nNullPointerException,  \r\nProfileDataException,  \r\nProviderException,  \r\nRasterFormatException,  \r\nSecurityException,  \r\nSystemException,  \r\nUndeclaredThrowableException,  \r\nUnmodifiableSetException,  \r\nUnsupportedOperationException"
        },
        {
            "ID": "656",
            "typeID": "11",
            "question": "Set里的元素是不能重复的，那么用什么方法来区分重复与否呢? 是用==还是equals()? 它们有何区别? ",
            "answer": "Set里的元素是不能重复的，那么用iterator()方法来区分重复与否。equals()是判读两个Set是否相等。 \r\nequals()和==方法决定引用值是否指向同一对象equals()在类中被覆盖，为的是当两个分离的对象的内容和类型相配的话，返回真值。"
        },
        {
            "ID": "655",
            "typeID": "11",
            "question": "Overload和Override的区别。Overloaded的方法是否可以改变返回值的类型? ",
            "answer": "方法的重写Overriding和重载Overloading是Java多态性的不同表现。重写Overriding是父类与子类之间多态性的一种表现， 重载Overloading是一个类中多态性的一种表现。如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写 (Overriding)。子类的对象使用这个方法时，将调用子类中的定义，对它而言，父类中的定义如同被“屏蔽”了。如果在一个类中定义了多个同名的方 法，它们或有不同的参数个数或有不同的参数类型，则称为方法的重载(Overloading)。Overloaded的方法是可以改变返回值的类型。"
        },
        {
            "ID": "654",
            "typeID": "11",
            "question": "Java有没有goto?  ",
            "answer": "没有 很十三的问题\r\nPS:如果哪个面试的问到这个问题，我劝你还是别进这家公司"
        },
        {
            "ID": "653",
            "typeID": "11",
            "question": "sleep() 和 wait() 有什么区别?   ",
            "answer": "sleep是线程类（Thread）的方法，导致此线程暂停执行指定时间，给执行机会给其他线程，但是监控状态依然保持，到时后会自动恢复。调用 sleep不会释放对象锁。wait是Object类的方法，对此对象调用wait方法导致本线程放弃对象锁，进入等待此对象的等待锁定池，只有针对此对 象发出notify方法（或notifyAll）后本线程才进入对象锁定池准备获得对象锁进入运行状态。"
        },
        {
            "ID": "652",
            "typeID": "11",
            "question": "short s1 = 1; s1 = s1 + 1;有什么错?   short s1 = 1; s1 += 1;有什么错?",
            "answer": "short s1 = 1; s1 = s1 + 1; （s1+1运算结果是int型，需要强制转换类型）short s1 = 1; s1 += 1;"
        },
        {
            "ID": "651",
            "typeID": "11",
            "question": "Math.round(11.5)等於多少? Math.round(-11.5)等於多少?  ",
            "answer": "Math.round(11.5)==12Math.round(-11.5)==-11round方法返回与参数最接近的长整数，参数加1/2后求其floor."
        },
        {
            "ID": "650",
            "typeID": "11",
            "question": "String s = new String(\"xyz\");创建了几个String Object? ",
            "answer": "两个"
        },
        {
            "ID": "649",
            "typeID": "11",
            "question": "GC是什么? 为什么要有GC?  ",
            "answer": "GC是垃圾收集的意思（Gabage Collection）,内存处理是编程人员容易出现问题的地方，忘记或者错误的内存回收会导致程序或系统的不稳定甚至崩溃， Java 提供的GC功能可以 自动监测对象是否超过作用域从而达到自动回收内存的目的， Java 语言没有提供释放已分配内存的显示操作方法。"
        },
        {
            "ID": "648",
            "typeID": "11",
            "question": "什么时候用assert？",
            "answer": "新增关键字（语法），用于测试boolean表达式状态，可用于调试程序。使用方法 assert ，表示如果表达式为真（true）,则下面的语句执行，否则抛出AssertionError。另外的使用方式assert < boolean表达式>:，表示如果表达式为真，后面的表达式忽略，否则后面表达式的值用于AssertionError的构建参数。注意编译时要增加-source ，否则报错。运行时要增加 –ea参数，否则assert行被忽略"
        },
        {
            "ID": "647",
            "typeID": "11",
            "question": "Collection 和 Collections的区别 ？",
            "answer": "Collection是集合类的上级接口，继承与他的接口主要有Set 和List.Collections是针对集合类的一个帮助类，他提供一系列静态方法实现对各种集合的搜索、排序、线程安全化等操作。"
        },
        {
            "ID": "646",
            "typeID": "11",
            "question": "HashMap和Hashtable的区别？",
            "answer": "HashMap是Hashtable的轻量级实现（非线程 安全 的实现），他们都完成了Map接口，主要区别在于HashMap允许空（null）键值（key）,由于非线程 安全 ，效率上可能高于Hashtable."
        },
        {
            "ID": "645",
            "typeID": "11",
            "question": "&和&&的区别",
            "answer": "&是位运算符，表示按位与运算，&&是逻辑运算符，表示逻辑与（and）."
        },
        {
            "ID": "644",
            "typeID": "11",
            "question": "Static Nested Class 和 Inner Class的不同？",
            "answer": "Static Nested Class是被声明为静态（static）的内部类，它可以不依赖于外部类实例被实例化。而通常的内部类需要在外部类实例化后才能实例化。"
        },
        {
            "ID": "643",
            "typeID": "11",
            "question": "Anonymous Inner Class (匿名内部类) 是否可以extends(继承)其它类，是否可以implements(实现)interface(接口)? ",
            "answer": "可以继承其他类或完成其他接口，在swing编程中常用此方式。"
        },
        {
            "ID": "642",
            "typeID": "11",
            "question": "谈谈final, finally, finalize的区别？",
            "answer": "final 用于声明属性，方法和类，分别表示属性不可变，方法不可覆盖，类不可继承。finally是异常处理语句结构的一部分，表示总是执行。finalize是 Object类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，可以覆盖此方法提供垃圾收集时的其他资源回收，例如关闭文件等。"
        },
        {
            "ID": "641",
            "typeID": "11",
            "question": "heap和stack有什么区别 ？",
            "answer": "栈是一种线形集合，其添加和删除元素的操作应在同一段完成。栈按照后进先出的方式进行处理。  \r\n堆是栈的一个组成元素  "
        },
        {
            "ID": "640",
            "typeID": "11",
            "question": "在java中一个类被声明为final类型，表示了什么意思？",
            "answer": "表示该类不能被继承，是顶级类。"
        },
        {
            "ID": "639",
            "typeID": "11",
            "question": "Error与Exception有什么区别？",
            "answer": "Error表示系统级的错误和程序不必处理的异常，  \r\nException表示需要捕捉或者需要程序进行处理的异常。"
        },
        {
            "ID": "638",
            "typeID": "11",
            "question": "多线程有几种实现方法?同步有几种实现方法?",
            "answer": "多线程有两种实现方法，分别是继承Thread类与实现Runnable接口\r\n\r\n同步的实现方面有两种，分别是synchronized,wait与notify\r\n\r\nwait():使一个线程处于等待状态，并且释放所持有的对象的lock。\r\n\r\nsleep():使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要捕捉InterruptedException异常。\r\n\r\nnotify():唤醒一个处于等待状态的线程，注意的是在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程，而且不是按优先级。\r\n\r\nAllnotity():唤醒所有处入等待状态的线程，注意并不是给所有唤醒线程一个对象的锁，而是让它们竞争。"
        },
        {
            "ID": "637",
            "typeID": "11",
            "question": "同步和异步有何异同，在什么情况下分别使用他们？举例说明。",
            "answer": "如果数据将在线程间共享。例如正在写的数据以后可能被另一个线程读到，或者正在读的数据可能已经被另一个线程写过了，那么这些数据就是共享数据，必须进行同步存取。\r\n\r\n当应用程序在对象上调用了一个需要花费很长时间来执行的方法，并且不希望让程序等待方法的返回时，就应该使用异步编程，在很多情况下采用异步途径往往更有效率。"
        },
        {
            "ID": "636",
            "typeID": "11",
            "question": "sleep()和 wait()有什么区别?",
            "answer": "（网上的答案：sleep是线程类（Thread）的方法，导致此线程暂停执行指定时间，给执行机会给其他线程，但是监控状态依然保持，到时后会自动恢复。调用sleep不会释放对象锁。 wait是Object类的方法，对此对象调用wait方法导致本线程放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象发出notify方法（或notifyAll）后本线程才进入对象锁定池准备获得对象锁进入运行状态。）\r\n\r\n\r\n\r\nsleep就是正在执行的线程主动让出cpu，cpu去执行其他线程，在sleep指定的时间过后，cpu才会回到这个线程上继续往下执行，如果当前线程进入了同步锁，sleep方法并不会释放锁，即使当前线程使用sleep方法让出了cpu，但其他被同步锁挡住了的线程也无法得到执行。wait是指在一个已经进入了同步锁的线程内，让自己暂时让出同步锁，以便其他正在等待此锁的线程可以得到同步锁并运行，只有其他线程调用了notify方法（notify并不释放锁，只是告诉调用过wait方法的线程可以去参与获得锁的竞争了，但不是马上得到锁，因为锁还在别人手里，别人还没释放。如果notify方法后面的代码还有很多，需要这些代码执行完后才会释放锁，可以在notfiy方法后增加一个等待和一些代码，看看效果），调用wait方法的线程就会解除wait状态和程序可以再次得到锁后继续向下运行。对于wait的讲解一定要配合例子代码来说明，才显得自己真明白。\r\n\r\npackage com.huawei.interview;\r\n\r\n\r\n\r\npublicclass MultiThread {\r\n\r\n\r\n\r\n/**\r\n\r\n * @paramargs\r\n\r\n */\r\n\r\npublic static voidmain(String[] args) {\r\n\r\n// TODO Auto-generated method stub\r\n\r\nnew Thread(newThread1()).start();\r\n\r\ntry {\r\n\r\nThread.sleep(10);\r\n\r\n} catch (InterruptedException e) {\r\n\r\n// TODO Auto-generated catchblock\r\n\r\ne.printStackTrace();\r\n\r\n}\r\n\r\nnew Thread(newThread2()).start(); \r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\nprivate static classThread1implements Runnable\r\n\r\n{\r\n\r\n\r\n\r\n@Override\r\n\r\npublic void run() {\r\n\r\n// TODO Auto-generated methodstub\r\n\r\n//由于这里的Thread1和下面的Thread2内部run方法要用同一对象作为监视器，我们这里不能用this，因为在Thread2里面的this和这个Thread1的this不是同一个对象。我们用MultiThread.class这个字节码对象，当前虚拟机里引用这个变量时，指向的都是同一个对象。\r\n\r\nsynchronized (MultiThread.class){\r\n\r\n\r\n\r\nSystem.out.println(\"enterthread1...\");\r\n\r\n\r\n\r\nSystem.out.println(\"thread1is waiting\");\r\n\r\ntry {\r\n\r\n//释放锁有两种方式，第一种方式是程序自然离开监视器的范围，也就是离开了synchronized关键字管辖的代码范围，另一种方式就是在synchronized关键字管辖的代码内部调用监视器对象的wait方法。这里，使用wait方法释放锁。\r\n\r\nMultiThread.class.wait();\r\n\r\n} catch(InterruptedException e) {\r\n\r\n// TODO Auto-generatedcatch block\r\n\r\ne.printStackTrace();\r\n\r\n}\r\n\r\n\r\n\r\nSystem.out.println(\"thread1is going on...\");\r\n\r\nSystem.out.println(\"thread1is being over!\"); \r\n\r\n}\r\n\r\n}\r\n\r\n\r\n\r\n}\r\n\r\n\r\n\r\nprivate static classThread2implements Runnable\r\n\r\n{\r\n\r\n\r\n\r\n@Override\r\n\r\npublic void run() {\r\n\r\n// TODO Auto-generated methodstub\r\n\r\nsynchronized (MultiThread.class){\r\n\r\n\r\n\r\nSystem.out.println(\"enterthread2...\");\r\n\r\n\r\n\r\nSystem.out.println(\"thread2notify other thread can release wait status..\");\r\n\r\n//由于notify方法并不释放锁，即使thread2调用下面的sleep方法休息了10毫秒，但thread1仍然不会执行，因为thread2没有释放锁，所以Thread1无法得不到锁。\r\n\r\n\r\n\r\nMultiThread.class.notify();\r\n\r\n\r\n\r\nSystem.out.println(\"thread2is sleeping ten millisecond...\");\r\n\r\ntry {\r\n\r\nThread.sleep(10);\r\n\r\n} catch (InterruptedExceptione) {\r\n\r\n// TODO Auto-generatedcatch block\r\n\r\ne.printStackTrace();\r\n\r\n}\r\n\r\n\r\n\r\nSystem.out.println(\"thread2is going on...\");\r\n\r\nSystem.out.println(\"thread2is being over!\");\r\n\r\n\r\n\r\n}\r\n\r\n}\r\n\r\n\r\n\r\n} \r\n\r\n\r\n\r\n}\r\n"
        },
        {
            "ID": "635",
            "typeID": "11",
            "question": "java中有几种方法可以实现一个线程？用什么关键字修饰同步方法? stop()和suspend()方法为何不推荐使用？",
            "answer": "java5以前，有如下两种：\r\n\r\n第一种：\r\n\r\nnew Thread(){}.start();这表示调用Thread子类对象的run方法，new Thread(){}表示一个Thread的匿名子类的实例对象，子类加上run方法后的代码如下：\r\n\r\nnew Thread(){\r\n\r\npublic void run(){\r\n\r\n}\r\n\r\n}.start();\r\n\r\n\r\n\r\n第二种：\r\n\r\nnew Thread(new Runnable(){}).start();这表示调用Thread对象接受的Runnable对象的run方法，new Runnable(){}表示一个Runnable的匿名子类的实例对象,runnable的子类加上run方法后的代码如下：\r\n\r\nnew Thread(new Runnable(){\r\n\r\npublic voidrun(){\r\n\r\n} \r\n\r\n}\r\n\r\n).start();\r\n\r\n\r\n\r\n\r\n\r\n从java5开始，还有如下一些线程池创建多线程的方式：\r\n\r\nExecutorService pool = Executors.newFixedThreadPool(3)\r\n\r\nfor(int i=0;i<10;i++)\r\n\r\n{\r\n\r\npool.execute(newRunable(){public void run(){}});\r\n\r\n}\r\n\r\nExecutors.newCachedThreadPool().execute(new Runable(){publicvoid run(){}});\r\n\r\nExecutors.newSingleThreadExecutor().execute(new Runable(){publicvoid run(){}});\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n有两种实现方法，分别使用new Thread()和new Thread(runnable)形式，第一种直接调用thread的run方法，所以，我们往往使用Thread子类，即new SubThread()。第二种调用runnable的run方法。\r\n\r\n\r\n\r\n有两种实现方法，分别是继承Thread类与实现Runnable接口\r\n\r\n用synchronized关键字修饰同步方法\r\n\r\n反对使用stop()，是因为它不安全。它会解除由线程获取的所有锁定，而且如果对象处于一种不连贯状态，那么其他线程能在那种状态下检查和修改它们。结果很难检查出真正的问题所在。suspend()方法容易发生死锁。调用suspend()的时候，目标线程会停下来，但却仍然持有在这之前获得的锁定。此时，其他任何线程都不能访问锁定的资源，除非被\"挂起\"的线程恢复运行。对任何线程来说，如果它们想恢复目标线程，同时又试图使用任何一个锁定的资源，就会造成死锁。所以不应该使用suspend()，而应在自己的Thread类中置入一个标志，指出线程应该活动还是挂起。若标志指出线程应该挂起，便用wait()命其进入等待状态。若标志指出线程应当恢复，则用一个notify()重新启动线程。"
        },
        {
            "ID": "634",
            "typeID": "11",
            "question": "请写出你最常见到的5个runtime exception？",
            "answer": "这道题主要考你的代码量到底多大，如果你长期写代码的，应该经常都看到过一些系统方面的异常，你不一定真要回答出5个具体的系统异常，但你要能够说出什么是系统异常，以及几个系统异常就可以了，当然，这些异常完全用其英文名称来写是最好的，如果实在写不出，那就用中文吧，有总比没有强！\r\n\r\n所谓系统异常，就是…..，它们都是RuntimeException的子类，在jdk doc中查RuntimeException类，就可以看到其所有的子类列表，也就是看到了所有的系统异常。我比较有印象的系统异常有：NullPointerException、ArrayIndexOutOfBoundsException、ClassCastException。"
        },
        {
            "ID": "633",
            "typeID": "11",
            "question": "Java中的异常处理机制的简单原理和应用。",
            "answer": "异常是指java程序运行时（非编译）所发生的非正常情况或错误，与现实生活中的事件很相似，现实生活中的事件可以包含事件发生的时间、地点、人物、情节等信息，可以用一个对象来表示，Java使用面向对象的方式来处理异常，它把程序中发生的每个异常也都分别封装到一个对象来表示的，该对象中包含有异常的信息。\r\n\r\nJava对异常进行了分类，不同类型的异常分别用不同的Java类表示，所有异常的根类为java.lang.Throwable，Throwable下面又派生了两个子类：Error和Exception，Error表示应用程序本身无法克服和恢复的一种严重问题，程序只有死的份了，例如，说内存溢出和线程死锁等系统问题。Exception表示程序还能够克服和恢复的问题，其中又分为系统异常和普通异常，系统异常是软件本身缺陷所导致的问题，也就是软件开发人员考虑不周所导致的问题，软件使用者无法克服和恢复这种问题，但在这种问题下还可以让软件系统继续运行或者让软件死掉，例如，数组脚本越界（ArrayIndexOutOfBoundsException），空指针异常（NullPointerException）、类转换异常（ClassCastException）；普通异常是运行环境的变化或异常所导致的问题，是用户能够克服的问题，例如，网络断线，硬盘空间不够，发生这样的异常后，程序不应该死掉。\r\n\r\njava为系统异常和普通异常提供了不同的解决方案，编译器强制普通异常必须try..catch处理或用throws声明继续抛给上层调用方法处理，所以普通异常也称为checked异常，而系统异常可以处理也可以不处理，所以，编译器不强制用try..catch处理或用throws声明，所以系统异常也称为unchecked异常。\r\n\r\n\r\n\r\n提示答题者：就按照三个级别去思考：虚拟机必须宕机的错误，程序可以死掉也可以不死掉的错误，程序不应该死掉的错误；\r\n"
        },
        {
            "ID": "632",
            "typeID": "11",
            "question": "error和exception有什么区别?",
            "answer": "error 表示恢复不是不可能但很困难的情况下的一种严重问题。比如说内存溢出。不可能指望程序能处理这样的情况。 exception表示一种设计或实现问题。也就是说，它表示如果程序运行正常，从不会发生的情况。"
        },
        {
            "ID": "631",
            "typeID": "11",
            "question": "运行时异常与一般异常有何异同？",
            "answer": "异常表示程序运行过程中可能出现的非正常状态，运行时异常表示虚拟机的通常操作中可能遇到的异常，是一种常见运行错误。java编译器要求方法必须声明抛出可能发生的非运行时异常，但是并不要求必须声明抛出未被捕获的运行时异常。"
        },
        {
            "ID": "630",
            "typeID": "11",
            "question": "下面这条语句一共创建了多少个对象：String s=\"a\"+\"b\"+\"c\"+\"d\"; ？",
            "answer": "对于如下代码：\r\n\r\nString s1 = \"a\";\r\n\r\nString s2 = s1 + \"b\";\r\n\r\nString s3 = \"a\" + \"b\";\r\n\r\nSystem.out.println(s2 == \"ab\");\r\n\r\nSystem.out.println(s3 == \"ab\");\r\n\r\n第一条语句打印的结果为false，第二条语句打印的结果为true，这说明javac编译可以对字符串常量直接相加的表达式进行优化，不必要等到运行期去进行加法运算处理，而是在编译时去掉其中的加号，直接将其编译成一个这些常量相连的结果。\r\n\r\n题目中的第一行代码被编译器在编译时优化后，相当于直接定义了一个”abcd”的字符串，所以，上面的代码应该只创建了一个String对象。写如下两行代码，\r\n\r\nString s =\"a\" + \"b\" + \"c\" + \"d\";\r\n\r\nSystem.out.println(s== \"abcd\");\r\n\r\n最终打印的结果应该为true。"
        },
        {
            "ID": "629",
            "typeID": "11",
            "question": "数组有没有length()这个方法? String有没有length()这个方法？",
            "answer": "数组没有length()这个方法，有length的属性。String有有length()这个方法。"
        },
        {
            "ID": "628",
            "typeID": "11",
            "question": "如何把一段逗号分割的字符串转换成一个数组?",
            "answer": "如果不查jdk api，我很难写出来！我可以说说我的思路：\r\n\r\n1 用正则表达式，代码大概为：String [] result = orgStr.split(“,”);\r\n\r\n2 用 StingTokenizer ,代码为：StringTokenizer tokener = StringTokenizer(orgStr,”,”);\r\n\r\nString [] result =new String[tokener .countTokens()];\r\n\r\nInt i=0;\r\n\r\nwhile(tokener.hasNext(){result[i++]=toker.nextToken();}\r\n"
        },
        {
            "ID": "627",
            "typeID": "11",
            "question": "String和StringBuffer的区别？",
            "answer": "JAVA平台提供了两个类：String和StringBuffer，它们可以储存和操作字符串，即包含多个字符的字符数据。这个String类提供了数值不可改变的字符串。而这个StringBuffer类提供的字符串进行修改。当你知道字符数据要改变的时候你就可以使用StringBuffer。典型地，你可以使用StringBuffers来动态构造字符数据。另外，String实现了equals方法，new String(“abc”).equals(newString(“abc”)的结果为true,而StringBuffer没有实现equals方法，所以，new StringBuffer(“abc”).equals(newStringBuffer(“abc”)的结果为false。"
        },
        {
            "ID": "626",
            "typeID": "11",
            "question": "String s = new String(\"xyz\");创建了几个String Object?二者之间有什么区别？",
            "answer": "两个或一个，”xyz”对应一个对象，这个对象放在字符串常量缓冲区，常量”xyz”不管出现多少遍，都是缓冲区中的那一个。New String每写一遍，就创建一个新的对象，它一句那个常量”xyz”对象的内容来创建出一个新String对象。如果以前就用过’xyz’，这句代表就不会创建”xyz”自己了，直接从缓冲区拿。"
        },
        {
            "ID": "625",
            "typeID": "11",
            "question": "是否可以继承String类?",
            "answer": "String类是final类故不可以继承。"
        },
        {
            "ID": "570",
            "typeID": "11",
            "question": "android中的动画有哪几类，他们的特点和区别是什么？",
            "answer": "两种，\r\n一种是Tween动画(补间动画)，\r\n一种是Frame动画(逐帧动画)。\r\nTween动画：使试图组件移动，放大，缩小以及产生透明度的变化。\r\nFrame动画：传统的动画方法，通过顺序的播放排列好的图片来实现，类似电影。"
        },
        {
            "ID": "569",
            "typeID": "11",
            "question": "你如何评价Android系统？优缺点",
            "answer": "优点：开源特性，得到众多厂商支持。\r\n软件发展很快。\r\n界面UI，系统优化不错。\r\n缺点：版本过多，升级过快。\r\n用户体验不一致。"
        },
        {
            "ID": "568",
            "typeID": "11",
            "question": "请解释下Android程序运行时权限与文件系统权限的区别",
            "answer": "Android程序运行  是虚拟机Dalvik( android授权)\r\n  文件系统   是 linux 内核 授权"
        },
        {
            "ID": "567",
            "typeID": "11",
            "question": "请解释下在单线程模型中Message,Handler,Message Queue,Looper之间的关系",
            "answer": "1.Message\r\n   Message消息，理解为线程间交流的信息，处理数据后台线程需要更新UI，则发送Message内含一些数据给UI线程。\r\n2. Handler\r\n   Handler处理者，是Message的主要处理者，负责Message的发送，Message内容的执行处理。后台线程就是通过传进来的 Handler对象引用来sendMessage(Message)。而使用Handler，需要implement 该类的 handleMessage(Message)\r\n方法，它是处理这些Message的操作内容，例如Update UI。通常需要子类化Handler来实现handleMessage方法。\r\nMessage Queue\r\n   Message Queue消息队列，用来存放通过Handler发布的消息，按照先进先出执行。\r\n    每个message queue都会有一个对应的Handler。Handler会向message queue通过两种方法发送消息：sendMessage或post。这两种消息都会插在message queue队尾并按先进先出执行。但通过这两种方法发送的消息执行的方式略有不同：通过sendMessage发送的是一个message对象,会被 Handler的handleMessage()函数处理；而通过post方法发送的是一个runnable对象，则会自己执行。\r\n4. Looper\r\n   Looper是每条线程里的MessageQueue的管家。Android没有Global的Message Queue，而Android会自动替主线程(UI线程)建立Message Queue，但在子线程里并没有建立Message Queue。所以调用Looper.getMainLooper()得到的主线程的Looper不为NULL，但调用Looper.myLooper() 得到当前线程的Looper就有可能为NULL。\r\n    对于子线程使用Looper，API Doc提供了正确的使用方法："
        },
        {
            "ID": "566",
            "typeID": "11",
            "question": "注册广播有几种方式，这些方式有何优缺点？Android引入广播机制的用意",
            "answer": "2种方式\r\n1.    在androidmainfest.xml中注册  \r\n2.    <receiver>\r\n3.        <intent-filter>\r\n4.           <action android:name = \"android.intent.action.PICK\"/>\r\n5.        </intent-filter>\r\n6.    </receiver>\r\n7.    缺点：常驻型，占资源比较大\r\n8.   \r\n9.    registerReceiver(receiver,filter);  BroadcastReceiver更新UI一般用这种方法"
        },
        {
            "ID": "565",
            "typeID": "11",
            "question": "如何启用Service，如何停用Service",
            "answer": "Intent intent = new Intent();\r\nintent.setClass(this,cba.class);\r\nstartService(intent);\r\nstopService(intent);"
        },
        {
            "ID": "564",
            "typeID": "11",
            "question": "请介绍下android大众常用的五种布局",
            "answer": "FrameLayout（框架布局）\r\n只可以有一个控件，并且不能设计这个控件的位置，控件会放在左上角\r\nLinearLayout（线性布局）\r\n一行只能控制一个控件的线性布局，所以当有很多控件需要在一个界面中列出时，可以用LinearLayout布局\r\nAbsoluteLayout（绝对布局）\r\n可以放置多个控件，并且可以自己定义控件的x,y的位置\r\nRelativeLayout（相对布局）\r\n比如要在一行上显示多个控件，这时就要用到相对布局\r\nTableLayout（表格布局）\r\n将子元素的位置分配到行或列中，一个TableLayout由许多的TableRow组成"
        },
        {
            "ID": "563",
            "typeID": "11",
            "question": "如何退出Activity？如何安全退出已调用多个Activity的Application？",
            "answer": "1.Activity.finish();\r\n也可以用killProcess()和System.exit()这样的方法\r\n2.用ActivityManager的restartPackage方法"
        },
        {
            "ID": "562",
            "typeID": "11",
            "question": "如何将一个Activity设置成窗口样式",
            "answer": "在AndroidManifext.xml中Activity定义处添加\r\nandroid:theme=\"@android:style/Theme.Dialog\"或\r\nandroid:theme=\"@android:style/Theme.Translucent\"。"
        },
        {
            "ID": "561",
            "typeID": "11",
            "question": "请描述下Activity的声明周期",
            "answer": " onCreate->onStart->onRemuse->onPause->onStop->onRestart->onDestroy"
        },
        {
            "ID": "560",
            "typeID": "11",
            "question": "Android引入广播机制的用意?",
            "answer": "a:从MVC的角度考虑(应用程序内)\r\n \r\n　其实回答这个问题的时候还可以这样问，android为什么要有那4大组件，现在的移动开发模型基本上也是照搬的web那一套MVC架构，只不过是改了点嫁妆而已。android的四大组件本质上就是为了实现移动或者说嵌入式设备上的MVC架构，它们之间有时候是一种相互依存的关系，有时候又是一种补充关系，引入广播机制可以方便几大组件的信息和数据交互。\r\n \r\n　　b：程序间互通消息(例如在自己的应用程序内监听系统来电)\r\n \r\n　　c：效率上(参考UDP的广播协议在局域网的方便性)"
        },
        {
            "ID": "559",
            "typeID": "11",
            "question": "如何将打开res aw目录中的数据库文件?",
            "answer": "在Android中不能直接打开res aw目录中的数据库文件，而需要在程序第一次启动时将该文件复制到手机内存或SD卡的某个目录中，然后再打开该数据库文件。复制的基本方法是使用getResources().openRawResource方法获得resaw目录中资源的InputStream对象，然后将该InputStream对象中的数据写入其他的目录中相应文件中。在Android SDK中可以使用SQLiteDatabase.openOrCreateDatabase方法来打开任意目录中的SQLite数据库文件。"
        },
        {
            "ID": "558",
            "typeID": "11",
            "question": "如何将SQLite数据库(dictionary.db文件)与apk文件一起发布?",
            "answer": "可以将dictionary.db文件复制到Eclipse Android工程中的resaw目录中。所有在resaw目录中的文件不会被压缩，这样可以直接提取该目录中的文件。可以将dictionary.db文件复制到resaw目录中."
        },
        {
            "ID": "557",
            "typeID": "11",
            "question": "横竖屏切换时候activity的生命周期?",
            "answer": "1、不设置Activity的android:configChanges时，切屏会重新调用各个生命周期，切横屏时会执行一次，切竖屏时会执行两次\r\n \r\n　　2、设置Activity的android:configChanges=\"orientation\"时，切屏还是会重新调用各个生命周期，切横、竖屏时只会执行一次\r\n \r\n　　3、设置Activity的android:configChanges=\"orientation|keyboardHidden\"时，切屏不会重新调用各个生命周期，只会执行onConfigurationChanged方法"
        },
        {
            "ID": "556",
            "typeID": "11",
            "question": "什么情况会导致Force Close ?如何避免?能否捕获导致其的异常?",
            "answer": "一般像空指针啊，可以看起logcat，然后对应到程序中 来解决错误"
        },
        {
            "ID": "555",
            "typeID": "11",
            "question": "什么是ANR 如何避免它?",
            "answer": "ANR：Application Not Responding，五秒\r\n \r\n在Android中，活动管理器和窗口管理器这两个系统服务负责监视应用程序的响应。当出现下列情况时，Android就会显示ANR对话框了：\r\n \r\n　　对输入事件(如按键、触摸屏事件)的响应超过5秒\r\n \r\n　　意向接受器(intentReceiver)超过10秒钟仍未执行完毕\r\n \r\n　　Android应用程序完全运行在一个独立的线程中(例如main)。这就意味着，任何在主线程中运行的，需要消耗大量时间的操作都会引发ANR。因为此时，你的应用程序已经没有机会去响应输入事件和意向广播(Intentbroadcast)。\r\n \r\n　　因此，任何运行在主线程中的方法，都要尽可能的只做少量的工作。特别是活动生命周期中的重要方法如onCreate()和onResume()等更应如此。潜在的比较耗时的操作，如访问网络和数据库;或者是开销很大的计算，比如改变位图的大小，需要在一个单独的子线程中完成(或者是使用异步请求，如数据库操作)。但这并不意味着你的主线程需要进入阻塞状态已等待子线程结束-- 也不需要调用Therad.wait()或者Thread.sleep()方法。取而代之的是，主线程为子线程提供一个句柄(Handler)，让子线程在即将结束的时候调用它(xing:可以参看Snake的例子，这种方法与以前我们所接触的有所不同)。使用这种方法涉及你的应用程序，能够保证你的程序对输入保持良好的响应，从而避免因为输入事件超过5秒钟不被处理而产生的ANR。这种实践需要应用到所有显示用户界面的线程，因为他们都面临着同样的超时问题。"
        },
        {
            "ID": "554",
            "typeID": "11",
            "question": "说说mvc模式的原理，它在android中的运用",
            "answer": "MVC(Model_view_controller)”模型_视图_控制器”。MVC应用程序总是由这三个部分组成。Event(事件)导致Controller改变Model或View，或者同时改变两者。只要Controller改变了Models的数据或者属性，所有依赖的View都会自动更新。类似的，只要Contro\r\n"
        },
        {
            "ID": "553",
            "typeID": "11",
            "question": "handler机制的原理",
            "answer": "andriod提供了 Handler 和Looper 来满足线程间的通信。Handler先进先出原则。Looper类用来管理特定线程内对象之间的消息交换(MessageExchange)。\r\n        1)Looper: 一个线程可以产生一个Looper对象，由它来管理此线程里的MessageQueue(消息队列)。\r\n \r\n　　2)Handler: 你可以构造Handler对象来与Looper沟通，以便push新消息到Message Queue里;或者接收Looper从MessageQueue取出)所送来的消息。\r\n \r\n　　3) Message Queue(消息队列):用来存放线程放入的消息。\r\n \r\n　　4)线程：UI thread 通常就是mainthread，而Android启动程序时会替它建立一个MessageQueue。"
        },
        {
            "ID": "552",
            "typeID": "11",
            "question": "Android中的动画有哪几类，它们的特点和区别是什么?",
            "answer": "两种，一种是Tween动画、还有一种是Frame动画。Tween动画，这种实现方式可以使视图组件移动、放大、缩小以及产生透明度的变化;另一种Frame动画，传统的动画方法，通过顺序的播放排列好的图片来实现，类似电影。"
        },
        {
            "ID": "551",
            "typeID": "11",
            "question": "一条最长的短信息约占多少byte?",
            "answer": "中文70(包括标点)，英文160，160个字节。"
        },
        {
            "ID": "550",
            "typeID": "11",
            "question": "什么是嵌入式实时操作系统,Android 操作系统属于实时操作系统吗?",
            "answer": "嵌入式实时操作系统是指当外界事件或数据产生时，能够接受并以足够快的速度予以处理，其处理的结果又能在规定的时间之内来控制生产过程或对处理系统作出快速响应，并控制所有实时任务协调一致运行的嵌入式操作系统。主要用于工业控制、 军事设备、 航空航天等领域对系统的响应时间有苛刻的要求，这就需要使用实时系统。又可分为软实时和硬实时两种，而android是基于linux内核的，因此属于软实时。"
        },
        {
            "ID": "549",
            "typeID": "11",
            "question": "嵌入式操作系统内存管理有哪几种，各有何特性",
            "answer": "页式，段式，段页，用到了MMU,虚拟空间等技术"
        },
        {
            "ID": "548",
            "typeID": "11",
            "question": "sim卡的EF文件有何作用",
            "answer": "sim卡的文件系统有自己规范，主要是为了和手机通讯，sim本 身可以有自己的操作系统，EF就是作存储并和手机通讯用的"
        },
        {
            "ID": "547",
            "typeID": "11",
            "question": "Android dvm的进程和Linux的进程, 应用程序的进程是否为同一个概念",
            "answer": "DVM指dalivk的虚拟机。每一个Android应用程序都在它自己的进程中运行，都拥有一个独立的Dalvik虚拟机实例。而每一个DVM都是在Linux中的一个进程，所以说可以认为是同一个概念。"
        },
        {
            "ID": "400",
            "typeID": "11",
            "question": "说出ArrayList,Vector,LinkedList的存储性能和特性",
            "answer": "ArrayList 和 Vector 都是使用数组方式存储数据,此数组元素数大于实际存储的数据以便增加 和插入元素, 它们都允许直接按序号索引元素,但是插入元素要涉及数组元素移动等内存操作,所以索引 数据快而插入数据慢,\r\nVector 由于使用了 synchronized 方法(线程安全),通常性能上较 ArrayList 差,而 LinkedList 使用双向链表实现存储, 按序号索引数据需要进行前向或后向遍历,但是插入数据时只需要记录本项的前后项即可, 所以插入速度较快。"
        },
        {
            "ID": "399",
            "typeID": "11",
            "question": "ArrayList和Vector的区别,HashMap和Hashtable的区别",
            "answer": "就 ArrayList 与 Vector 主要从二方面来说.\r\n1)同步性:Vector 是线程安全的,也就是说是同步的,而 ArrayList 是线程序不安全的,不是 同步的\r\n2)数据增长:当需要增长时,Vector 默认增长为原来一培,而 ArrayList 却是原来的一半\r\n就 HashMap 与 HashTable 主要从三方面来说。 3)历史原因:Hashtable是基于陈旧的Dictionary类的,HashMap是Java1.2引进的Map接口的 一个实现\r\n1)同步性:Hashtable 是线程安全的,也就是说是同步的,而 HashMap 是线程序不安全的,不是 同步的\r\n2)值:只有 HashMap 可以让你将空值作为一个表的条目的 key 或 value"
        },
        {
            "ID": "398",
            "typeID": "11",
            "question": "List,Set,Map是否继承自Collection接口",
            "answer": "List和Set是继承自Collection接口的接口,Set不允许重复的项目,List允许重复项目,Set 接口派生的类有 TreeSet,HashSet,LinkedHashSet。List 接口派生的类有 ArrayList,Vector 等。Map 是独立的接口,不继承 Collection 接口"
        },
        {
            "ID": "397",
            "typeID": "11",
            "question": "用最有效率的方法算出2乘以8等於几",
            "answer": "用移位运算 inta=2<<3;\r\na 就是 2 乘以 8 最后结果是 16 这是最省内存最有效率的方法 这个方法确实高效率的。我来解释一下:\r\n2 的二进制是 10 在 32 位存储器里面是 0000000000000010\r\n左移三位后变成 0000000000010000 也就是 16"
        },
        {
            "ID": "396",
            "typeID": "11",
            "question": "是否可以继承String类",
            "answer": "String 类是 final 类故不可以继承。"
        },
        {
            "ID": "395",
            "typeID": "11",
            "question": "构造器Constructor是否可被override",
            "answer": "构造器 Constructor 不能被继承,因此不能重写 Override,但可以被重载 Overload"
        },
        {
            "ID": "394",
            "typeID": "11",
            "question": "error和exception有什么区别",
            "answer": "error 表示恢复不是不可能但很困难的情况下的一种严重问题。比如说内存溢出。不可能指望程 序能处理这样的情况。exception 表示一种设计或实现问题。也就是说,它表示如果程序运行正 常,从不会发生的情况"
        },
        {
            "ID": "393",
            "typeID": "11",
            "question": "Math.round(11.5)等於多少?Math.round(-11.5)等於多少",
            "answer": "Math.round(11.5)==12\r\nMath.round(-11.5)==-11\r\nround 方法返回与参数最接近的长整数"
        },
        {
            "ID": "392",
            "typeID": "11",
            "question": "&和&&的区别",
            "answer": "&和&&都可以用作逻辑与的运算符,表示逻辑与(and),当运算符两边的表达式的结果都为 true 时,整个运算结果才为 true,否则,只要有一方为 false,则结果为 false。 &&还具有短路的功能,即如果第一个表达式为 false,则不再计算第二个表达式,例如,对于 if(str!=null&&!str.equals(“”))表达式,当 str 为 null 时,后面的表达式不会执行,所以 不会出现 NullPointerException 如果将&&改为&,则会抛出 NullPointerException 异常。 If(x==33&++y>0)y 会增长,If(x==33&&++y>0)不会增长 &还可以用作位运算符,当&操作符两边的表达式不是 boolean 类型时,&表示按位与操作,我们 通常使用 0x0f 来与一个整数进行&运算,来获取该整数的最低 4 个 bit 位,例如,0x31&0x0f 的 结果为 0x01"
        },
        {
            "ID": "391",
            "typeID": "11",
            "question": "StaticNestedClass和InnerClass的不同",
            "answer": "\"NestedClass(一般是 C++的说法),InnerClass(一般是 JAVA 的说法)。Java 内部类与 C++嵌套 类最大的不同就在于是否有指向外部的引用上。\r\n静态内部类(InnerClass)意味着 1 创建一个 static 内部类的对象,不需要一个外部类对象,2 不能从一个 static 内部类的一个对象访问一个外部类对象"
        },
        {
            "ID": "390",
            "typeID": "11",
            "question": "作用域public,private,protected,以及不写时的区别",
            "answer": "AnonymousInnerClass(匿名内部类)是否可以 extends(继承)其它类,是否可以 implements(实 现)interface(接口)\r\n匿名的内部类是没有名字的内部类。不能 extends(继承)其它类,但一个内部类可以作为一个接 口,由另一个内部类实现。"
        },
        {
            "ID": "389",
            "typeID": "11",
            "question": "finish()与System.exit(0)的区别，再谈谈你对退出的理解",
            "answer": "首先一个Activity是有生命周期onCreate,onStart,onResume,onPause,onStop,onDestroy...\r\nfinish是Activity的类，仅仅针对Activity，当调用finish()时，只是将活动推向后台，并没有立即释放内存，活动的资源并没有被清理；当调用System.exit(0)时，杀死了整个进程，这时候活动所占的资源也会被释放。\r\n其次，android的机制决定了用户无法完全退出应用，当你的application最长时间没有被用过的时候，android自身会决定将application关闭了。\r\nfinish方法可以控制像Activity一样的组件，使其结束生命周期，但应用程序全局的资源并不会立刻释放，像static变量的值仍然会保留，保以再次使用。\r\n"
        },
        {
            "ID": "388",
            "typeID": "11",
            "question": "如何线程间通讯？",
            "answer": "Intent 等"
        },
        {
            "ID": "387",
            "typeID": "11",
            "question": "布局、区别、应用场景",
            "answer": "FrameLayout，LinearLayout，TableLayout，RelativeLayout，AbsoluteLayout"
        },
        {
            "ID": "386",
            "typeID": "11",
            "question": "Java线程实现方式和区别",
            "answer": "继承Thread，实现runable接口。\r\n区别：避免点继承的局限，一个类可以继承多个接口。\r\n适合于资源的共享\r\n"
        },
        {
            "ID": "385",
            "typeID": "11",
            "question": "java有那些排序，冒泡代码",
            "answer": "for(inti=0;i<num.length;i++){\r\n//内循环控制比较后移位\r\nfor(intj=num.length-1;j>i;j--){\r\nif(num[j-1]>num[j]){\r\ntemp=num[j-1];\r\nnum[j-1]=num[j];\r\nnum[j]=temp;\r\n}\r\n}\r\n"
        },
        {
            "ID": "384",
            "typeID": "11",
            "question": "LOST.DIR是什么？",
            "answer": "LOST.DIR是专门收集Android系统运行时意外丢失的文件而设置的文件夹，其收集的内容包括系统因为意外而没能保存的各类内存、交换、暂存等数据，软件的缓存数据、以及其他各类文件。只要系统发生意外（如软件突然无法正常运行），便会将发生意外的文件移到此目录下，以数字序列名称代替该文件的扩展名。注意：由于LOST.DIR文件夹的特殊作用，里面的文件都是“意外而生”，因此可以删除里面的文件，但请不要删除LOST.DIR文件夹。"
        },
        {
            "ID": "383",
            "typeID": "11",
            "question": "throw与throws区别",
            "answer": "throws是用来声明一个方法可能抛出的所有异常信息\r\nthrow则是指抛出的一个具体的异常类型。\r\n通常在一个方法（类）的声明处通过throws声明方法（类）可能抛出的异常信息，而在方法（类）内部通过throw声明一个具体的异常信息。\r\nthrows通常不用显示的捕获异常，可由系统自动将所有捕获的异常信息抛给上级方法；\r\nthrow则需要用户自己捕获相关的异常，而后在对其进行相关包装，最后在将包装后的异常信息抛\r\n"
        },
        {
            "ID": "382",
            "typeID": "11",
            "question": "ListView切换奇偶行背景色",
            "answer": "ListView中有时候又这样的需求，当选中某项listView的时候，需求是改变listiew的背景颜色，如果用resource文件会有缓存问题，背景显示错误，那么直接用16进制表示颜色即可。如0xFF7AACC6. 注意表示透明度的需要写上，否则显示不正确"
        },
        {
            "ID": "381",
            "typeID": "11",
            "question": "java中如何引用本地语言",
            "answer": "可以用JNI（java native interface java 本地接口）接口 。"
        },
        {
            "ID": "380",
            "typeID": "11",
            "question": "DDMS和TraceView的区别?",
            "answer": "DDMS是一个程序执行查看器，在里面可以看见线程和堆栈等信息，TraceView是程序性能分析器。"
        },
        {
            "ID": "379",
            "typeID": "11",
            "question": "如何将打开res aw目录中的数据库文件?",
            "answer": "在Android中不能直接打开res aw目录中的数据库文件，而需要在程序第一次启动时将该文件复制到手机内存或SD卡的某个目录中，然后再打开该数据库文件。\r\n复制的基本方法是使用getResources().openRawResource方法获得res aw目录中资源的 InputStream对象，然后将该InputStream对象中的数据写入其他的目录中相应文件中。在Android SDK中可以使用SQLiteDatabase.openOrCreateDatabase方法来打开任意目录中的SQLite数据库文件。\r\n"
        },
        {
            "ID": "378",
            "typeID": "11",
            "question": "怎么提高sqlite的效率?",
            "answer": "事物"
        },
        {
            "ID": "377",
            "typeID": "11",
            "question": "SQLite线程安全吗？sqlite3_threadsafe()来确实是否线程安全版本?",
            "answer": "SQLite是线程安全的。\r\n为了达到线程安全，SQLite在编译时必须将SQLITE_THREADSAFE预处理宏置为1。在Windows和Linux上，已编译的好的二进制发行版中都是这样设置的。如果不确定你所使用的库是否是线程安全的，可以调用sqlite3_threadsafe()接口找出。"
        },
        {
            "ID": "376",
            "typeID": "11",
            "question": "如何将SQLite数据库(dictionary.db文件)与apk文件一起发布?",
            "answer": "可以将dictionary.db文件复制到Eclipse Android工程中的res aw目录中。所有在res aw目录中的文件不会被压缩，这样可以直接提取该目录中的文件。可以将dictionary.db文件复制到res aw目录中."
        },
        {
            "ID": "375",
            "typeID": "11",
            "question": "用算法调整图片的透明度?",
            "answer": "有一个一维整型数组int[]data保存的是一张宽为width，高为height的图片像素值信息。请写一个算法，将该图片所有的白色不透明(0xffffffff)像素点的透明度调整为50%。"
        },
        {
            "ID": "374",
            "typeID": "11",
            "question": "一条最长的短信息约占多少byte",
            "answer": "中文70(包括标点)，英文160，160个字节。"
        },
        {
            "ID": "373",
            "typeID": "11",
            "question": "什么是嵌入式实时操作系统, Android 操作系统属于实时操作系统吗",
            "answer": "嵌入式实时操作系统是指当外界事件或数据产生时，能够接受并以足够快的速度予以处理，其处理的结果又能在规定的时间之内来控制生产过程或对处理系统作出快速响应，并控制所有实时任务协调一致运行的嵌入式操作系统。主要用于工业控制、 军事设备、 航空航天等领域对系统的响应时间有苛刻的要求，这就需要使用实时系统。又可分为软实时和硬实时两种，而android是基于linux内核的，因此属于软实时。"
        },
        {
            "ID": "372",
            "typeID": "11",
            "question": "嵌入式操作系统内存管理有哪几种， 各有何特性",
            "answer": "页式，段式，段页，用到了MMU,虚拟空间等技术"
        },
        {
            "ID": "371",
            "typeID": "11",
            "question": "系统的优势和不足?",
            "answer": "5大优势： \r\n⑴开放性 \r\n在优势方面，Android平台首先就是其开发性，开发的平台允许任何移动终端厂商加入到Android联盟中来。显著的开放性可以使其拥有更多的开发者，随着用户和应用的日益丰富，一个崭新的平台也将很快走向成熟。开放性对于Android的发展而言，有利于积累人气，这里的人气包括消费者和厂商，而对于消费者来讲，随大的受益正是丰富的软件资源。开放的平台也会带来更大竞争，如此一来，消费者将可以用更低的价位购得心仪的手机。\r\n⑵挣脱运营商的束缚 \r\n在过去很长的一段时间，特别是在欧美地区，手机应用往往受到运营商制约，使用什么功能接入什么网络，几乎都受到运营商的控制。从去年iPhone 上市 ，用户可以更加方便地连接网络，运营商的制约减少。随着EDGE、HSDPA这些2G至3G移动网络的逐步过渡和提升，手机随意接入网络已不是运营商口中的笑谈，当你可以通过手机IM软件方便地进行即时聊天时，再回想不久前天价的彩信和图铃下载业务，是不是像噩梦一样？互联网巨头Google推动的Android终端天生就有网络特色，将让用户离互联网更近。\r\n⑶丰富的硬件选择 \r\n这一点还是与Android平台的开放性相关，由于Android的开放性，众多的厂商会推出千奇百怪，功能特色各具的多种产品。功能上的差异和特色，却不会影响到数据同步、甚至软件的兼容，好比你从诺基亚 Symbian风格手机 一下改用苹果 iPhone ，同时还可将Symbian中优秀的软件带到iPhone上使用、联系人等资料更是可以方便地转移，是不是非常方便呢？\r\n⑷不受任何限制的开发商 \r\nAndroid平台提供给第三方开发商一个十分宽泛、自由的环境，不会受到各种条条框框的阻扰，可想而知，会有多少新颖别致的软件会诞生。但也有其两面性，血腥、暴力、情色方面的程序和游戏如可控制正是留给Android难题之一。\r\n⑸无缝结合的Google应用 \r\n如今叱诧互联网的Google已经走过10年度历史，从搜索巨人到全面的互联网渗透，Google服务如地图、邮件、搜索等已经成为连接用户和互联网的重要纽带，而Android平台手机将无缝结合这些优秀的Google服务。\r\n再说Android的5大不足：\r\n⑴安全和隐私 \r\n由于手机 与互联网的紧密联系，个人隐私很难得到保守。除了上网过程中经意或不经意留下的个人足迹，Google这个巨人也时时站在你的身后，洞穿一切，因此，互联网的深入将会带来新一轮的隐私危机。\r\n⑵首先开卖Android手机的不是最大运营商 \r\n众所周知，T-Mobile在23日，于美国纽约发布 了Android首款手机G1。但是在北美市场，最大的两家运营商乃AT&T和Verizon，而目前所知取得Android手机销售权的仅有 T-Mobile和Sprint，其中T-Mobile的3G网络相对于其他三家也要逊色不少，因此，用户可以买账购买G1，能否体验到最佳的3G网络服务则要另当别论了！\r\n⑶运营商仍然能够影响到Android手机 \r\n在国内市场，不少用户对购得移动定制机不满，感觉所购的手机被人涂画了广告一般。这样的情况在国外市场同样出现。Android手机的另一发售运营商Sprint就将在其机型中内置其手机商店程序。\r\n⑷同类机型用户减少 \r\n在不少手机论坛都会有针对某一型号的子论坛，对一款手机的使用心得交流，并分享软件资源。而对于Android平台手机，由于厂商丰富，产品类型多样，这样使用同一款机型的用户越来越少，缺少统一机型的程序强化。举个稍显不当的例子，现在山寨机泛滥，品种各异，就很少有专门针对某个型号山寨机的讨论和群组，除了哪些功能异常抢眼、颇受追捧的机型以外。\r\n⑸过分依赖开发商缺少标准配置 \r\n在使用PC端的Windows Xp系统的时候，都会内置微软Windows Media Player这样一个浏览器程序，用户可以选择更多样的播放器，如Realplay或暴风影音等。但入手开始使用默认的程序同样可以应付多样的需要。在 Android平台中，由于其开放性，软件更多依赖第三方厂商，比如Android系统的SDK中就没有内置音乐 播放器，全部依赖第三方开发，缺少了产品的统一性。\r\n"
        },
        {
            "ID": "370",
            "typeID": "11",
            "question": "系统上安装了多种浏览器，能否指定某浏览器访问指定页面？请说明原由",
            "answer": "通过直接发送Uri把参数带过去，或者通过manifest里的intentfilter里的data属性"
        },
        {
            "ID": "369",
            "typeID": "11",
            "question": "请解释下Android程序运行时权限与文件系统权限的区别",
            "answer": "运行时权限Dalvik( android授权) \r\n文件系统 linux 内核授权\r\n"
        },
        {
            "ID": "368",
            "typeID": "11",
            "question": "AIDL的全称是什么？如何工作？能处理哪些类型的数据",
            "answer": "全称是：Android Interface Define Language\r\n在Android中, 每个应用程序都可以有自己的进程. 在写UI应用的时候, 经常要用到Service. 在不同的进程中, 怎样传递对象呢?显然, Java中不允许跨进程内存共享. 因此传递对象, 只能把对象拆分成操作系统能理解的简单形式, 以达到跨界对象访问的目的. 在J2EE中,采用RMI的方式, 可以通过序列化传递对象. 在Android中, 则采用AIDL的方式. 理论上AIDL可以传递Bundle,实际上做起来却比较麻烦。\r\nAIDL(AndRoid接口描述语言)是一种借口描述语言; 编译器可以通过aidl文件生成一段代码，通过预先定义的接口达到两个进程内部通信进程的目的. 如果需要在一个Activity中, 访问另一个Service中的某个对象, 需要先将对象转化成AIDL可识别的参数(可能是多个参数), 然后使用AIDL来传递这些参数, 在消息的接收端, 使用这些参数组装成自己需要的对象.\r\nAIDL的IPC的机制和COM或CORBA类似, 是基于接口的，但它是轻量级的。它使用代理类在客户端和实现层间传递值. 如果要使用AIDL, 需要完成2件事情: 1. 引入AIDL的相关类.; 2. 调用aidl产生的class.\r\nAIDL的创建方法:\r\nAIDL语法很简单,可以用来声明一个带一个或多个方法的接口，也可以传递参数和返回值。 由于远程调用的需要, 这些参数和返回值并不是任何类型.下面是些AIDL支持的数据类型:\r\n1)不需要import声明的简单Java编程语言类型(int,boolean等)\r\n2) String, CharSequence不需要特殊声明\r\n3) List, Map和Parcelables类型, 这些类型内所包含的数据成员也只能是简单数据类型, String等其他比支持的类型.\r\n"
        },
        {
            "ID": "367",
            "typeID": "11",
            "question": "如何退出Activity？如何安全退出已调用多个Activity的Application",
            "answer": "对于单一Activity的应用来说，退出很简单，直接finish()即可。当然，也可以用killProcess()和System.exit()这样的方法。\r\n对于多个activity:\r\n1)记录打开的Activity：每打开一个Activity，就记录下来。在需要退出时，关闭每一个Activity即可\r\n2)发送特定广播：在需要结束应用时，发送一个特定的广播，每个Activity收到广播后，关闭即可。\r\n3)递归退出：在打开新的Activity时使用startActivityForResult，然后自己加标志，在onActivityResult中处理，递归关闭。为了编程方便，最好定义一个Activity基类，处理这些共通问题。\r\n在2.1之前，可以使用ActivityManager的restartPackage方法。\r\n它可以直接结束整个应用。在使用时需要权限android.permission.RESTART_PACKAGES。\r\n注意不要被它的名字迷惑。\r\n可是，在2.2，这个方法失效了。在2.2添加了一个新的方法，killBackground Processes()，需要权限 android.permission.KILL_BACKGROUND_PROCESSES。可惜的是，它和2.2的restartPackage一样，根本起不到应有的效果。\r\n另外还有一个方法，就是系统自带的应用程序管理里，强制结束程序的方法，forceStopPackage()。它需要权限android.permission.FORCE_STOP_PACKAGES。并且需要添加android:sharedUserId=\"android.uid.system\"属性。同样可惜的是，该方法是非公开的，他只能运行在系统进程，第三方程序无法调用。\r\n因为需要在Android.mk中添加LOCAL_CERTIFICATE := platform。\r\n而Android.mk是用于在Android源码下编译程序用的。\r\n从以上可以看出，在2.2，没有办法直接结束一个应用，而只能用自己的办法间接办到。\r\n现提供几个方法，供参考：\r\n1)抛异常强制退出：\r\n该方法通过抛异常，使程序Force Close。\r\n验证可以，但是，需要解决的问题是，如何使程序结束掉，而不弹出Force Close的窗口。\r\n2)记录打开的Activity：\r\n每打开一个Activity，就记录下来。在需要退出时，关闭每一个Activity即可。\r\n3)发送特定广播：\r\n在需要结束应用时，发送一个特定的广播，每个Activity收到广播后，关闭即可。\r\n4)递归退出\r\n在打开新的Activity时使用startActivityForResult，然后自己加标志，在onActivityResult中处理，递归关闭。\r\n除了第一个，都是想办法把每一个Activity都结束掉，间接达到目的。但是这样做同样不完美。你会发现，如果自己的应用程序对每一个Activity都设置了nosensor，在两个Activity结束的间隙，sensor可能有效了。但至少，我们的目的达到了，而且没有影响用户使用。为了编程方便，最好定义一个Activity基类，处理这些共通问题。\r\n"
        },
        {
            "ID": "366",
            "typeID": "11",
            "question": "如何将一个Activity设置成窗口的样式",
            "answer": "<activity>中配置：android :theme=\"@android:style/Theme.Dialog\" \r\n另外android:theme=\"@android:style/Theme.Translucent\" 是设置透明\r\n"
        },
        {
            "ID": "365",
            "typeID": "11",
            "question": "如果后台的Activity由于某原因被系统回收了，如何在被系统回收之前保存当前状态？",
            "answer": "重写onSaveInstanceState()方法，在此方法中保存需要保存的数据，该方法将会在activity被回收之前调用。通过重写onRestoreInstanceState()方法可以从中提取保存好的数据"
        },
        {
            "ID": "364",
            "typeID": "11",
            "question": "IntentService有何优点？",
            "answer": "Acitivity的进程，当处理Intent的时候，会产生一个对应的Service； Android的进程处理器现在会尽可能的不kill掉你；非常容易使用"
        },
        {
            "ID": "363",
            "typeID": "11",
            "question": "有哪些异常？",
            "answer": "Android本身的api并未声明会抛出异常，则其在运行时有无可能抛出runtime异常，你遇到过吗？诺有的话会导致什么问题？如何解决？\r\n答：会，比如nullpointerException。我遇到过，比如textview.setText()时，textview没有初始化。会导致程序无法正常运行出现forceclose。打开控制台查看logcat信息找出异常信息并修改程序。\r\n"
        },
        {
            "ID": "362",
            "typeID": "11",
            "question": "Service和Thread的区别",
            "answer": "servie是系统的组件，它由系统进程托管（servicemanager）；它们之间的通信类似于client和server，是一种轻量级的ipc通信，这种通信的载体是binder，它是在linux层交换信息的一种ipc。而thread是由本应用程序托管。 1). Thread：Thread 是程序执行的最小单元，它是分配CPU的基本单位。可以用 Thread 来执行一些异步的操作。\r\n2). Service：Service 是android的一种机制，当它运行的时候如果是Local Service，那么对应的 Service 是运行在主进程的 main 线程上的。如：onCreate，onStart 这些函数在被系统调用的时候都是在主进程的 main 线程上运行的。如果是Remote Service，那么对应的 Service 则是运行在独立进程的 main 线程上。\r\n既然这样，那么我们为什么要用 Service 呢？其实这跟 android 的系统机制有关，我们先拿 Thread 来说。Thread 的运行是独立于 Activity 的，也就是说当一个 Activity 被 finish 之后，如果你没有主动停止 Thread 或者 Thread 里的 run 方法没有执行完毕的话，Thread 也会一直执行。因此这里会出现一个问题：当 Activity 被 finish 之后，你不再持有该 Thread 的引用。另一方面，你没有办法在不同的 Activity 中对同一 Thread 进行控制。 \r\n举个例子：如果你的 Thread 需要不停地隔一段时间就要连接服务器做某种同步的话，该 Thread 需要在 Activity 没有start的时候也在运行。这个时候当你 start 一个 Activity 就没有办法在该 Activity 里面控制之前创建的 Thread。因此你便需要创建并启动一个 Service ，在 Service 里面创建、运行并控制该 Thread，这样便解决了该问题（因为任何 Activity 都可以控制同一 Service，而系统也只会创建一个对应 Service 的实例）。 \r\n因此你可以把 Service 想象成一种消息服务，而你可以在任何有 Context 的地方调用 Context.startService、Context.stopService、Context.bindService，Context.unbindService，来控制它，你也可以在 Service 里注册 BroadcastReceiver，在其他地方通过发送 broadcast 来控制它，当然这些都是 Thread 做不到的。"
        },
        {
            "ID": "361",
            "typeID": "11",
            "question": "请介绍下ContentProvider是如何实现数据共享的？",
            "answer": "一个程序可以通过实现一个Content provider的抽象接口将自己的数据完全暴露出去，而且Content providers是以类似数据库中表的方式将数据暴露。Content providers存储和检索数据，通过它可以让所有的应用程序访问到，这也是应用程序之间唯一共享数据的方法。\r\n要想使应用程序的数据公开化，可通过2种方法：创建一个属于你自己的Content provider或者将你的数据添加到一个已经存在的Content provider中，前提是有相同数据类型并且有写入Content provider的权限。\r\n如何通过一套标准及统一的接口获取其他应用程序暴露的数据，Android提供了ContentResolver，外界的程序可以通过ContentResolver接口访问ContentProvider提供的数据。\r\n"
        },
        {
            "ID": "320",
            "typeID": "11",
            "question": "什么情况会导致Force Close ，如何避免，能否捕获导致其的异常",
            "answer": "程序出现异常，比如nullpointer。\r\n避免：编写程序时逻辑连贯，思维缜密。能捕获异常，在logcat中能看到异常信息。"
        },
        {
            "ID": "319",
            "typeID": "11",
            "question": "说明handler机制的原理",
            "answer": "一个Handler允许你发送和处理Message和Runable对象，每个线程都有自己的Looper，每个Looper中封装着MessageQueue。 Looper负责不断的从自己的消息队列里取出队头的任务或消息执行。每个handler也和线程关联，Handler负责把Message和Runable\r\n对象传递给MessageQueue（用到post，sendMessage等方法），而且在这些对象离开MessageQueue时，Handler负责执行他们（用到handleMessage方法）。\r\n其中Message类就是定义了一个信息，这个信息中包含一个描述符和任意的数据对象，这个信息被用来传递给Handler.Message对象。"
        },
        {
            "ID": "318",
            "typeID": "11",
            "question": "如何启用停用Service",
            "answer": "服务的开发比较简单，如下：\r\n第一步：继承Service类\r\npublic class SMSService extends Service {}\r\n第二步：在AndroidManifest.xml文件中的<application>节点里对服务进行配置:<service android:name=\".SMSService\" />\r\n服务不能自己运行，需要通过调用Context.startService()或Context.bindService()方法启动服务。这两个方法都可以启动Service，但是它们的使用场合有所不同。使用startService()方法启用服务，调用者与服务之间没有关连，即使调用者退出了，服务仍然运行。使用bindService()方法启用服务，调用者与服务绑定在了一起，调用者一旦退出，服务也就终止，大有“不求同时生，必须同时死”的特点。\r\n如果打算采用Context.startService()方法启动服务，在服务未被创建时，系统会先调用服务的onCreate()方法，接着调用onStart()方法。如果调用startService()方法前服务已经被创建，多次调用startService()方法并不会导致多次创建服务，但会导致多次调用onStart()方法。采用startService()方法启动的服务，只能调用Context.stopService()方法结束服务，服务结束时会调用onDestroy()方法。\r\n如果打算采用Context.bindService()方法启动服务，在服务未被创建时，系统会先调用服务的onCreate()方法，接着调用onBind()方法。这个时候调用者和服务绑定在一起，调用者退出了，系统就会先调用服务的onUnbind()方法，接着调用onDestroy()方法。如果调用bindService()方法前服务已经被绑定，多次调用bindService()方法并不会导致多次创建服务及绑定(也就是说onCreate()和onBind()方法并不会被多次调用)。如果调用者希望与正在绑定的服务解除绑定，可以调用unbindService()方法，调用该方法也会导致系统调用服务的onUnbind()-->onDestroy()方法。\r\n服务常用生命周期回调方法如下： \r\nonCreate() 该方法在服务被创建时调用，该方法只会被调用一次，无论调用多少次startService()或bindService()方法，服务也只被创建一次。\r\nonDestroy()该方法在服务被终止时调用。\r\n与采用Context.startService()方法启动服务有关的生命周期方法\r\nonStart() 只有采用Context.startService()方法启动服务时才会回调该方法。该方法在服务开始运行时被调用。多次调用startService()方法尽管不会多次创建服务，但onStart() 方法会被多次调用。\r\n与采用Context.bindService()方法启动服务有关的生命周期方法\r\nonBind()只有采用Context.bindService()方法启动服务时才会回调该方法。该方法在调用者与服务绑定时被调用，当调用者与服务已经绑定，多次调用Context.bindService()方法并不会导致该方法被多次调用。\r\nonUnbind()只有采用Context.bindService()方法启动服务时才会回调该方法。该方法在调用者与服务解除绑定时被调用.\r\n"
        },
        {
            "ID": "317",
            "typeID": "11",
            "question": "Activity的启动模式有哪些，是什么含义",
            "answer": "在android里，有4种activity的启动模式，分别为： \r\n“standard” (默认) \r\n“singleTop” \r\n“singleTask” \r\n“singleInstance”\r\n它们主要有如下不同：\r\n1)如何决定所属task \r\n“standard”和”singleTop”的activity的目标task，和收到的Intent的发送者在同一个task内，除非intent包括参数FLAG_ACTIVITY_NEW_TASK。 \r\n如果提供了FLAG_ACTIVITY_NEW_TASK参数，会启动到别的task里。 \r\n“singleTask”和”singleInstance”总是把activity作为一个task的根元素，他们不会被启动到一个其他task里。\r\n2)是否允许多个实例 \r\n“standard”和”singleTop”可以被实例化多次，并且存在于不同的task中，且一个task可以包括一个activity的多个实例； \r\n“singleTask”和”singleInstance”则限制只生成一个实例，并且是task的根元素。 singleTop要求如果创建intent的时候栈顶已经有要创建 的Activity的实例，则将intent发送给该实例，而不发送给新的实例。\r\n3)是否允许其它activity存在于本task内 \r\n“singleInstance”独占一个task，其它activity不能存在那个task里；如果它启动了一个新的activity，不管新的activity的launch mode 如何，新的activity都将会到别的task里运行（如同加了FLAG_ACTIVITY_NEW_TASK参数）。 \r\n而另外三种模式，则可以和其它activity共存。\r\n4)是否每次都生成新实例 \r\n“standard”对于没一个启动Intent都会生成一个activity的新实例； \r\n“singleTop”的activity如果在task的栈顶的话，则不生成新的该activity的实例，直接使用栈顶的实例，否则，生成该activity的实例。 \r\n比如现在task栈元素为A-B-C-D（D在栈顶），这时候给D发一个启动intent，如果D是 “standard”的，则生成D的一个新实例，栈变为A－B－C－D－D。 \r\n如果D是singleTop的话，则不会生产D的新实例，栈状态仍为A-B-C-D \r\n如果这时候给B发Intent的话，不管B的launchmode是”standard” 还是 “singleTop” ，都会生成B的新实例，栈状态变为A-B-C-D-B。\r\n“singleInstance”是其所在栈的唯一activity，它会每次都被重用。\r\n“singleTask”如果在栈顶，则接受intent，否则，该intent会被丢弃，但是该task仍会回到前台。\r\n当已经存在的activity实例处理新的intent时候，会调用onNewIntent()方法 如果收到intent生成一个activity实例，那么用户可以通过back键回到上一个状态；如果是已经存在的一个activity来处理这个intent的话，用户不能通过按back键返回到这之前的状态。\r\n"
        },
        {
            "ID": "316",
            "typeID": "11",
            "question": "Android中的动画有哪几类，它们的特点和区别是什么",
            "answer": "两种，一种是Tween动画、还有一种是Frame动画。Tween动画，这种实现方式可以使视图组件移动、放大、缩小以及产生透明度的变化;另一种Frame动画，传统的动画方法，通过顺序的播放排列好的图片来实现，类似电影。"
        },
        {
            "ID": "315",
            "typeID": "11",
            "question": "请介绍下Android中常用的五种布局分别是什么",
            "answer": "常用五种布局方式，分别是：FrameLayout（框架布局），LinearLayout （线性布局），AbsoluteLayout（绝对布局），RelativeLayout（相对布局），TableLayout（表格布局）。\r\n1)FrameLayout：所有东西依次都放在左上角，会重叠，这个布局比较简单，也只能放一点比较简单的东西。2)LinearLayout：线性布局，每一个LinearLayout里面又可分为垂直布局（android:orientation=\"vertical\"）和水平布局（android:orientation=\"horizontal\" ）。当垂直布局时，每一行就只有一个元素，多个元素依次垂直往下；水平布局时，只有一行，每一个元素依次向右排列。\r\n3)AbsoluteLayout：绝对布局用X,Y坐标来指定元素的位置，这种布局方式也比较简单，但是在屏幕旋转时，往往会出问题，而且多个元素的时候，计算比较麻烦。\r\n4)RelativeLayout：相对布局可以理解为某一个元素为参照物，来定位的布局方式。主要属性有：相对于某一个元素android:layout_below、 android:layout_toLeftOf相对于父元素的地方android:layout_alignParentLeft、android:layout_alignParentRigh;\r\n5)TableLayout：表格布局，每一个TableLayout里面有表格行TableRow，TableRow里面可以具体定义每一个元素。每一个布局都有自己适合的方式，这五个布局元素可以相互嵌套应用，做出美观的界面。\r\n"
        },
        {
            "ID": "314",
            "typeID": "11",
            "question": "android客户端如何实现自动登录",
            "answer": "通过SharedPreferences存储用户名,密码,当存储不为空时实现自动登录功能"
        },
        {
            "ID": "313",
            "typeID": "11",
            "question": "Android SDK 3.0(HoneyComb)及4.0(Ice Cream)新特性",
            "answer": "新版SDK发布的同时也发布了一个扩展包android-support-v4，把部分特性单独的抽出来，使低版本的SDK也可以使用这些特性，主要支持以下特性：\r\nFragment: 3.0引入,碎片管理,可以局部刷新UI,它设计的功能和Activity一样强大，包括生命周期、导航等，Fragment的每次导航都可以记录下来用于返回。 \r\nViewPager: 提供了多界面切换的新效果 \r\nGridLayout: 4.0引入, 网格布局, android第六大布局\r\nLoader: 装载器从android3.0开始引进。它使得在activity或fragment中异步加载数据变得简单\r\n"
        },
        {
            "ID": "312",
            "typeID": "11",
            "question": "实现手风琴效果",
            "answer": "实现手风琴效果（ExpandableListView）\r\n设置界面的类（preferenceActivity）保存到sharedpreference中\r\n抽屉效果（slidingDrawer）组件\r\n悬浮窗口: PopWindow,可以实现类似Dialog和菜单的效果\r\n"
        },
        {
            "ID": "311",
            "typeID": "11",
            "question": "谈谈UI中， Padding和Margin有什么区别,gravity与layout_gravity的区别",
            "answer": "Padding 用来指定组件内的内容距离组件边界的距离;\r\n Margin用来指定控件与控件之间的距离\r\nGravity用来指定组件内的内容相对于组件本身的位置\r\nLayout_gravity用来指定组件相对于其父组件的位置\r\n"
        },
        {
            "ID": "310",
            "typeID": "11",
            "question": "如何将一个Activity设置成窗口的样式",
            "answer": "在清单文件AndroidManifest.xml中相应的<activity>标签内设置属性android:theme=”@android:style/Theme.Dialog”"
        },
        {
            "ID": "309",
            "typeID": "11",
            "question": "如何实现一键退出",
            "answer": "定义一个类继承Application，定义一个集合存放所有的activity， \r\n定义一个添加的方法，再写一个退出的方法，使用for循环全部调用finish方法，然\r\n后在每个Activity的onCreate方法中调用自定义类里的添加方法，然后在需要使用一\r\n键退出的地方调用类中的退出方法即可。\r\n"
        },
        {
            "ID": "308",
            "typeID": "11",
            "question": "NDK开发流程？（JNI运行原理）",
            "answer": "NDK应用的开发流程(在应用中定义本地接口(native), 编译成.h头文件,交由C程序员实现,将.c实现通过NDK编译成.so动态链接库,导入项目中libs/armeabi,代码中调用该本地接口)\r\n应用场景: 音频,视频解码,拍摄车牌号,识别车牌号\r\n"
        },
        {
            "ID": "307",
            "typeID": "11",
            "question": "播放视频有哪些实现方式",
            "answer": "1)使用系统自带的播放器来播放，指定Action为ACTION_VIEW,Data为Uri，Type为其MIME类型。\r\n\t\t\t//调用系统自带的播放器 \r\n Intent intent = new Intent(Intent.ACTION_VIEW); \r\n intent.setDataAndType(uri, \"video/mp4\"); \r\n startActivity(intent);\r\n2)使用VideoView组件来播放, 可以结合MediaController来实现播控, 只是不能随意更改视频的大小及位置。\r\n3)使用MediaPlayer和SurfaceView来实现，这种方式很灵活,可以自定义视频播放的大小和位置。\r\n"
        },
        {
            "ID": "306",
            "typeID": "11",
            "question": "版本更新的实现思路",
            "answer": "在服务器相应URL上有版本文件, 客户端同时存储该应用当前版本号 (SharedPreferences/Sqlite), 每次打开应用,去检测服务器版本号与本地版本号是否一致,如果不一 致,则自定义对话框提示是否下载更新"
        },
        {
            "ID": "305",
            "typeID": "11",
            "question": "Android 自定义组件实现思路",
            "answer": "Android 自定义组件有三种实现思路:\r\n1) 继承某个现有组件,在其基础上添加额外功能,如继承 Gallery 实现 CoverFlow 效果\r\n2) 继承某个 Layout,实现复合组件自定义,如 TextView 和 EditText 组合实现登录注册组件\r\n3) 继承 View,实现 onDraw()方法,实现自己绘制组件,如翻页效果组件"
        },
        {
            "ID": "304",
            "typeID": "11",
            "question": "如何实现消息推送",
            "answer": "实现消息推送的方式有五种,分别是轮询,SMS,C2DM,MQTT,XMPP 最常使用的是 XMPP, 我 们做项目时采用的是 XMPP 协议"
        },
        {
            "ID": "303",
            "typeID": "11",
            "question": "加载大图片的时候如何防止内存溢出",
            "answer": " android 系统给图片分配的内存只有 8M,当加载大量图片时往往会出现 OOM。"
        },
        {
            "ID": "302",
            "typeID": "11",
            "question": "android 内存的优化",
            "answer": "android 内存泄露容易导致内存溢出,又称为 OOM。\r\nAndroid 内存优化策略:\r\n1)在循环内尽量不要使用局部变量\r\n2)不用的对象即时释放,即指向 NULL\r\n3)数据库的 cursor 即时关闭。\r\n4)构造 adapter 时使用缓存 contentview\r\n5)调用 registerReceiver()后在对应的生命周期方法中调用 unregisterReceiver()\r\n6)即时关闭 InputStream/OutputStream。\r\n7)android系统给图片分配的内存只有8M, 图片尽量使用软引用, 较大图片可通过BitmapFactory 缩放后再使用,并及时 recycle\r\n8)尽量避免 static 成员变量引用资源耗费过多的实例。"
        },
        {
            "ID": "301",
            "typeID": "11",
            "question": "度地图核心类,及实现的功能",
            "answer": "BMapManager:地图引擎管理类,负责初始化,开启地图 API,终止百度地图 API 等工作 MKSearch:搜索服务.用于位置检索、周边检索、范围检索、公交检索、驾乘检索、步行检索 MKSearchListener 搜索结果通知接口。该接口返回 poi 搜索,公交搜索,驾乘路线,步行路线结果 MapView:显示地图的 View\r\nMyLocationOverlay:一个负责显示用户当前位置的 Overlay。\r\nOverlay:Overlay 是一个基类,它表示可以显示在地图上方的覆盖物。"
        },
        {
            "ID": "203",
            "typeID": "11",
            "question": "说出 ArrayList,Vector, LinkedList 的存储性能和特性?",
            "answer": "ArrayList 和 Vector 都是使用数组方式存储数据,此数组元素数大于实 际存储的数据以便增加和插入元素,它们都允许直接按序号索引元素, 但是插入元素要涉及数组元素移动等内存操作,所以索引数据快而插入 数据慢,Vector 由于使用了 synchronized 方法(线程安全),通常性 能上较 ArrayList 差,而 LinkedList 使用双向链表实现存储,按序号 索引数据需要进行前向或后向遍历,但是插入数据时只需要记录本项的 前后项即可,所以插入速度较快。"
        },
        {
            "ID": "202",
            "typeID": "11",
            "question": "面向对象的特征有哪些方面?",
            "answer": "1.抽象: 抽象就是忽略一个主题中与当前目标无关的那些方面,以便更充分地注 意与当前目标有关的方面。抽象并不打算了解全部问题,而只是选择其 中的一部分,暂时不用部分细节。抽象包括两个方面,一是过程抽象, 二是数据抽象。 2.继承: 继承是一种联结类的层次模型,并且允许和鼓励类的重用,它提供了一 种明确表述共性的方法。对象的一个新类可以从现有的类中派生,这个 过程称为类继承。新类继承了原始类的特性,新类称为原始类的派生类 (子类),而原始类称为新类的基类(父类)。派生类可以从它的基类 那里继承方法和实例变量,并且类可以修改或增加新的方法使之更适合 特殊的需要。 3.封装: 封装是把过程和数据包围起来,对数据的访问只能通过已定义的界面。 面向对象计算始于这个基本概念,即现实世界可以被描绘成一系列完全 自治、封装的对象,这些对象通过一个受保护的接口访问其他对象。 4. 多态性: 多态性是指允许不同类的对象对同一消息作出响应。多态性包括参数化 多态性和包含多态性。多态性语言具有灵活、抽象、行为共享、代码共 享的优势,很好的解决了应用程序函数同名问题。\r\n"
        },
        {
            "ID": "201",
            "typeID": "11",
            "question": "try {}里有一个 return 语句,那么紧跟在这个 try 后的 finally {}里的 code 会不会被执行,什么时候被执行,在 return 前还 是后?",
            "answer": "会执行,在 return 前执行。"
        },
        {
            "ID": "200",
            "typeID": "11",
            "question": "当一个线程进入一个对象的一个 synchronized 方法后,其它 线程是否可进入此对象的其它方法?",
            "answer": "不能,一个对象的一个 synchronized 方法只能由一个线程访问。"
        },
        {
            "ID": "199",
            "typeID": "11",
            "question": "是否可以继承 String 类?",
            "answer": "String 类是 final 类故不可以继承。"
        },
        {
            "ID": "198",
            "typeID": "11",
            "question": "构造器 Constructor 是否可被 override?",
            "answer": "构造器 Constructor 不能被继承,因此不能重写 Overriding,但可以被 重载 Overloading。"
        },
        {
            "ID": "197",
            "typeID": "11",
            "question": "启动一个线程是用 run()还是 start()?",
            "answer": "启动一个线程是调用 start()方法,使线程所代表的虚拟处理机处于可运 行状态,这意味着它可以由 JVM 调度并执行。这并不意味着线程就会立即 运行。run()方法可以产生必须退出的标志来停止一个线程。\r\n"
        },
        {
            "ID": "196",
            "typeID": "11",
            "question": "接口是否可继承接口? 抽象类是否可实现(implements)接口?",
            "answer": "抽象类是否可继承实体类(concrete class)? 接口可以继承接口。抽象类可以实现(implements)接口,抽象类是否可继 承实体类,但前提是实体类必须有明确的构造函数。\r\n"
        },
        {
            "ID": "195",
            "typeID": "11",
            "question": "abstract 的 method 是否可同时是 static,是否可同时是 native,是否可同时是 synchronized?",
            "answer": "都不能\r\n"
        },
        {
            "ID": "194",
            "typeID": "11",
            "question": "abstract class 和 interface 有什么区别?",
            "answer": "声明方法的存在而不去实现它的类被叫做抽象类(abstract class), 它用于要创建一个体现某些基本行为的类,并为该类声明方法,但不能在 该类中实现该类的情况。不能创建 abstract 类的实例。然而可以创建一 个变量,其类型是一个抽象类,并让它指向具体子类的一个实例。不能有 抽象构造函数或抽象静态方法。Abstract 类的子类为它们父类中的所有 抽象方法提供实现,否则它们也是抽象类为。取而代之,在子类中实现该 方法。知道其行为的其它类可以在类中实现这些方法。 接口(interface)是抽象类的变体。在接口中,所有方法都是抽象的。 多继承性可通过实现这样的接口而获得。接口中的所有方法都是抽象的, 没有一个有程序体。接口只可以定义 static final 成员变量。接口的实 现与子类相似,除了该实现类不能从接口定义中继承行为。当类实现特殊 接口时,它定义(即将程序体给予)所有这种接口的方法。然后,它可以 在实现了该接口的类的任何对象上调用接口的方法。由于有抽象类,它允 许使用接口名作为引用变量的类型。通常的动态联编将生效。引用可以转 换到接口类型或从接口类型转换,instanceof 运算符可以用来决定某对 象的类是否实现了接口。"
        },
        {
            "ID": "193",
            "typeID": "11",
            "question": "List, Set, Map 是否继承自 Collection 接口?",
            "answer": "List,Set 是\r\nMap 不是"
        },
        {
            "ID": "192",
            "typeID": "11",
            "question": "error 和 exception 有什么区别?",
            "answer": "error 表示恢复不是不可能但很困难的情况下的一种严重问题。比如说内 存溢出。不可能指望程序能处理这样的情况。\r\nexception 表示一种设计或实现问题。也就是说,它表示如果程序运行正 常,从不会发生的情况。"
        },
        {
            "ID": "191",
            "typeID": "11",
            "question": "Set里的元素是不能重复的,那么用什么方法来区分重复与否呢? 是用==还是 equals()? 它们有何区别?",
            "answer": "Set 里的元素是不能重复的,那么用 iterator()方法来区分重复与否。 equals()是判读两个 Set 是否相等。 equals()和==方法决定引用值是否指向同一对象 equals()在类中被覆 盖,为的是当两个分离的对象的内容和类型相配的话,返回真值。"
        },
        {
            "ID": "190",
            "typeID": "11",
            "question": "Overload 和 Override 的区别。Overloaded 的方法是否可以改 变返回值的类型?",
            "answer": "方法的重写 Overriding 和重载 Overloading 是 Java 多态性的不同表现。 重写 Overriding 是父类与子类之间多态性的一种表现,重载 Overloading 是一个类中多态性的一种表现。如果在子类中定义某方法与 其父类有相同的名称和参数,我们说该方法被重写 (Overriding)。子类 的对象使用这个方法时,将调用子类中的定义,对它而言,父类中的定义 如同被“屏蔽”了。如果在一个类中定义了多个同名的方法,它们或有不 同的参数个数或有不同的参数类型,则称为方法的重载(Overloading)。 Overloaded 的方法是可以改变返回值的类型。"
        },
        {
            "ID": "189",
            "typeID": "11",
            "question": "数组有没有 length()这个方法? String 有没有 length()这个 方法?",
            "answer": "数组没有 length()这个方法,有 length 的属性。\r\nString 有有 length()这个方法。\r\n"
        },
        {
            "ID": "188",
            "typeID": "11",
            "question": "Java 有没有 goto?",
            "answer": "Goto?java 中的保留字,现在没有在 java 中使用。"
        },
        {
            "ID": "187",
            "typeID": "11",
            "question": "sleep() 和 wait() 有什么区别? ",
            "answer": "sleep()方法是使线程停止一段时间的方法。在 sleep 时间间隔期满后, 线程不一定立即恢复执行。这是因为在那个时刻,其它线程可能正在运行 而且没有被调度为放弃执行,除非(a)“醒来”的线程具有更高的优先级 (b)正在运行的线程因为其它原因而阻塞。 wait()是线程交互时,如果线程对一个同步对象 x 发出一个 wait()调用, 该线程会暂停执行,被调对象进入等待状态,直到被唤醒或等待时间到。\r\n"
        },
        {
            "ID": "186",
            "typeID": "11",
            "question": "Math.round(11.5)等於多少? Math.round(-11.5)等於多少?",
            "answer": "Math.round(11.5)返回(long)12,Math.round(-11.5)返回(long) -11;"
        },
        {
            "ID": "185",
            "typeID": "11",
            "question": "String s = new String(\"xyz\");创建了几个 String Object?",
            "answer": "两个对象,一个是“xyx”,一个是指向“xyx”的引用对象 s。"
        },
        {
            "ID": "184",
            "typeID": "11",
            "question": "GC 是什么? 为什么要有 GC?",
            "answer": "GC 是垃圾收集器。Java 程序员不用担心内存管理,因为垃圾收集器会自 动进行管理。要请求垃圾收集,可以调用下面的方法之一: System.gc()\r\nRuntime.getRuntime().gc()"
        },
        {
            "ID": "183",
            "typeID": "11",
            "question": "Collection 和 Collections 的区别",
            "answer": "Collections 是个 java.util 下的类,它包含有各种有关集合操作的静 态方法。\r\nCollection 是个 java.util 下的接口,它是各种集合结构的父接口。"
        },
        {
            "ID": "182",
            "typeID": "11",
            "question": "HashMap 和 Hashtable 的区别",
            "answer": "都属于 Map 接口的类,实现了将惟一键映射到特定的值上。\r\nHashMap 类没有分类或者排序。它允许一个 null 键和多个 null 值。 Hashtable 类似于 HashMap,但是不允许 null 键和 null 值。它也比 HashMap 慢,因为它是同步的。\r\n"
        },
        {
            "ID": "181",
            "typeID": "11",
            "question": "&和&&的区别",
            "answer": "&是位运算符。&&是布尔逻辑运算符。\r\n"
        },
        {
            "ID": "180",
            "typeID": "11",
            "question": "sax 解析代码",
            "answer": "首先 SAXParserFactory 来创建一个 SAXParserFactory 实例 SAXParserFactory factory = SAXParserFactory.newInstance(); 根据 SAXParserFactory 实例来创建 SAXParser\r\nSAXParser 产生 SAXReader\r\nXMLReader reader = factory.newSAXParser().getXMLReader();\r\nXMLReader 加载 XML,然后解析 XML,在解析的过程中触发相对于接口中的事件处理程序"
        },
        {
            "ID": "179",
            "typeID": "11",
            "question": "XML 解析有哪几种?各自优缺点,官方推荐使用哪种",
            "answer": "基本的解析方式有三种: DOM,SAX,Pull 1)dom 解析解析器读入整个文档,然后构建一个驻留内存的树结构,然后代码就可以使用 DOM 接口来操作这个树结构的优点是对文档增删改查比较方便,缺点占用内存比较大。 2)sax 解析基于事件驱动型,优点占用内存少,解析速度快,缺点是只适合做文档的读取,不适合 做文档的增删改查。 3)pull 解析同样基于事件驱动型,android 官方 API 提供,可随时终止,调用 next() 方法提取它们(主动提取事件)\r\n"
        },
        {
            "ID": "178",
            "typeID": "11",
            "question": "移动互联数据交互格式有哪些及其区别",
            "answer": "(Json(有数据类型)与 xml(没有)的区别?) 移动互联数据交互格式有 XML 和 JSON 1)JSON 和 XML 的数据可读性基本相同\r\n2)JSON 和 XML 同样拥有丰富的解析手段 3)JSON 相对于 XML 来讲,数据的体积小 4)JSON 与 JavaScript 的交互更加方便 5)JSON 对数据的描述性比 XML 较差"
        },
        {
            "ID": "177",
            "typeID": "11",
            "question": "说说HttpClient的通信过程",
            "answer": "1)生成请求对象(HttpGet get,HttpPost post)\r\n2)生成客户端对象 HttpClient client\r\n3)执行请求接收相应 HttpResponse response = client.execute(post)\r\nHttpEntity entity = response.getEntity()\r\n4)得到数据流\r\nInputStream inputStream = entity.getContent();\r\n5)最后关闭过期连接"
        },
        {
            "ID": "176",
            "typeID": "11",
            "question": "android 哪几种方式访问网络",
            "answer": "http 协议:超文本传输协议\r\n(最底层的是 Socket,接着是 URLConnection,HttpClient)\r\naction 节点中的 android.intent.action.MAIN 表明它所在的 Activity 是整个应用程序的入口点\r\nHttpURLConnection\r\nHttpClient 方式(HttpGet 和 HttpPost 类)"
        },
        {
            "ID": "175",
            "typeID": "11",
            "question": "Android 程序入口如何判断",
            "answer": "action 节点中的 android.intent.action.MAIN 表明它所在的 Activity 是整个应用程序的入口点"
        },
        {
            "ID": "174",
            "typeID": "11",
            "question": "简述Android中的IPC机制",
            "answer": "IPC(Inter-Process Communication,进程间通信),aidl 是 Android Interface definition language 的缩写,它是一种 android 内部进程通信接口的描述语言,通过它我们可以定义进程 间的通信接口.编译器可以通过扩展名为 aidl 的文件生成一段代码,通过预先定义的接口达到两 个进程内部通信进程的目的.\r\nBroadcastReceiver 也可以实现进程间通信\r\nContentProvider 提供进程间数据共享"
        },
        {
            "ID": "173",
            "typeID": "11",
            "question": "如何实现屏幕分辨率的自适应(布局、九线图、目录)",
            "answer": "最好可以通过权重(layout_weight)的方式来分配每个组件的大小,也可以通过具体的像素 (dip)来确定大小。   尽量使用 Relativelayout 。   已知应用支持平台设备的分辨率,可以提供多个 layout_320*480 ... drawable-hdpi,drawable-mdpi,drawable-ldpi 分别代表分辨率为480*800,360*480,240*360, 放置图片大小相差1.5倍 最后还需要在 AndroidManifest.xml 里添加下面一段,没有这一段自适应就不能实现: <supports-screens android:largeScreens=\"true\" android:normalScreens=\"true\"\r\nandroid:anyDensity = \"true\"/> 在</application>标签和</manifest> 标签之间添加上面那段代码。即可。 备注:三者的解析度不一样,就像你把电脑的分辨率调低,图片会变大一样,反之分辨率高,图 片缩小 还可以通过.9.png 实现图片的自适应\r\n"
        },
        {
            "ID": "172",
            "typeID": "11",
            "question": "Intent 的原理、作用、可以传递哪些类型的参数",
            "answer": "intent 是连接 Activity, Service, BroadcastReceiver, ContentProvider 四大组件的信使,, 可以传递八种基本数据类型以及 string, Bundle 类型,以及实现了 Serializable 或者 Parcelable 的类型。\r\nIntent 可以划分成显式意图和隐式意图。 显式意图:调用Intent.setComponent()或Intent.setClass()方法明确指定了组件名的Intent 为显式意图,显式意图明确指定了 Intent 应该传递给哪个组件。 隐式意图:没有明确指定组件名的 Intent 为隐式意图。 Android 系统会根据隐式意图中设置的 动作(action)、类别(category)、数据(URI 和数据类型)找到最合适的组件来处理这个意图。"
        },
        {
            "ID": "171",
            "typeID": "11",
            "question": "ListView 图片异步加载实现思路",
            "answer": "1)先从内存缓存中获取图片显示(内存缓冲)\r\n2)获取不到的话从 SD 卡里获取(SD 卡缓冲,从 SD 卡获取图片是放在子线程里执行的,否则快 速滑屏的话会不够流畅)\r\n3)都获取不到的话从网络下载图片并保存到 SD 卡同时加入内存并显示(视情况看是否要显示)"
        },
        {
            "ID": "170",
            "typeID": "11",
            "question": "ListView 分页加载实现思路",
            "answer": "实现 OnScrollListener 接口重写 onScrollStateChanged 和 onScroll 方法,使用 onscroll 方法 实现”滑动“后处理检查是否还有新的记录,如果有,调用 addFooterView,添加记录到 adapter, adapter 调用 notifyDataSetChanged 更新数据;如果没有记录了,把自定义的 mFooterView 去 掉。使用 onScrollStateChanged 可以检测是否滚到最后一行且停止滚动然后执行加载"
        },
        {
            "ID": "169",
            "typeID": "11",
            "question": "listview 优化策略",
            "answer": "1)对 convetView 进行判空,是当 convertView 不为空的时候直接重新使用 convertView 从而减少了很多不必要的 View 的创建\r\n2)定义一个 ViewHolder,将 convetView 的 tag 设置为 ViewHolder,不为空时重新使用即可\r\n3)当 ListView 加载数据量较大时可以采用分页加载和图片异步加载"
        },
        {
            "ID": "168",
            "typeID": "11",
            "question": "什么是ANR如何避免它?(Android线程间的通信方式)",
            "answer": "ANR:Application Not Responding(应用程序无响应).当出现下列情况时,Android就会 显示ANR对话框了:对输入事件(如按键、触摸屏事件)的响应超过5秒 意向接受器 (intentReceiver)超过10秒钟仍未执行完毕 Android 应用程序完全运行在一个独立的线程中 (例如 main)。这就意味着,任何在主线程中运行的,需要消耗大量时间的操作都会引发 ANR。 解决方案有两种:\r\n1)AsyncTask 异步任务中,doInBackground()和 onPostExecute(Result)两个方法非常重要 doInBackground() 这个方法运行在后台线程中,主要负责执行那些很耗时的操作,如移动护理 系统中的网络连接、解析 XML 等操作。该方法必须重载。\r\nonPostExecute(Result) 这个方法也运行于UI线程,在doInBackground(Params...)方法执行后 调用,该方法用于处理后台任务执行后返回的结果。\r\n2) 子 thread + handler"
        },
        {
            "ID": "167",
            "typeID": "11",
            "question": "Android 中的五种存储方式及其应用场景",
            "answer": "1)SharedPreferences\r\n存储路径:(data/data/packagename/shares_prefs), 轻量级存储,以键值对的形式存储在 xml 中,一般用来保存应用中的设置属性\r\n2)文件存储 SD 卡存储多媒体文件, 文件缓存\r\n3) Sqlite 数据库 存储路径:(data/data/packagename/databases), 一种嵌入式数据库,支持 sql 语言,存储大量结构性数据\r\n4)ContentProvider 进程(应用程序)间数据共享,数据源可以是 sqlite,也可以是 xml,相关类: ContentResolver(内容解析器), ContentObserver(数据 观察者)\r\n5) 网络存储 天气数据的 xml,json 格式等等,通过 HttpUrlConnection,HttpClient,或者 SOAP 协议获取数据"
        },
        {
            "ID": "166",
            "typeID": "11",
            "question": "Android 中 asset 文件夹和 raw 文件夹区别",
            "answer": "res/raw 和 assets 的相同点:\r\n两者目录下的文件在打包后会原封不动的保存在 apk 包中,不会被编译成二进制。\r\nres/raw 和 assets 的不同点:\r\n5\r\n1)res/raw中的文件会被映射到R.java文件中,访问的时候直接使用资源ID即 R.raw.filename; assets 文件夹下的文件不会被映射到 R.java 中,访问的时候需要 AssetManager 类。 2)res/raw 不可以有目录结构,而 assets 则可以有目录结构,也就是 assets 目录下可以再建 立文件夹\r\n3)读取文件资源举例:\r\n读取 res/raw 下的文件资源,通过以下方式获取输入流来进行写操作\r\nInputStream is = getResources().openRawResource(R.raw.filename);\r\n读取 assets 下的文件资源,通过以下方式获取输入流来进行写操作\r\nAssetManager am = null;\r\nam = getAssets();\r\nInputStream is = am.open(\"filename\");"
        },
        {
            "ID": "165",
            "typeID": "11",
            "question": "activity 在屏幕旋转时的生命周期",
            "answer": "不设置 Activity 的 android:configChanges 时,切屏会重新调用各个生命周期,切横屏时 会执行一次,切竖屏时会执行两次;设置 Activity 的 android:configChanges=\"orientation\" 时,切屏还是会重新调用各个生命周期,切横、竖屏时只会执行一次;设置 Activity 的 android:configChanges=\"orientation|keyboardHidden\"时,切屏不会重新调用各个生命周期, 只会执行 onConfigurationChanged 方法"
        },
        {
            "ID": "164",
            "typeID": "11",
            "question": "Android的四大组件作用是什么？",
            "answer": "Activity :应用程序中,一个 Activity 通常就是一个单独的屏幕,它上面可以显示一些控件也 可以监听并处理用户的事件做出响应。Activity 之间通过 Intent 进行通信。 Service 服务:一个 Service 是一段长生命周期的,没有用户界面的程序,可以用来开发如监控 类程序。 BroadcastReceive 广播接收器:你的应用可以使用它对外部事件进行过滤只对感兴趣的外部事 件(如当电话呼入时,或者数据网络可用时)进行接收并做出响应。广播接收器没有用户界面。然 而,它们可以启动一个 activity 或 serice 来响应它们收到的信息。 Content Provider 内容提供者 :主要用于多个应用间数据共享。这些数据可以存储在文件系统 中或 SQLite 数据库。"
        },
        {
            "ID": "163",
            "typeID": "11",
            "question": "Activity 的 onSaveInstanceState() 和 onRestoreInstanceState()",
            "answer": "Activity 的 onSaveInstanceState() 和 onRestoreInstanceState()并不是生命周期方法, 它们不同于 onCreate()、onPause()等生命周期方法,它们并不一定会被触发。当应用遇到意外 情况(如:内存不足、用户直接按 Home 键)由系统销毁一个 Activity 时,onSaveInstanceState() 会被调用。但是当用户主动去销毁一个 Activity 时,例如在应用中按返回键, onSaveInstanceState()就不会被调用。因为在这种情况下,用户的行为决定了不需要保存 Activity 的状态。通常 onSaveInstanceState()只适合用于保存一些临时性的状态,而 onPause() 适合用于数据的持久化保存。  \r\n另外,当屏幕的方向发生了改变, Activity 会被摧毁并且被重新创建,如果你想在 Activity 被摧毁前缓存一些数据,并且在 Activity 被重新创建后恢复缓存的数据。可以重写 Activity 的 onSaveInstanceState() 和 onRestoreInstanceState()方法。"
        },
        {
            "ID": "162",
            "typeID": "11",
            "question": "Activity 生命周期?保存 activity 的一些信息在哪个生命周期方法中横竖屏切换 activity 的生命周期",
            "answer": "共有七个周期函数:\r\nvoid onCreate(Bundle savedInstanceState) 第一次创建时调用\r\nvoid onStart() 被用户可见时调用\r\nvoid onRestart() 当 Activity 处于 stop 状态又被重新启动时调用\r\nvoid onResume() 当获得焦点即可与用户交互时调用\r\nvoid onPause() 当失去焦点时调用\r\nvoid onStop() 当不可见时调用\r\nvoid onDestroy() 当销毁时调用"
        },
        {
            "ID": "161",
            "typeID": "11",
            "question": "Android 的四大组件是什么?",
            "answer": "Android 有四大组件:Activity、Service、Broadcast Receiver、Content Provider。"
        },
        {
            "ID": "160",
            "typeID": "11",
            "question": "android 系统架构",
            "answer": "1)应用程序层 java 语言 应用程序开发 \r\n2)应用程序框架层 java 语言 OS 定制 framework 层开发\r\n3)系统运行库层 C C++ 实现 so 库\r\n4)Linux 内核层"
        },
        {
            "ID": "159",
            "typeID": "11",
            "question": "广播如何调用,有什么方式,各自的区别,实现广播的意图是什么,哪里用到",
            "answer": "程序中发送广播通过 sendBroadcastReceiver()实现\r\n接收广播通过定义一个类继承 BroadcastReceiver 并重写 onReceive()方法实现 注册广播有两种方式:\r\n第一种静态方式:在清单文件中通过<receive>标签声明\r\n第二种代码动态方式:\r\nIntentFilter filter = new IntentFilter(\"android.provider.Telephony.SMS_RECEIVED\"); IncomingSMSReceiver receiver = new IncomgSMSReceiver(); registerReceiver(receiver.filter);\r\n1)第一种不是常驻型广播,也就是说广播跟随 activity 的生命周期。注意: 在 activity 结束 前,移除广播接收器。\r\n2)第二种是常驻型,也就是说当应用程序关闭后,如果有信息广播来,程序也会被系统调用自 动运行。"
        },
        {
            "ID": "158",
            "typeID": "11",
            "question": "常用设计模式及应用场景",
            "answer": "常用设计模式及应用场景,用两种方式实现单例模式,要求线程安全\r\n常用设计模式:\r\n单例模式: Calendar 实例的获取\r\n适配器模式: Adapter 为 ListView GridView 等添加数据\r\n工厂模式: Spring IOC 反转控制\r\n代理模式: Spring AOP 面向切面编程\r\n观察者模式: ContentObserver 监听内容改变 (懒汉式)程序执行过程中需要这个类的对象时再实例化该类的对象"
        },
        {
            "ID": "157",
            "typeID": "11",
            "question": "sleep() 与 wait()的区别？",
            "answer": "1这两个方法来自不同的类分别是,sleep 来自 Thread 类,和 wait 来自 Object\r\n类。\r\n2最主要是 sleep 方法没有释放锁,而 wait 方法释放了锁,使得其他线程可 以使用同步控制块或者方法。sleep 不出让系统资源;wait 是进入线程等待池 等待,出让系统资源,其他线程可以占用 CPU。一般 wait 不会加时间限制, 因为如果 wait 线程的运行资源不够,再出来也没用,要等待其他线程调用 notify/notifyAll 唤醒等待池中的所有线程,才会进入就绪队列等待 OS 分配系 统资源。sleep(milliseconds)可以用时间指定使它自动唤醒过来,如果时间不到 只能调用 interrupt()强行打断。\r\n"
        },
        {
            "ID": "156",
            "typeID": "11",
            "question": "线程的实现方式",
            "answer": "线程的实现有两种方式,一是继承 Thread 类,二是实现 Runnable 接口"
        },
        {
            "ID": "155",
            "typeID": "11",
            "question": "线程有几种状态,分别是哪些(调用 run()和调用 start()的区别)",
            "answer": "1)新建状态(New):新创建了一个线程对象。 2)就绪状态(Runnable):线程对象创建后,其他线程调用了该对象的 start()方法。该状态的\r\n线程位于可运行线程池中,变得可运行,等待获取 CPU 的使用权。 3)运行状态(Running):就绪状态的线程获取了 CPU,执行 run()方法。 4)阻塞状态(Blocked):阻塞状态是线程因为某种原因放弃 CPU 使用权,暂时停止运行。直\r\n到线程进入就绪状态,才有机会转到运行状态。阻塞的情况分三种: 1等待阻塞:运行的线程执行 wait()方法,JVM 会把该线程放入等待池中。 2同步阻塞:运行的线程在获取对象的同步锁时,若该同步锁被别的线程占用,则 JVM 会把该 线程放入锁池中。\r\n3其他阻塞:运行的线程执行 sleep()或 join()方法,或者发出了 I/O 请求时,JVM 会把该线程置 为阻塞状态。当 sleep()状态超时、join()等待线程终止或者超时、或者 I/O 处理完毕时,线程重 新转入就绪状态。\r\n5)死亡状态(Dead):线程执行完了或者因异常退出了 run()方法,该线程结束生命周期。\r\n当调用 start 方法的时候,该线程就进入就绪状态。等待 CPU 进行调度执行,此时还没有真正执 行线程。\r\n当调用 run 方法的时候,是已经被 CP U 进行调度,执行线程的主要任务。"
        },
        {
            "ID": "154",
            "typeID": "11",
            "question": "抽象类与接口的区别(abstract 与 interface 的区别)",
            "answer": "abstract 可以修饰抽象方法,而一个类只要有一个抽象方法,就必须用 abstract 定义该类,\r\n抽象类,被继承,实现它里面的方法,可以只有普通方法"
        },
        {
            "ID": "153",
            "typeID": "11",
            "question": "实现一个字符串倒序",
            "answer": "字符串“abcde”通过写一个函数不让调用第三方的字符串,实现一个字符串倒序,比如字符串 “abcde” 变成“edcba”\r\n答: String src = \"ABCDEF \";\r\nString dst = new StringBuffer(src).reverse().toString();"
        },
        {
            "ID": "152",
            "typeID": "11",
            "question": "String 和StringBuffer的区别",
            "answer": "STRING的长度是不可变的，STRINGBUFFER的长度是可变的。如果你对字符串中的内容经常进行操作，特别是内容要修改时，那么使用StringBuffer，如果最后需要String，那么使用StringBuffer（缓存）的toString()方法。 \r\nStringBuilder：节约内存，创建字符串；\r\n"
        },
        {
            "ID": "151",
            "typeID": "11",
            "question": "Overload和Override的区别",
            "answer": "Overloaded的方法是否可以改变返回值的类型?\r\n方法的重写Overriding和重载Overloading是Java多态性的不同表现。重写Overriding是父类与子类之间多态性的一种表现，重载Overloading是一个类中多态性的一种表现。如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写 (Overriding)。子类的对象使用这个方法时，将调用子类中的定义，对它而言，父类中的定义如同被\"屏蔽\"了。如果在一个类中定义了多个同名的方法，它们或有不同的参数个数或有不同的参数类型，则称为方法的重载(Overloading)。Overloaded的方法是可以改变返回值的类型。\r\n"
        },
        {
            "ID": "54",
            "typeID": "11",
            "question": "swtich是否能作用在byte上，是否能作用在long上，是否能作用在String上",
            "answer": "witch（expr1）中，expr1是一个整数表达式。因此传递给 switch 和 case 语句的参数应该是 int、 short、 char 或者 byte。long,string 都不能作用于swtich"
        },
        {
            "ID": "53",
            "typeID": "11",
            "question": "ArrayList和Vector的区别,HashMap和Hashtable的区别",
            "answer": "就ArrayList与Vector主要从二方面来说.\r\n一.同步性:Vector是线程安全的，也就是说是同步的，而ArrayList是线程序不安全的，不是同步的\r\n二.数据增长:当需要增长时,Vector默认增长为原来一培，而ArrayList却是原来的一半\r\n就HashMap与HashTable主要从三方面来说。\r\n一.历史原因:Hashtable是基于陈旧的Dictionary类的，HashMap是Java 1.2引进的Map接口的一个实现\r\n二.同步性:Hashtable是线程安全的，也就是说是同步的，而HashMap是线程序不安全的，不是同步的\r\n三.值：只有HashMap可以让你将空值作为一个表的条目的key或value "
        },
        {
            "ID": "52",
            "typeID": "11",
            "question": "抽象类与接口？",
            "answer": "抽象类与接口都用于抽象，但是抽象类(JAVA中)可以有自己的部分实现，而接口则完全是一个标识(同时有多重继承的功能)。 \r\nJAVA类实现序例化的方法是实现java.io.Serializable接口\r\nCollection框架中实现比较要实现Comparable 接口和 Comparator 接口"
        },
        {
            "ID": "51",
            "typeID": "11",
            "question": "STRING与STRINGBUFFER的区别",
            "answer": "STRING的长度是不可变的，STRINGBUFFER的长度是可变的。如果你对字符串中的内容经常进行操作，特别是内容要修改时，那么使用StringBuffer，如果最后需要String，那么使用StringBuffer的toString()方法"
        },
        {
            "ID": "50",
            "typeID": "11",
            "question": "谈谈final, finally, finalize?",
            "answer": "final是修饰符（关键字）如果一个类被声明为final，意味着它不能再派生出新的子类，不能作为父类被继承。因此一个类不能既被声明为 abstract，又被声明为final.将变量或方法声明为final，可以保证它们在使用中不被改变。被声明为final的变量必须在声明时给定初值，而在以后的引用中只能读取，不可修改。被声明为final的方法也同样只能使用，不能重载。Finally是在异常处理时提供 finally 块来执行任何清除操作。如果抛出一个异常，那么相匹配的 catch 子句就会执行，然后控制就会进入 finally 块（如果有的话），只要有finally语句块，无论程序如何运行，它都必然被执行到。"
        },
        {
            "ID": "49",
            "typeID": "11",
            "question": "error和exception有什么区别",
            "answer": "error 表示恢复不是不可能但很困难的情况下的一种严重问题。比如说内存溢出。不可能指望程序能处理这样的情况\r\n    exception 表示一种设计或实现问题。也就是说，它表示如果程序运行正常，从不会发生的情况"
        },
        {
            "ID": "48",
            "typeID": "11",
            "question": "Set里的元素是不能重复的，那么用什么方法来区分重复与否呢? 是用==还是equals()? 它们有何区别",
            "answer": "Set里的元素是不能重复的，那么用iterator()方法来区分重复与否。equals()是判读两个Set是否相等\r\n    equals()和==方法决定引用值是否指向同一对象equals()在类中被覆盖，为的是当两个分离的对象的内容和类型相配的话，返回真值"
        },
        {
            "ID": "47",
            "typeID": "11",
            "question": "Overload和Override的区别。Overloaded的方法是否可以改变返回值的类型",
            "answer": "方法的重写Overriding和重载Overloading是Java多态性的不同表现。重写Overriding是父类与子类之间多态性的一种表现，重载Overloading是一个类中多态性的一种表现。如 果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写 (Overriding)。子类的对象使用这个方法时，将调用子类中的定义，对它 而言，父类中的定义如同被\"屏蔽\"了。如果在一个类中定义了多个同名的方法，它们或有不同的参数个数或有不同的参数类型，则称为方法的重载 (Overloading)。Overloaded的方法是可以改变返回值的类型"
        },
        {
            "ID": "46",
            "typeID": "11",
            "question": "数组有没有length()这个方法? String有没有length()这个方法",
            "answer": "数组没有length()这个方法，有length的属性。String有length()这个方法"
        },
        {
            "ID": "45",
            "typeID": "11",
            "question": "short s1 = 1; s1 = s1 + 1;有什么错? short s1 = 1; s1 += 1;有什么错",
            "answer": "short s1 = 1; s1 = s1 + 1; （s1+1运算结果是int型，需要强制转换类型）short s1 = 1; s1 += 1;（可以正确编译）"
        },
        {
            "ID": "44",
            "typeID": "11",
            "question": "Math.round(11.5)等於多少? Math.round(-11.5)等於多少",
            "answer": " Math.round(11.5)==12;Math.round(-11.5)==-11;round方法返回与参数最接近的长整数，参数加1/2后求其floor"
        },
        {
            "ID": "43",
            "typeID": "11",
            "question": "String s = new String(\"xyz\");创建了几个String Object",
            "answer": "两个，一个字符对象，一个字符对象引用对象"
        },
        {
            "ID": "42",
            "typeID": "11",
            "question": "什么时候用assert?",
            "answer": "：assertion(断言)在软件开发中是一种常用的调试方式，很多开发语言中都支持这种机制。在实现中，assertion就是在程序中的一条语句，它对一个boolean表达式进行检查，一个正确程序必须保证这个boolean表达式的值为true；如果该值为false，说明程序已经处于不正确的状态下，系统将给出警告或退出。一般来说，assertion用于保证程序最基本、关键的正确性。assertion检查通常在开发和测试时开启。为了提高性能，在软件发布后，assertion检查通常是关闭的"
        },
        {
            "ID": "41",
            "typeID": "11",
            "question": "Collection 和 Collections的区别?",
            "answer": "Collection是集合类的上级接口，继承与他的接口主要有Set 和List.\r\nCollections是针对集合类的一个帮助类，他提供一系列静态方法实现对各种集合的搜索、排序、线程安全化等操作"
        },
        {
            "ID": "40",
            "typeID": "11",
            "question": "&和&&的区别",
            "answer": "&是位运算符，表示按位与运算，&&是逻辑运算符，表示逻辑与（and）"
        },
        {
            "ID": "39",
            "typeID": "11",
            "question": "Static Nested Class 和 Inner Class的不同",
            "answer": "Nested Class （一般是C++的说法），Inner Class (一般是JAVA的说法)。Java内部类与C++嵌套类最大的不同就在于是否有指向外部的引用上。注： 静态内部类（Inner Class）意味着1创建一个static内部类的对象，不需要一个外部类对象，2不能从一个static内部类的一个对象访问一个外部类对象!"
        },
        {
            "ID": "38",
            "typeID": "11",
            "question": "Anonymous Inner Class (匿名内部类) 是否可以extends(继承)其它类，是否可以implements(实现)interface(接口)",
            "answer": "匿名的内部类是没有名字的内部类。不能extends(继承) 其它类，但一个内部类可以作为一个接口，由另一个内部类实现"
        },
        {
            "ID": "13",
            "typeID": "11",
            "question": "ContentProvider是如何实现数据共享的？",
            "answer": "创建一个属于你自己的Content provider或者将你的数据添加到一个已经存在的Content provider中，前提是有相同数据类型并且有写入Content provider的权限。"
        },
        {
            "ID": "12",
            "typeID": "11",
            "question": "Android中常用的五种布局？",
            "answer": "FrameLayout（框架布局），LinearLayout （线性布局），AbsoluteLayout（绝对布局），RelativeLayout（相对布局），TableLayout（表格布局）。"
        },
        {
            "ID": "11",
            "typeID": "11",
            "question": "介绍下Android的数据存储方式有哪几种？",
            "answer": "Android 提供了5种方式存储数据：\r\n--使用SharedPreferences存储数据；\r\n--文件存储数据；\r\n--SQLite数据库存储数据；\r\n--使用ContentProvider存储数据；\r\n--网络存储数据；"
        }
    ]


